<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[React Redux Router学习路线]]></title>
      <url>%2F2017%2F05%2F12%2F216React-Redux-Router%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF%2F</url>
      <content type="text"><![CDATA[1 React Redux Router学习首先英文得要过关,因为需要看英文文档 ; 第一步 react demo 第二步 redux demo 源码实现 第三步 router demo 学习方法推荐,基础最重要,源码很重要 github上搜索 分别单独搜索 react redux react-router react-redux react-redux -router google搜索 说句实话,谷歌要比百度靠谱太多,google搜索都是干货,百度甩给你的可能是bug 知乎搜索 react ,有一些话题以及问题会由比较好的链接 2 项目理解react-redux-router react-redux react-router 3 我的博客也有一些自己学习的总结,感兴趣也可以看下.后期会补充,欢迎交流]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[webpack模块路径解析规则]]></title>
      <url>%2F2017%2F05%2F11%2F214webpack%E6%A8%A1%E5%9D%97%E8%B7%AF%E5%BE%84%E8%A7%A3%E6%9E%90%E8%A7%84%E5%88%99%2F</url>
      <content type="text"><![CDATA[模块解析##1 首先来看下webpack支持的模块类型 ###模块(Modules) EDIT DOCUMENT** 在模块化编程中，开发者将程序分解成离散功能块(discrete chunks of functionality)，并称之为模块。 每个模块具有比完整程序更小的接触面，使得校验、调试、测试轻而易举。 精心编写的模块提供了可靠的抽象和封装界限，使得应用程序中每个模块都具有条理清楚的设计和明确的目的。 Node.js 从最一开始就支持模块化编程。然而，在 web，模块化的支持正缓慢到来。在 web 存在多种支持 JavaScript 模块化的工具，这些工具各有优势和限制。webpack 基于从这些系统获得的经验教训，并将模块的概念应用于项目中的任何文件。 ###什么是 webpack 模块 对比 Node.js 模块，webpack 模块能够以各种方式表达它们的依赖关系，几个例子如下： ES2015 import 语句 CommonJS require() 语句 AMD define 和 require 语句 css/sass/less 文件中的 @import 语句。 样式(url(...))或 HTML 文件(&lt;img src=...&gt;)中的图片链接(image url) webpack 1 需要特定的 loader 来转换 ES 2015 import，然而通过 webpack 2 可以开箱即用。 支持的模块类型webpack 通过 loader 可以支持各种语言和预处理器编写模块。loader 描述了 webpack 如何处理 非 JavaScript(non-JavaScript) 模块，并且在bundle中引入这些依赖。 webpack 社区已经为各种流行语言和语言处理器构建了 loader，包括： CoffeeScript TypeScript ESNext (Babel) Sass Less Stylus 总的来说，webpack 提供了可定制的、强大和丰富的 API，允许任何技术栈使用 webpack，保持了在你的开发、测试和生成流程中无侵入性(non-opinionated)。 2 webpack可以解析的文件路径(import语句会执行所加载的模块，可以有下面的写法) 绝对路径12import "/home/me/file";import "C:\\Users\\me\\file"; 由于我们已经取得文件的绝对路径，因此不需要进一步再做解析。 也就是说不需要webpack进行路径的解析. 相对路径12import "../src/file1";import "./file2"; 在这种情况下，使用 import 或 require 的资源文件(resource file)所在的目录被认为是上下文目录(context directory)。在 import/require 中给定的相对路径，会添加此上下文路径(context path)，以产生模块的绝对路径(absolute path)。 也就是说webpack解析该文件的时候,会以资源文件所在目录为基准进行解析; 模块路径12import "module";import "module/lib/file"; 模块将在 resolve.modules 中指定的所有目录内搜索。 也就是说对于模块路径,解析的时候会在node_modules目录下进行解析 告诉 webpack 解析模块时应该搜索的目录。 绝对路径和相对路径都能使用，但是要知道它们之间有一点差异。 通过查看当前目录以及祖先路径（即 ./node_modules, ../node_modules 等等），相对路径将类似于 Node 查找 ‘node_modules’ 的方式进行查找。 使用绝对路径，将只在给定目录中搜索。 resolve.modules defaults to: 1modules: [&quot;node_modules&quot;] 如果你想要添加一个目录到模块搜索目录，此目录优先于 node_modules/ 搜索： 1modules: [path.resolve(__dirname, &quot;src&quot;), &quot;node_modules&quot;] 你可以替换初始模块路径，此替换路径通过使用 resolve.alias 配置选项来创建一个别名。 此时在解析模块路径的时候,就不会再去node_modules里面查找对应的模块,而是通过我们配置的路径进行查找 比如App.js中 12import store, &#123; history &#125; from 'STORE'import routes from 'ROUTE' from后面就是要解析的路径,此处的路径是模块路径; webpack.config.js中 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253var path = require('path'), webpack = require('webpack'), NyanProgressPlugin = require('nyan-progress-webpack-plugin');var rootPath = path.resolve(__dirname, '..'), // 项目根目录,__diename永远获取的是当前文件相对于磁盘根目录 react-demo/ 目录下 src = path.join(rootPath, 'src'), // 开发源码目录 env = process.env.NODE_ENV.trim(); // 当前环境var commonPath = &#123; rootPath: rootPath, dist: path.join(rootPath, 'dist'), // build 后输出目录 indexHTML: path.join(src, 'index.html'), // 入口基页 staticDir: path.join(rootPath, 'static') // 无需处理的静态资源目录&#125;;module.exports = &#123; commonPath: commonPath, entry: &#123; app: path.join(src, 'app.js'), // ================================ // 框架 / 类库 分离打包 // ================================ vendor: [ 'history', 'lodash', 'react', 'react-dom', 'react-redux', 'react-router', 'react-router-redux', 'redux', 'redux-thunk' ] &#125;, output: &#123; path: path.join(commonPath.dist, 'static'), publicPath: '/static/' &#125;, resolve: &#123; extensions: ['', '.js', '.jsx'], alias: &#123; // ================================ // 自定义路径别名 // ================================ STORE: path.join(src, 'redux/store'), ROUTE: path.join(src, 'routes'),//对应src/routers文件夹 &#125; &#125;, &#125;; resolveLoader: &#123; root: path.join(rootPath, 'node_modules') &#125;, 3一旦根据上述规则解析路径之后,解析器将检查路径是否指向文件或者目录 文件 : 如果以上提到的路径(相对路径,模块路径,绝对路径),指向的是一个文件 如果文件具有文件扩展名,则将文件直接打包 否则将使用[resolve.extensions]作为文件扩展名来解析,此选项告诉解析器在解析的时候能够接受那些扩展名 文件夹 : 如果路径指向的是一个文件夹 如果文件夹中包含 package.json 文件，则按照顺序查找 resolve.mainFields 配置选项中指定的字段。并且 package.json 中的第一个这样的字段确定文件路径。 If there is no package.json or if the main fields do not return a valid path, file names specified in the resolve.mainFiles configuration option are looked for in order, to see if a matching filename exists in the imported/required directory . 如果目录中没有package.json文件,那么将会根据reslove(解析对象)中的默认配置resolve.mainFiles中的配置文件名去该目录中解析配置的文件名,默认配置如下 . 1mainFiles: [&quot;index&quot;] 也就是说会import index文件,该文件的导出的对象. The file extension is then resolved in a similar way using the resolve.extensions option. 4 loaders的解析规则loader解析遵循与文件解析器指定的规则相同. 但是resolveloader配置选项可以用来为Loader提供独立的解析规则 12345resolveloader : &#123; modules: ["node_modules"], extensions: [".js", ".json"], mainFields: ["loader", "main"]&#125; 5 从缓存中解析模块Every filesystem access is cached, so that multiple parallel or serial requests to the same file occur faster. In watch mode, only modified files are evicted from the cache. If watch mode is off, then the cache gets purged before every compilation. 每一个文件都会被缓存,所以对于同一文件的并行的请求将可以更快的请求到模块,在观察者模式下,只用改变了的文件将会从缓存中抽出,如果观察者模式关闭,那么每次编译之前都会清理缓存.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Redux Provider Connect]]></title>
      <url>%2F2017%2F05%2F11%2F215Redux-Provider-Connect%2F</url>
      <content type="text"><![CDATA[我是一个不信邪的人,所以无论如何我也要把这个搞明白 ###1Provider核心源码 123456789101112131415161718192021222324var Provider = function (_Component) &#123; _inherits(Provider, _Component); Provider.prototype.getChildContext = function getChildContext() &#123; return &#123; store: this.store &#125;; &#125;; function Provider(props, context) &#123; _classCallCheck(this, Provider); var _this = _possibleConstructorReturn(this, _Component.call(this, props, context)); //这行代码是我加的测试代码,在控制台输出的就是一个Provider对象 console.log(_this); _this.store = props.store; return _this; &#125; Provider.prototype.render = function render() &#123; return _react.Children.only(this.props.children); &#125;; return Provider;&#125;(_react.Component); 使用如下:provider的主要作用就是将store作为props对象中的一个属性传递给Provider对象 123456789const store = createStore(reducer)const App = () =&gt; &#123; return ( &lt;Provider store=&#123;store&#125;&gt; &lt;Comp/&gt; &lt;/Provider&gt; )&#125;; ========= after four hours 我有点信邪了 , 毕竟我是才学这个的小白. Provider 内的任何一个组件（比如这里的 Comp），如果需要使用 state 中的数据，就必须是「被 connect 过的」组件——使用 connect 方法对「你编写的组件（MyComp）」进行包装后的产物。 12 参考]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[React-router Foundation]]></title>
      <url>%2F2017%2F05%2F09%2F213React-router-Foundation%2F</url>
      <content type="text"><![CDATA[参考此文章,具体的demo以及相关配置都有,大家可以直接看这个即可,我写的只是为了让自己理解深刻 react-router-tutorial 1 React-Router用来配合React来使用,对于不同的组件,根据不同的url地址进行不同的组件的渲染还是从本质上先大概了解下Router和Route分别是什么 1234import &#123; Router, Route, hashHistory &#125; from 'react-router'console.log('Router',Router);console.log('Route',Route); 12345678910Router function (props, context, updater) &#123; // This constructor is overridden by mocks. The argument is used // by mocks to assert on what gets mounted. if (process.env.NODE_ENV !== &apos;production…Route function (props, context, updater) &#123; // This constructor is overridden by mocks. The argument is used // by mocks to assert on what gets mounted. if (process.env.NODE_ENV !== &apos;production… 可以看出,它们也是一般的组件创建函数,然后通过类似于下面的方法进行调用即可 12345&lt;Router history=&#123;hashHistory&#125;&gt; &lt;Route path="/" component=&#123;App&#125;/&gt; &lt;Route path='/about' component=&#123;About&#125;/&gt; &lt;Route path='/repo' component=&#123;Repo&#125;/&gt; &lt;/Router&gt; 最终实现的功能就会根据不同的路由渲染不同的组件 2 如上实现根据不同的url地址的实现方案,需要我们在地址栏手动输入相关地址,才可以访问,这个时候Link组件12import &#123;Link&#125; from 'react-router'console.log('Link',Link); 12345Link function (props, context, updater) &#123; // This constructor is overridden by mocks. The argument is used // by mocks to assert on what gets mounted. if (process.env.NODE_ENV !== &apos;production… 其实我们发现 Router Route Link等也都是一些组件而已,实现的功能就是根据不同的url地址进行不同组件的渲染. 123456789101112131415161718import React from 'react'import &#123;Link&#125; from 'react-router'console.log('Link',Link);export default React.createClass(&#123; render() &#123; return ( &lt;div&gt; &lt;h1&gt;React Router Tutorial&lt;/h1&gt; &lt;ul role = 'nav'&gt; &lt;li&gt;&lt;Link to='/about'&gt;About&lt;/Link&gt;&lt;/li&gt; &lt;li&gt;&lt;Link to='/repo'&gt;Repo&lt;/Link&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; ) &#125;&#125;) Link组件的作用和我们平常用的&lt;a&gt;标签的作用大同小异 . 同样我们也可以封装一个Link ,该link可以有一些样式,以后在这个组件就可以被复用. 123456789// modules/NavLink.jsimport React from &apos;react&apos;import &#123; Link &#125; from &apos;react-router&apos;export default React.createClass(&#123; render() &#123; return &lt;Link &#123;...this.props&#125; activeClassName=&quot;active&quot;/&gt; &#125;&#125;) 3 React-router的工作 原理其实 就是根据url地址栏不同的地址,然后可以渲染不同的组件在路由中 1this.props.children 至关重要,理解它就算基本上理解了路由的基本原理 先贴上参考链接吧 xianyulaodi App组件 12345678910111213141516171819202122const App=React.createClass(&#123; render() &#123; return ( &lt;div className=&quot;mp_wrap bui_wrap&quot;&gt; &#123;/**主屏幕**/&#125; &lt;div className=&quot;mp_pagebox_home&quot;&gt; &#123;/**这里面的内容会被子路由给代替**/&#125; &#123;this.props.children&#125; &#123;/**注意这个this.props.children**/&#125; &#123;/**公共页脚**/&#125; &lt;div className=&quot;mp_page_footer&quot;&gt; &lt;Footer /&gt; &lt;/div&gt; &#123;/**公共页脚**/&#125; &lt;/div&gt; &#123;/**主屏幕**/&#125; &lt;/div&gt; ) &#125;&#125;); 路由的配置 1234567891011121314151617181920212223242526render(( &lt;Router&gt; &lt;Route path=&quot;/&quot; component=&#123;App&#125;&gt; &lt;IndexRoute component=&#123;Index&#125; /&gt; &lt;Route path=&quot;/type/:typeName&quot; component=&#123;Type&#125; /&gt; &lt;Route path=&quot;/mall&quot; component=&#123;Mall&#125;&gt; &lt;Route path=&quot;type/:typeName&quot; component=&#123;Type&#125; /&gt; &lt;/Route&gt; &lt;Route path=&quot;/my&quot; component=&#123;My&#125;&gt; &lt;IndexRoute component=&#123;MyNav&#125; /&gt; &lt;Route path=&quot;userCenter&quot; component=&#123;MyUserCenter&#125; /&gt; &lt;Route path=&quot;memberClub&quot; component=&#123;MemberClub&#125; /&gt; &lt;/Route&gt; &lt;Route path=&quot;/circle&quot; component=&#123;Circle&#125;&gt; &lt;IndexRoute component=&#123;CircleType&#125; /&gt; &lt;Route path=&quot;tip/:tipName&quot; component=&#123;CircleTip&#125; /&gt; &lt;Route path=&quot;say&quot; component=&#123;CircleSay&#125; /&gt; &lt;/Route&gt; &lt;/Route&gt; &lt;/Router&gt;), document.getElementById(&apos;index&apos;)) 123&#123;/**这里面的内容会被子路由给代替**/&#125;&#123;this.props.children&#125;&#123;/**注意这个this.props.children**/&#125; 在这里面 this.props.children会更具不同的url地址加载不同的组件 默认加载的组件是Index 如果url 是 /my ,那么就会加载 My组件 123456789101112这里是my.js文件,也就是my组件var Content= React.createClass(&#123; render()&#123; return ( &lt;div className = &apos;myWrap&apos;&gt; &#123;this.props.children&#125; &lt;/div&gt; ) &#125;&#125;) my组件在渲染的时候,默认渲染的是MyNav组件, 12345&lt;Route path=&quot;/my&quot; component=&#123;My&#125;&gt; &lt;IndexRoute component=&#123;MyNav&#125; /&gt; &lt;Route path=&quot;userCenter&quot; component=&#123;MyUserCenter&#125; /&gt; &lt;Route path=&quot;memberClub&quot; component=&#123;MemberClub&#125; /&gt;&lt;/Route&gt; 如果url地址栏是/my/userCenter,则会加载MyUserCenter组件 所以要理解路由的匹配原理 嵌套关系: 中文网的解释：React Router 使用路由嵌套的概念来让你定义 view 的嵌套集合，当一个给定的 URL 被调用时，整个集合中（命中的部分）都会被渲染。 嵌套路由被描述成一种树形结构。React Router 会深度优先遍历整个路由配置来寻找一个与给定的 URL 相匹配的路由。 什么意思呢。上面的入口文件中，可以看到，其他路由都是最外层那个app（也就是这个 &lt;Route path=&quot;/&quot; component={App}&gt;）的子路由，其他路由都是嵌套在这里面。 当url变化是，它里面的{this.props.children}都会替换，也就是所谓的整个集合的命中部分都会被渲染。 路径语法: 路由路径是匹配一个（或一部分）URL 的 一个字符串模式。大部分的路由路径都可以直接按照字面量理解，除了以下几个特殊的符号： :paramName – 匹配一段位于 /、? 或 # 之后的 URL。 命中的部分将被作为一个参数 () – 在它内部的内容被认为是可选的 * – 匹配任意字符（非贪婪的）直到命中下一个字符或者整个 URL 的末尾，并创建一个 splat 参数 123&lt;Route path=&quot;/hello/:name&quot;&gt; // 匹配 /hello/michael 和 /hello/ryan&lt;Route path=&quot;/hello(/:name)&quot;&gt; // 匹配 /hello, /hello/michael 和 /hello/ryan&lt;Route path=&quot;/files/*.*&quot;&gt; // 匹配 /files/hello.jpg 和 /files/path/to/hello.jpg 如果一个路由使用了相对路径，那么完整的路径将由它的所有祖先节点的路径和自身指定的相对路径拼接而成。使用绝对路径可以使路由匹配行为忽略嵌套关系。 4 路由中的参数传递render/app.js中 注意此时的 : 冒号后面的变量就可 以通过 this.props.params 1 通过如下这种方式定义变量 1&lt;Route path=&quot;/type/:typeName&quot; component=&#123;Type&#125; /&gt; 上面这行route配置 , : typeName是一个变量 , 对于不同的变量值 , 在Type中该变量值可以通过 1this.props.params 来获取. Type组件中 123456const &#123; typeName &#125; = this.props.params&lt;h2&gt;&#123;typeName&#125;&lt;/h2&gt;&lt;Link to=&quot;/type/饼干&quot;&gt; &lt;p className=&quot;icon icon1&quot;&gt;&lt;/p&gt; &lt;p className=&quot;bui_ta_c bui_tc_gray&quot;&gt;饼干&lt;/p&gt;&lt;/Link&gt; 当我们点击Link标签的时候,h2中既可以获取到此时]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[React创建组件的三种方式]]></title>
      <url>%2F2017%2F05%2F09%2F212React%E5%88%9B%E5%BB%BA%E7%BB%84%E4%BB%B6%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[1 React.createClass( )123456789101112131415161718&lt;body&gt; &lt;div id="root"&gt;&lt;/div&gt; &lt;script type='text/babel'&gt; var HelloWorld = React.createClass(&#123; render : function()&#123; return &lt;h1&gt;hello &#123;this.props.name1&#125; &lt;p&gt;hello &#123;this.props.name2&#125;&lt;/p&gt; &lt;/h1&gt; &#125; &#125;) ; ReactDOM.render( &lt;HelloWorld name1='Jhon' name2="JiM" /&gt;, document.getElementById('root') ) &lt;/script&gt;&lt;/body&gt; 2 React.Component123456789101112131415&lt;div id="root"&gt;&lt;/div&gt;&lt;script type='text/babel'&gt; class Welcome extends React.Component &#123; render()&#123; return &lt;h1&gt;hello &#123;this.props.name&#125;&lt;/h1&gt; &#125; &#125; const element = &lt;Welcome name = 'JiM'/&gt; ReactDOM.render( element, document.getElementById('root') ) &lt;/script&gt; 3 function123456789101112131415161718192021222324252627&lt;div id="root"&gt;&lt;/div&gt;&lt;script type='text/babel'&gt; function Welcome(props)&#123; console.log(props) return &lt;h1&gt;hello &#123;props.name&#125;&lt;/h1&gt; &#125; function App()&#123; return ( &lt;div&gt; &lt;Welcome name = 'Jhon'/&gt; &lt;Welcome name = 'JiM'/&gt; &lt;Welcome name = 'Kobe'/&gt; &lt;/div&gt; ); &#125; const element = &lt;App /&gt; ReactDOM.render( element , document.getElementById('root') )&lt;/script&gt; ###]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[React概览]]></title>
      <url>%2F2017%2F05%2F09%2F211React%E6%A6%82%E8%A7%88%2F</url>
      <content type="text"><![CDATA[1 React中有什么顶层API123456&lt;body&gt; &lt;script src='../build/react-0.13.4.js'&gt;&lt;/script&gt; &lt;script&gt; console.log(React); &lt;/script&gt;&lt;/body&gt; 控制台输出就是如下React对象 12345678910111213141516171819202122232425262728293031323334var React = &#123; Children: &#123; map: ReactChildren.map, forEach: ReactChildren.forEach, count: ReactChildren.count, only: onlyChild &#125;, Component: ReactComponent, DOM: ReactDOM, PropTypes: ReactPropTypes, initializeTouchEvents: function(shouldUseTouch) &#123; EventPluginUtils.useTouchEvents = shouldUseTouch; &#125;, createClass: ReactClass.createClass, createElement: createElement, cloneElement: cloneElement, createFactory: createFactory, createMixin: function(mixin) &#123; // Currently a noop. Will be used to validate and trace mixins. return mixin; &#125;, constructAndRenderComponent: ReactMount.constructAndRenderComponent, constructAndRenderComponentByID: ReactMount.constructAndRenderComponentByID, findDOMNode: findDOMNode, render: render, renderToString: ReactServerRendering.renderToString, renderToStaticMarkup: ReactServerRendering.renderToStaticMarkup, unmountComponentAtNode: ReactMount.unmountComponentAtNode, isValidElement: ReactElement.isValidElement, withContext: ReactContext.withContext, // Hook for JSX spread, don't use this for anything else. __spread: assign&#125;; 顶层API的一般用法createElement( )12345React.createElement( type, [props], [...children]) 平常我们用 jsx 写的&lt;Hello /&gt; 其实就是对CreateElement函数的封装 12345678910class Hello extends React.Component &#123; render() &#123; return &lt;div&gt;Hello &#123;this.props.toWhat&#125;&lt;/div&gt;; &#125;&#125;ReactDOM.render( &lt;Hello toWhat="World" /&gt;, document.getElementById('root')); 等价于 12345678910class Hello extends React.Component &#123; render() &#123; return React.createElement('div', null, `Hello $&#123;this.props.toWhat&#125;`); &#125;&#125;ReactDOM.render( React.createElement(Hello, &#123;toWhat: 'World'&#125;, null), document.getElementById('root')); React.Component( )12345class Greeting extends React.Component &#123; render() &#123; return &lt;h1&gt;Hello, &#123;this.props.name&#125;&lt;/h1&gt;; &#125;&#125; 2 ReactDOMReactDOM.render()12345ReactDOM.render( element, container, [callback]) 该方法将在我们提供的container中渲染一个React元素 如果可选择的callback被提供了,那么在组件渲染完毕之后,就可以执行callback函数 React将会替换我们提供的container中的所有元素为ReactElement(如果原来的容器有子元素的话) unmountComponentAtNode( )1ReactDOM.unmountComponentAtNode(container) Remove a mounted React component from the DOM and clean up its event handlers and state. If no component was mounted in the container, calling this function does nothing. Returns true if a component was unmounted and false if there was no component to unmount. findDOMNode( )1ReactDOM.findDOMNode(component) If this component has been mounted into the DOM, this returns the corresponding native browser DOM element. This method is useful for reading values out of the DOM, such as form field values and performing DOM measurements. In most cases, you can attach a ref to the DOM node and avoid using findDOMNode at all. When render returns null or false, findDOMNode returns null.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[React-Component]]></title>
      <url>%2F2017%2F05%2F09%2F210React-Component%2F</url>
      <content type="text"></content>
    </entry>

    
    <entry>
      <title><![CDATA[return小结]]></title>
      <url>%2F2017%2F05%2F08%2F209return%E5%B0%8F%E7%BB%93%2F</url>
      <content type="text"><![CDATA[1 函数执行的时候,如果遇到return,则终止当前函数的执行,直接返回return后面的结果 2 for(var k in obj ) { } 循环,只有在obj被定义的情况下,才会执行for后面的代码块 123456789101112131415161718192021222324252627282930&lt;script&gt; var obj = &#123;name:'Jhon',age:13&#125;; function f1(obj)&#123; console.log('2'); for (var k in obj )&#123; //如果obj为定义,则for语句后面的代码块不会执行 return false ; &#125; //如果obj是一个对象,下面的代码不会执行,函数在执行的时候,遇到return就会直接退出当前函数执行,返回return的值 console.log('11'); return true ; cconsole.log('1'); &#125; var a = f1(obj);//传入obj var b = f1();//不传值,默认undefined console.log(a);//false console.log(b);//true function isEmptyObject(obj) &#123; for (var k in obj) &#123; return false; &#125; return true; &#125; &lt;/script&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ES6 import]]></title>
      <url>%2F2017%2F05%2F05%2F204ES6-import%2F</url>
      <content type="text"><![CDATA[1 了解ES6 模块加载和Common.js模块加载的区别1.1 Common.js语法中的模块加载加载得是引用的模块暴露出来的module.exports 整体 1.2 ES6的模块加载可以’静态加载,也就是说加载部分接口,而不是加载整个对象’ 12345678// CommonJS模块let &#123; stat, exists, readFile &#125; = require('fs');// 等同于let _fs = require('fs');let stat = _fs.stat;let exists = _fs.exists;let readfile = _fs.readfile; 上面代码的实质是整体加载fs模块（即加载fs的所有方法），生成一个对象（_fs），然后再从这个对象上面读取3个方法。这种加载称为“运行时加载”，因为只有运行时才能得到这个对象，导致完全没办法在编译时做“静态优化”。 12// ES6模块import &#123; stat, exists, readFile &#125; from 'fs'; ES6 模块不是对象，而是通过export命令显式指定输出的代码，再通过import命令输入。 上面代码的实质是从fs模块加载3个方法，其他方法不加载。这种加载称为“编译时加载”或者静态加载，即 ES6 可以在编译时就完成模块加载，效率要比 CommonJS 模块的加载方式高。当然，这也导致了没法引用 ES6 模块本身，因为它不是对象。 注意: ES6 模块之中，顶层的this指向undefined，即不应该在顶层代码使用this。 2 ES6模块的命令组成主要有export和import两个命令组成;export用于规定模块对外的接口;import用于输入其他模块提供的功能接口 2.1 export profile.js文件 123456789101112131415161718//第一种写法export var name = 'JiM';export function f()&#123; console.log('this is a func'); &#125;//-----------------------------------------------//第二种写法var name1 = 'Jhon' ;function f1 ()&#123; console.log('this is a func1'); &#125;export &#123; name1,f1 &#125; ;//注意暴露出去的写法必须用&#123;&#125;包起来 main.js 1import &#123;name ,name1 ,f,f1&#125; from './profile.js'; 最后，export命令可以出现在模块的任何位置，只要处于模块顶层就可以。如果处于块级作用域内，就会报错，下一节的import命令也是如此。这是因为处于条件代码块之中，就没法做静态优化了，违背了ES6模块的设计初衷。 export default 用来指定模块默认输出的接口,此时import该模块的就不需要{ } 括起来了,如下: 12345678910111213// 第一组export default function crc32() &#123; // 输出 // ...&#125;import crc32 from 'crc32'; // 输入// 第二组export function crc32() &#123; // 输出 // ...&#125;;import &#123;crc32&#125; from 'crc32'; // 输入 export default 也可以默认导出任何数据类型 1export default &#123;userData : null , msg : "login"&#125; export default命令用于指定模块的默认输出。显然，一个模块只能有一个默认输出，因此export default命令只能使用一次。所以，import命令后面才不用加大括号，因为只可能对应一个方法。 正是因为export default命令其实只是输出一个叫做default的变量，所以它后面不能跟变量声明语句。 2.2 import import命令接受一堆大括号,用于引出模块中的接口,from后面接的是模块的路径,可以是相对路径,也可以是绝对路径,如果是模块标识,需要进行配置,告诉浏览器引擎如何加载该模块中的接口; import命令具有声明提升功能,会提升到整个模块的头部 import命令是静态执行的,不能使用变量和表达式 123foo();import &#123; foo &#125; from 'my_module'; 上面的代码不会报错，因为import的执行早于foo的调用。这种行为的本质是，import命令是编译阶段执行的，在代码运行之前。 12345678910111213// 报错import &#123; 'f' + 'oo' &#125; from 'my_module';// 报错let module = 'my_module';import &#123; foo &#125; from module;// 报错if (x === 1) &#123; import &#123; foo &#125; from 'module1';&#125; else &#123; import &#123; foo &#125; from 'module2';&#125; 由于import是静态执行，所以不能使用表达式和变量，这些只有在运行时才能得到结果的语法结构。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Redux applyMiddleware源码]]></title>
      <url>%2F2017%2F05%2F05%2F208Redux-applyMiddleware%E6%BA%90%E7%A0%81%2F</url>
      <content type="text"><![CDATA[今天是周日,昨天玩了一天,嗯,该放松还是得放松嘛,今天来学习下. 1 还是先贴上源码12345678910111213141516171819202122232425262728293031323334353637383940414243import compose from './compose'/** * Creates a store enhancer that applies middleware to the dispatch method * of the Redux store. This is handy for a variety of tasks, such as expressing * asynchronous actions in a concise manner, or logging every action payload. * * See `redux-thunk` package as an example of the Redux middleware. * * Because middleware is potentially asynchronous, this should be the first * store enhancer in the composition chain. * * Note that each middleware will be given the `dispatch` and `getState` functions * as named arguments. * * @param &#123;...Function&#125; middlewares The middleware chain to be applied. * @returns &#123;Function&#125; A store enhancer applying the middleware. */export default function applyMiddleware(...middlewares) &#123; return (createStore) =&gt; (reducer, preloadedState, enhancer) =&gt; &#123; const store = createStore(reducer, preloadedState, enhancer) let dispatch = store.dispatch let chain = [] const middlewareAPI = &#123; getState: store.getState, dispatch: (action) =&gt; dispatch(action) &#125; chain = middlewares.map(middleware =&gt; middleware(middlewareAPI)) dispatch = compose(...chain)(store.dispatch)/* // 例如，chain 为 [M3, M2, M1]，而 compose 是从右到左进行“包裹”的 // 那么，M1 的 dispatch 参数为 store.dispatch（见【降低逼格写法】的【锚点-2】） // 往后，M2 的 dispatch 参数为 M1 的中间件处理逻辑哥（见【降低逼格写法】的【锚点-3】） // 同样，M3 的 dispatch 参数为 M2 的中间件处理逻辑哥 // 最后，我们得到串联后的中间件链：M3(M2(M1(store.dispatch))) */ return &#123; ...store, dispatch &#125; &#125;&#125; 由于目前对这个源码理解还是不够透彻,索性拿别人的作为记录得了,后期自己深入研究在自己写demo. 下面这个就是一个简单的中间件 1234567891011121314151617181920212223242526272829/* 装逼写法 */const printStateMiddleware = (&#123; getState &#125;) =&gt; next =&gt; action =&gt; &#123; console.log('state before dispatch', getState()) let returnValue = next(action) console.log('state after dispatch', getState()) return returnValue&#125;-------------------------------------------------/* 降低逼格写法 */function printStateMiddleware(middlewareAPI) &#123; // 记为【锚点-1】，中间件内可用的 API return function (dispatch) &#123; // 记为【锚点-2】，传入上级中间件处理逻辑（若无则为原 store.dispatch） // 下面记为【锚点-3】，整个函数将会被传到下级中间件（如果有的话）作为它的 dispatch 参数 return function (action) &#123; // &lt;---------------------------------------------- 这货就叫做【中间件处理逻辑哥】吧 console.log('state before dispatch', middlewareAPI.getState()) var returnValue = dispatch(action) // 还记得吗，dispatch 的返回值其实还是 action console.log('state after dispatch', middlewareAPI.getState()) return returnValue // 继续传给下一个中间件作为参数 action &#125; &#125;&#125; 如果觉得代码有点晦涩难懂,可以进行下babel转化为ES5 如下: 1234567891011121314151617181920212223242526272829303132333435363738Object.defineProperty(exports, "__esModule", &#123; value: true&#125;);var _extends = Object.assign || function (target) &#123; for (var i = 1; i &lt; arguments.length; i++) &#123; var source = arguments[i]; for (var key in source) &#123; if (Object.prototype.hasOwnProperty.call(source, key)) &#123; target[key] = source[key]; &#125; &#125; &#125; return target; &#125;;exports.default = applyMiddleware;function _toConsumableArray(arr) &#123; if (Array.isArray(arr)) &#123; for (var i = 0, arr2 = Array(arr.length); i &lt; arr.length; i++) &#123; arr2[i] = arr[i]; &#125; return arr2; &#125; else &#123; return Array.from(arr); &#125; &#125;function applyMiddleware() &#123; for (var _len = arguments.length, middlewares = Array(_len), _key = 0; _key &lt; _len; _key++) &#123; middlewares[_key] = arguments[_key]; &#125; return function (createStore) &#123; return function (reducer, preloadedState, enhancer) &#123; var store = createStore(reducer, preloadedState, enhancer); var _dispatch = store.dispatch; var chain = []; var middlewareAPI = &#123; getState: store.getState, dispatch: function dispatch(action) &#123; return _dispatch(action); &#125; &#125;; chain = middlewares.map(function (middleware) &#123; return middleware(middlewareAPI); &#125;); _dispatch = compose.apply(undefined, _toConsumableArray(chain))(store.dispatch); return _extends(&#123;&#125;, store, &#123; dispatch: _dispatch &#125;); &#125;; &#125;;&#125; 先从整体上把控下Redux所谓的API都有什么 : 1234567891011121314Redux 有五个 API，分别是： createStore(reducer, [initialState]) combineReducers(reducers) applyMiddleware(...middlewares) bindActionCreators(actionCreators, dispatch) compose(...functions)createStore 生成的 store 有四个 API，分别是： getState() dispatch(action) subscribe(listener) replaceReducer(nextReducer) 2 通过源码分析下applyMiddleware这个函数做了什么工作:2.1 返回一个新的store创建器 首先返回一个函数,该函数接受Redux.createStore这个API作为参数,也就是说 1applyMiddleware(...middleWares) = function (createStore)&#123; &#125; 1var enhancedCreateStore = Redux.applyMiddleware(...Middlewares)(Redux.createStore); 上面这行代码返回的结果也是一个函数,而这个函数被赋值给enhancedCreateStore 正常的创建store的函数 1var store = Redux.createStore(reducer, preloadedState, enhancer); 增强createStore之后的创建store函数 1var store = enhancedCreateStore(reducer, preloadedState, enhancer); 2.2 新的store创建器返回的结果增加了原来的dispatch函数功能,从源码中可以看出返回的值和最基础的createStore一样返回的是一个下面的对象: 1234567return &#123; dispatch, subscribe, getState, replaceReducer, [$$observable]: observable&#125; 只不过dispatch函数增加了一些功能而已. 1234return &#123; ...store, dispatch&#125; 以上分析就是applyMiddleware函数所做的一些工作. 123456789101112131415161718192021原 createStore ———— │ ↓return enhancer1(createStore)(reducer, preloadedState, enhancer2) | ├———————→ createStore 增强版 1 │ ↓return enhancer2(createStore1)(reducer, preloadedState, enhancer3) | ├———————————→ createStore 增强版 1+2 │ ↓return enhancer3(createStore1+2)(reducer, preloadedState, applyMiddleware(m1,m2,m3)) | ├————————————————————→ createStore 增强版 1+2+3 │ ↓return appleMiddleware(m1,m2,m3)(createStore1+2+3)(reducer, preloadedState) | ├——————————————————————————————————→ 生成最终增强版 store 3 走一个小的功能看下具体的效果12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;script src="./redux.min.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;script&gt;/** Action Creators */function inc() &#123; return &#123; type: 'INCREMENT' &#125;;&#125;function dec() &#123; return &#123; type: 'DECREMENT' &#125;;&#125;function reducer(state, action) &#123; state = state || &#123; counter: 0 &#125;; switch (action.type) &#123; case 'INCREMENT': return &#123; counter: state.counter + 1 &#125;; case 'DECREMENT': return &#123; counter: state.counter - 1 &#125;; default: return state; &#125;&#125;function printStateMiddleware(middlewareAPI) &#123; return function (dispatch) &#123; return function (action) &#123; console.log('dispatch 前：', middlewareAPI.getState()); var returnValue = dispatch(action); console.log('dispatch 后：', middlewareAPI.getState(), '\n'); return returnValue; &#125;; &#125;;&#125;var enhancedCreateStore = Redux.applyMiddleware(printStateMiddleware)(Redux.createStore);var store = enhancedCreateStore(reducer);store.dispatch(inc());store.dispatch(inc());store.dispatch(dec());&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;控制台输出：dispatch 前：&#123; counter: 0 &#125;dispatch 后：&#123; counter: 1 &#125;dispatch 前：&#123; counter: 1 &#125;dispatch 后：&#123; counter: 2 &#125;dispatch 前：&#123; counter: 2 &#125;dispatch 后：&#123; counter: 1 &#125; 参考非常感谢作者能从源码的角度剖析文章.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Redux combineReducers和bindActionCreators源码]]></title>
      <url>%2F2017%2F05%2F05%2F207Redux-combineReducers%E6%BA%90%E7%A0%81bindCreateAction%2F</url>
      <content type="text"><![CDATA[1 combineReducers源码如下(核心)12345678910111213141516171819202122232425262728293031function combineReducers(reducers) &#123; //传入combineReducers函数的是一个对象,包括不同的reducer的key -value键值对 var reducerKeys = Object.keys(reducers);//reducerKeys是一个数组,是我们传入的reducers的keys组成的数组 var finalReducers = &#123;&#125;//创建一个空对象,用来存放我们传入的reducers的value的值组成的数组 for (var i = 0; i &lt; reducerKeys.length; i++) &#123; var key = reducerKeys[i] if (typeof reducers[key] === 'function') &#123; finalReducers[key] = reducers[key] &#125; &#125;//以上循环用于过滤传入的reducers,确保最后每个reducer都是一个函数 var finalReducerKeys = Object.keys(finalReducers)//我们传入的reducers数组确认是一个key -value(function)的对象 // 返回合成后的 reducer 返回的这个函数就是combineReducers函数的返回值. //这个函数负责处理根据不同的action来进行state状态改变 //每次dispatch不同的action的时候,这个函数会被执行,执行的时候, return function combination(state = &#123;&#125;, action) &#123; var hasChanged = false var nextState = &#123;&#125; //以下循环通过不同的reducer对应的不同的key,处理state状态树上的对应的key值所对应的的子state,然后返回一个新的nextState对应的key-value组成的对象; for (var i = 0; i &lt; finalReducerKeys.length; i++) &#123; var key = finalReducerKeys[i] var reducer = finalReducers[key] var previousStateForKey = state[key] // 获取当前子 state var nextStateForKey = reducer(previousStateForKey, action) // 执行各子 reducer 中获取子 nextState,每一个子reducer都会返回一个新的state nextState[key] = nextStateForKey // 将子 nextState 挂载到对应的键名 hasChanged = hasChanged || nextStateForKey !== previousStateForKey &#125; return hasChanged ? nextState : state &#125;&#125; 通过源码我们可以看出,当将一个合并后的reducers函数传入createStore的时候 123456const reducers = combineReducers(&#123; todos, visibilityFilter&#125;)const store = createStore(reducers) 因为当我们执行createStore函数的时候,会默认执行dispatch函数,而dispatch函数会执行reducers函数,在执行该函数的的过程中,我们可以看到,reducers函数的返回值会赋值给currentState,` 2 state和action运行的流程无论是 dispatch 哪个 action，都会流通所有的 reducer表面上看来，这样子很浪费性能，但 JavaScript 对于这种纯函数的调用是很高效率的，因此请尽管放心这也是为何 reducer 必须返回其对应的 state 的原因。否则整合状态树时，该 reducer 对应的键值就是 undefine 12345 counterReducer(counter, action) -------------------- counter ↗ ↘rootReducer(state, action) —→∑ ↗ optTimeReducer(optTime, action) ------ optTime ↘ nextState ↘—→∑ todo ↗ ↘ todoListReducer(todoList,action) ----- todoList ↗ 3 bindActionCreators源码核心如下12345678910111213141516171819202122232425262728/* 为 Action Creator 加装上自动 dispatch 技能 */function bindActionCreator(actionCreator, dispatch) &#123; return (...args) =&gt; dispatch(actionCreator(...args))&#125;/*转为ES5如下"use strict";function bindActionCreator(actionCreator, dispatch) &#123; return function () &#123; return dispatch(actionCreator.apply(undefined, arguments)); &#125;;&#125;*/export default function bindActionCreators(actionCreators, dispatch) &#123; // 省去一大坨类型判断 var keys = Object.keys(actionCreators) //将对象中所有的key值集合到一个数组当中,返回一个数组 var boundActionCreators = &#123;&#125; for (var i = 0; i &lt; keys.length; i++) &#123; var key = keys[i] var actionCreator = actionCreators[key] //actionCreator[key]对应的是一个组件函数 if (typeof actionCreator === 'function') &#123; // 逐个装上自动 dispatch 技能 boundActionCreators[key] = bindActionCreator(actionCreator, dispatch) //该函数返回结果也是一个函数,如果返回的函数再次执行的话,那么返回的将是dispatch函数,进行action分发了 &#125; &#125; return boundActionCreators&#125; 12345678910&lt;input id="todoInput" type="text" /&gt;&lt;button id="btn"&gt;提交&lt;/button&gt;&lt;script&gt;$('#btn').on('click', function() &#123; var content = $('#todoInput').val() // 获取输入框的值 var action = addTodo(content) // 执行 Action Creator 获得 action store.dispatch(action) // 手动显式 dispatch 一个 action&#125;)&lt;/script&gt; 123456789101112131415&lt;input id="todoInput" type="text" /&gt;&lt;button id="btn"&gt;提交&lt;/button&gt;&lt;script&gt;// 全局引入 Redux、jQuery，同时 store 是全局变量var actionsCreators = Redux.bindActionCreators( //bindActionCreators函数会返回一个boundActionCreators对象,该对象中 &#123; addTodo: addTodo &#125;, store.dispatch // 传入 dispatch 函数)$('#btn').on('click', function() &#123; var content = $('#todoInput').val() actionCreators.addTodo(content) // 它会自动 dispatch&#125;)&lt;/script&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Redux createStore源码]]></title>
      <url>%2F2017%2F05%2F05%2F205Redux-createStore%E6%BA%90%E7%A0%81%2F</url>
      <content type="text"><![CDATA[###1 先贴上createStore源码 看了源码我对redux的认识才开始清晰,现在终于明白,不看源码学框架就是没事儿找刺激啊,不知道底层如何实现,学起来就是举步维艰; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254import isPlainObject from 'lodash/isPlainObject'import $$observable from 'symbol-observable'/** * These are private action types reserved by Redux. * For any unknown actions, you must return the current state. * If the current state is undefined, you must return the initial state. * Do not reference these action types directly in your code. */export const ActionTypes = &#123; INIT: '@@redux/INIT'&#125;/** * Creates a Redux store that holds the state tree. * The only way to change the data in the store is to call `dispatch()` on it. * * There should only be a single store in your app. To specify how different * parts of the state tree respond to actions, you may combine several reducers * into a single reducer function by using `combineReducers`. * * @param &#123;Function&#125; reducer A function that returns the next state tree, given * the current state tree and the action to handle. * * @param &#123;any&#125; [preloadedState] The initial state. You may optionally specify it * to hydrate the state from the server in universal apps, or to restore a * previously serialized user session. * If you use `combineReducers` to produce the root reducer function, this must be * an object with the same shape as `combineReducers` keys. * * @param &#123;Function&#125; [enhancer] The store enhancer. You may optionally specify it * to enhance the store with third-party capabilities such as middleware, * time travel, persistence, etc. The only store enhancer that ships with Redux * is `applyMiddleware()`. * * @returns &#123;Store&#125; A Redux store that lets you read the state, dispatch actions * and subscribe to changes. */export default function createStore(reducer, preloadedState, enhancer) &#123; if (typeof preloadedState === 'function' &amp;&amp; typeof enhancer === 'undefined') &#123; enhancer = preloadedState preloadedState = undefined &#125; if (typeof enhancer !== 'undefined') &#123; if (typeof enhancer !== 'function') &#123; throw new Error('Expected the enhancer to be a function.') &#125; return enhancer(createStore)(reducer, preloadedState) &#125; if (typeof reducer !== 'function') &#123; throw new Error('Expected the reducer to be a function.') &#125; let currentReducer = reducer let currentState = preloadedState let currentListeners = [] let nextListeners = currentListeners let isDispatching = false function ensureCanMutateNextListeners() &#123; if (nextListeners === currentListeners) &#123; nextListeners = currentListeners.slice() &#125; &#125; /** * Reads the state tree managed by the store. * * @returns &#123;any&#125; The current state tree of your application. */ function getState() &#123; return currentState &#125; /** * Adds a change listener. It will be called any time an action is dispatched, * and some part of the state tree may potentially have changed. You may then * call `getState()` to read the current state tree inside the callback. * * You may call `dispatch()` from a change listener, with the following * caveats: * * 1. The subscriptions are snapshotted just before every `dispatch()` call. * If you subscribe or unsubscribe while the listeners are being invoked, this * will not have any effect on the `dispatch()` that is currently in progress. * However, the next `dispatch()` call, whether nested or not, will use a more * recent snapshot of the subscription list. * * 2. The listener should not expect to see all state changes, as the state * might have been updated multiple times during a nested `dispatch()` before * the listener is called. It is, however, guaranteed that all subscribers * registered before the `dispatch()` started will be called with the latest * state by the time it exits. * * @param &#123;Function&#125; listener A callback to be invoked on every dispatch. * @returns &#123;Function&#125; A function to remove this change listener. */ function subscribe(listener) &#123; if (typeof listener !== 'function') &#123; throw new Error('Expected listener to be a function.') &#125; let isSubscribed = true ensureCanMutateNextListeners() nextListeners.push(listener) return function unsubscribe() &#123; if (!isSubscribed) &#123; return &#125; isSubscribed = false ensureCanMutateNextListeners() const index = nextListeners.indexOf(listener) nextListeners.splice(index, 1) &#125; &#125; /** * Dispatches an action. It is the only way to trigger a state change. * * The `reducer` function, used to create the store, will be called with the * current state tree and the given `action`. Its return value will * be considered the **next** state of the tree, and the change listeners * will be notified. * * The base implementation only supports plain object actions. If you want to * dispatch a Promise, an Observable, a thunk, or something else, you need to * wrap your store creating function into the corresponding middleware. For * example, see the documentation for the `redux-thunk` package. Even the * middleware will eventually dispatch plain object actions using this method. * * @param &#123;Object&#125; action A plain object representing “what changed”. It is * a good idea to keep actions serializable so you can record and replay user * sessions, or use the time travelling `redux-devtools`. An action must have * a `type` property which may not be `undefined`. It is a good idea to use * string constants for action types. * * @returns &#123;Object&#125; For convenience, the same action object you dispatched. * * Note that, if you use a custom middleware, it may wrap `dispatch()` to * return something else (for example, a Promise you can await). */ function dispatch(action) &#123; if (!isPlainObject(action)) &#123; throw new Error( 'Actions must be plain objects. ' + 'Use custom middleware for async actions.' ) &#125; if (typeof action.type === 'undefined') &#123; throw new Error( 'Actions may not have an undefined "type" property. ' + 'Have you misspelled a constant?' ) &#125; if (isDispatching) &#123; throw new Error('Reducers may not dispatch actions.') &#125; try &#123; isDispatching = true currentState = currentReducer(currentState, action) &#125; finally &#123; isDispatching = false &#125; const listeners = currentListeners = nextListeners for (let i = 0; i &lt; listeners.length; i++) &#123; const listener = listeners[i] listener() &#125; return action &#125; /** * Replaces the reducer currently used by the store to calculate the state. * * You might need this if your app implements code splitting and you want to * load some of the reducers dynamically. You might also need this if you * implement a hot reloading mechanism for Redux. * * @param &#123;Function&#125; nextReducer The reducer for the store to use instead. * @returns &#123;void&#125; */ function replaceReducer(nextReducer) &#123; if (typeof nextReducer !== 'function') &#123; throw new Error('Expected the nextReducer to be a function.') &#125; currentReducer = nextReducer dispatch(&#123; type: ActionTypes.INIT &#125;) &#125; /** * Interoperability point for observable/reactive libraries. * @returns &#123;observable&#125; A minimal observable of state changes. * For more information, see the observable proposal: * https://github.com/tc39/proposal-observable */ function observable() &#123; const outerSubscribe = subscribe return &#123; /** * The minimal observable subscription method. * @param &#123;Object&#125; observer Any object that can be used as an observer. * The observer object should have a `next` method. * @returns &#123;subscription&#125; An object with an `unsubscribe` method that can * be used to unsubscribe the observable from the store, and prevent further * emission of values from the observable. */ subscribe(observer) &#123; if (typeof observer !== 'object') &#123; throw new TypeError('Expected the observer to be an object.') &#125; function observeState() &#123; if (observer.next) &#123; observer.next(getState()) &#125; &#125; observeState() const unsubscribe = outerSubscribe(observeState) return &#123; unsubscribe &#125; &#125;, [$$observable]() &#123; return this &#125; &#125; &#125; // When a store is created, an "INIT" action is dispatched so that every // reducer returns their initial state. This effectively populates // the initial state tree. dispatch(&#123; type: ActionTypes.INIT &#125;) return &#123; dispatch, subscribe, getState, replaceReducer, [$$observable]: observable &#125;&#125; var store = createStore(reducer , preLoadState , enhancer) 定义一个store的时候可以传递reducer函数,state初始状态 注意createStore之后,会先默认执行dispatch函数一次,看源码注意下这一点.通过这次默认执行dispatch函数,reducer函数就会执行,可以初始化state状态 dispatch函数执行的时候,由于刚创建store并没有通过subscribe绑定listeners,所以listeners在createStore的时候不会执行. getState( )函数用来获取state下一个状态 dispatch(action)函数, 用来根据不同的action,调用reducer函数改变state状态 依次执行所有通过subscribe订阅到listeners数组中的函数; 返回一个传入的action对象 subscribe( listener ) 用来向listeners数组中添加监听器 replaceReducer( nextReducer ) 替换 reducer 为 nextReducer 123dispatch不同的action,然后触发reducer函数定义reducer函数的时候,reducer函数接受两个参数,一个是state,一个是action,因为reducer函数在执行的时候,是在dispatch函数内部执行,所以reducer函数的action来自于dispatch的参数action,reducer函数的state可以来自于自己,也可以来自于定义store的时候 2 我们来结合一个小栗子看下createStore在状态管理过程中所扮演的角色2.1 还是老惯例,看下引入redux之后,文件中对象有什么 12345678&lt;body&gt; &lt;script src='./redux.min.js'&gt;&lt;/script&gt; &lt;script&gt; console.log(Redux); console.log(Redux.createStore); &lt;/script&gt;&lt;/body&gt; 1234567891011Object &#123;__esModule: true,createStore: function, combineReducers: function, bindActionCreators: function, applyMiddleware: function…&#125;applyMiddleware:function o()bindActionCreators:function u(t,e)combineReducers:function i(t)compose:function n()createStore:function o(t,e)__esModule:true 2.2 reducer函数的定义为什么总是第一个参数是state,第二个参数是action? 我们定义的reducer函数要返回一个reducer处理之后的state,赋值给currentState,然后通过getState就可以获取当前状态; 源码中有如下两行代码,可以看出 12var currentReducer = reducer; currentState = currentReducer(currentState, action); 当我们创建一个store的时候,createStore接受两个参数,一个是reducer函数,一个是initialState初始状态, 然后 var currentReducer = reducer ; var currentState = initialState; 当我们调用dispatch的时候,dispatch执行的过程中,会调用reducer函数,reducer函数就是我们处理state的方法 dispatch函数中在调用reducer的时候,会向其中传递两个参数,一个是initialState对象,一个是action对象;dispatch函数执行后返回的是传入的action 注意定义reducer的时候,必须要返回一个state状态,防治state状态的丢失. 2.3 初始化state的两种方式, 通过createStore(reducer , initialState) 通过reducer(state = initialState , action ) 1234567891011121314151617181920212223242526272829303132333435363738&lt;body&gt; &lt;script src='./redux.min.js'&gt;&lt;/script&gt; &lt;script&gt; //action 创建器 function createActionOne ()&#123; return &#123; type : 'INCREAMENT' &#125; &#125; function createActionTwo()&#123; return &#123; type : 'DECREASE' &#125; &#125; //reducer处理函数 function reducer (state = &#123;count : 0 &#125;,action)&#123; // state = state || &#123;count : 0 &#125; switch (action.type) &#123; case "INCREAMENT" : return &#123;conut : state.count+1&#125;; case "DECREASE" : return &#123;count : state.count-1&#125;; default : return state ; &#125; &#125; //store状态管理器的创建 var store = Redux.createStore(reducer); console.log( store.getState() ); store.dispatch(createActionOne()); console.log( store.getState() ); &lt;/script&gt;&lt;/body&gt; 1234567891011121314151617181920212223242526272829303132333435363738&lt;body&gt; &lt;script src='./redux.min.js'&gt;&lt;/script&gt; &lt;script&gt; //action 创建器 function createActionOne ()&#123; return &#123; type : 'INCREAMENT' &#125; &#125; function createActionTwo()&#123; return &#123; type : 'DECREASE' &#125; &#125; //reducer处理函数 function reducer (state ,action)&#123; // state = state || &#123;count : 0 &#125; switch (action.type) &#123; case "INCREAMENT" : return &#123;conut : state.count+1&#125;; case "DECREASE" : return &#123;count : state.count-1&#125;; default : return state ; &#125; &#125; //store状态管理器的创建 var initialState = &#123;count : 10 &#125; var store = Redux.createStore(reducer,initialState); console.log( store.getState() ); store.dispatch(createActionOne()); console.log( store.getState() ); &lt;/script&gt;&lt;/body&gt; 3 ES6语法新特性 bable在线编译工具ES6 1234567891011function reducer (state = &#123;count : 0 &#125;,action)&#123; // state = state || &#123;count : 0 &#125; switch (action.type) &#123; case "INCREAMENT" : return &#123;conut : state.count+1&#125;; case "DECREASE" : return &#123;count : state.count-1&#125;; default : return state ; &#125; &#125; 经过转化为ES5 12345678910111213141516"use strict";function reducer() &#123; var state = arguments.length &gt; 0 &amp;&amp; arguments[0] !== undefined ? arguments[0] : &#123; count: 0 &#125;; var action = arguments[1]; // state = state || &#123;count : 0 &#125; switch (action.type) &#123; case "INCREAMENT": return &#123; conut: state.count + 1 &#125;; case "DECREASE": return &#123; count: state.count - 1 &#125;; default: return state; &#125;&#125; 4 参考源码解读]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Redux compose源码]]></title>
      <url>%2F2017%2F05%2F05%2F206Redux-compose%E6%BA%90%E7%A0%81%2F</url>
      <content type="text"><![CDATA[1 先贴上源码12345678910111213141516171819202122/** * Composes single-argument functions from right to left. The rightmost * function can take multiple arguments as it provides the signature for * the resulting composite function. * * @param &#123;...Function&#125; funcs The functions to compose. * @returns &#123;Function&#125; A function obtained by composing the argument functions * from right to left. For example, compose(f, g, h) is identical to doing * (...args) =&gt; f(g(h(...args))). */export default function compose(...funcs) &#123; if (funcs.length === 0) &#123; return arg =&gt; arg &#125; if (funcs.length === 1) &#123; return funcs[0] &#125; return funcs.reduce((a, b) =&gt; (...args) =&gt; a(b(...args)))&#125; 经过bable编译器编译之后 123456789101112131415161718192021222324252627"use strict";Object.defineProperty(exports, "__esModule", &#123; value: true&#125;);exports.default = compose;function compose() &#123; for (var _len = arguments.length, funcs = Array(_len), _key = 0; _key &lt; _len; _key++) &#123; funcs[_key] = arguments[_key]; &#125; if (funcs.length === 0) &#123; return function (arg) &#123; return arg; &#125;; &#125; if (funcs.length === 1) &#123; return funcs[0]; &#125; return funcs.reduce(function (a, b) &#123; return function () &#123; return a(b.apply(undefined, arguments)); &#125;; &#125;);&#125; 2 简化应用过程123456789101112// 由于 reduce / reduceRight 仅仅是方向的不同，因此下面用 reduce 说明即可var arr = [1, 2, 3, 4, 5]//封装的compose函数用的是这种reduce函数,没有传入初始值var re1 = arr.reduce(function(total, i) &#123; return total + i&#125;)console.log(re1) // 15var re2 = arr.reduce(function(total, i) &#123; return total + i&#125;, 100) // &lt;---------------传入一个初始值console.log(re2) // 115 3 reduce函数Array.prototype.reduce(callback ,[initialValue]) (reduceRight函数和reduce函数类似，只不是从数组的最后反向开始迭代);数组的reduce方法向callback函数传递四个参数，分别是 12345678910111213141516ParameterscallbackFunction to execute on each value in the array, taking four arguments:1 accumulatorThe accumulated value previously returned in the last invocation of the callback, or initialValue, if supplied. (See below.)(如果initialValue提供了，那么第一次运行的时候，accumular值为initialValue，如果没有提供initialValue，那么accumular的值为数组中的第一个元素，currentValue为数组中的第二个元素，跳过第一个索引值)2 currentValueThe current element being processed in the array.3 currentIndexThe index of the current element being processed in the array. Starts at index 0, if an initialValue is provided, and at index 1 otherwise.4 arrayThe array reduce was called upon.5 initialValueOptional. Value to use as the first argument to the first call of the callback.Return valueThe value that results from the reduction. callback函数每次执行之后的结果作为第一个参数再次传递给callback函数 4 compose函数执行之后返回值是什么12345return funcs.reduce(function (a, b) &#123; return function () &#123; return a(b.apply(undefined, arguments)); &#125;; &#125;); 如上代码返回值是reduce函数执行后的结果 如果是一个简单的数组进行reduce函数的运算,那么结果就很简单 123456var ret = [1,2,3].reduce(function(a,b)&#123; return a+b ;&#125;);console.log(ret);//6 如果是一个由函数组成的数组进行reduce函数的运算,那么返回的结果就是一个函数的链式调用 1234567891011121314151617181920212223242526272829&lt;body&gt; &lt;script src='./redux.min.js'&gt;&lt;/script&gt; &lt;script&gt; function func1(num)&#123; console.log('func1获取参数',num); return num + 1 ; &#125; function func2(num)&#123; console.log('func2获取参数',num); return num + 1 ; &#125; function func3(num)&#123; console.log('func1获取参数',num); return num + 3 ; &#125; var ret = Redux.compose(func1,func2,func3); console.dir(ret);//可以看出结果是一个函数 function anonymous(t) var ret1 = Redux.compose(func1,func2,func3)(3) ; console.log(ret1); var ret2 = func1(func2(func3(3))); //这个就是compose函数最终返回的最简单的函数形态 console.log(ret2) &lt;/script&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[DHTMLX框架浅析]]></title>
      <url>%2F2017%2F05%2F03%2F203DHTMLX%E6%A1%86%E6%9E%B6%E6%B5%85%E6%9E%90%2F</url>
      <content type="text"><![CDATA[###1]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[seajsuse实例应用与理解]]></title>
      <url>%2F2017%2F05%2F02%2F202seajsuse%E5%AE%9E%E4%BE%8B%E5%BA%94%E7%94%A8%E4%B8%8E%E7%90%86%E8%A7%A3%2F</url>
      <content type="text"><![CDATA[五一小长假已经过完,心里很愧疚,因为没有学习,没有学习就没有进步,没有进步就没有薪水,没有薪水我就无法生活,没有生活我就无法生存,没有生存我还能怎样拯救世界呢?为了世界和平,继续学习;嗯,开始节后第一博;回顾原理,夯实基础. seajs.use 首先看下在没有这些工具的时候我们如何加载一个js文件的 123456var script = document.createElement('script');script.setAttribute('src', 'example.js');script.onload = function() &#123; console.log("script loaded!");&#125;;document.body.appendChild(script); 1 seajs.use语法1234567891011121314seajs.use(id, callback?)// 加载一个模块seajs.use('./a');// 加载一个模块，在加载完成时，执行回调seajs.use('./a', function(a) &#123; a.doSomething();&#125;);// 加载多个模块，在加载完成时，执行回调seajs.use(['./a', './b'], function(a, b) &#123; a.doSomething(); b.doSomething();&#125;); 2 seajs.use模块加载在所在文件的用途:通过seajs.use引入的文件在当前页面都是可用的,相当于引入的js文件在当前页面执行(src引入js文件的原理一样)考虑如下文件目录 12345678910111213F: workspace -sea.js -jquery-1.12.4.js -seajsTest -module.js -js module1.js module2.js -css common.css -page index.html index.html 1234567891011121314151617181920&lt;body&gt; &lt;p id='test'&gt;this is a test for seajsuse&lt;/p&gt; &lt;script&gt; seajs.use(['../../jquery-1.12.4'],function()&#123; console.log($) // seajs.use('../module'); &#125;) setTimeout(function()&#123; console.log('1'); console.log($); &#125;,200) console.log($); &lt;/script&gt;&lt;/body&gt; 输出 123Uncaught ReferenceError: $ is not defined // 最后一行代码输出function ( selector, context ) &#123;&#125; //回调函数输出function ( selector, context ) &#123;&#125; //定时器输出 这个时候要对函数的同步执行,异步执行以及回调函数有着清晰的认识:简单来说就是 同步 异步 回调 seajs.use的回调函数在依赖模块加载完毕之后触发执行.因为模块的加载时同步加载的,加载完成之后才会执行回调函数common.css也可以通过seajs.use引入当前页面 123p &#123; font-size : 50px ;&#125; index.html加上如下代码 1234&lt;script&gt; seajs.use('../css/common.css')&lt;/script&gt; 可以发现字体被加上了css样式，字体变大了。 注意引入css文件的时候,一定要加上css后缀名,因为seajs不会为我们加上后缀,默认是 .js a.加载css的时候一定要加后缀的 b.路径中有”？“的时候javascript文件的后缀不能省略 c.路径中是以”#”号结尾的文件也不可以省去后缀 3 seajs.use如果嵌套seajs.use,还是从原理层面去考虑,seajs.use依赖的模块也是可以直接调用外部seajs.use引用的模块数据(可以理解嵌套的使用script -src加载js文件)module.js 1$('#test').css('backgroundColor','red') 然后再浏览器中打开index.html文件,可以发现字体变红了,module.js可以使用$这样的jquery封装的代码 一个文件就是一个模块,通过seajs.use加载一个模块本质上就是通过script标签src属性引入一个文件而已,但是需要注意命名空间的问题 3.1 当这个模块使用define定义的时候,那么就不会污染全局,define定义的变量必须通过exports对象提供接口才能被外部访问 3.2 当这个模块不是通过define函数定义的时候,那么就会容易产生全局的变量污染,因为通过script标签引入的js文件会在全局执行; module1.js 1var foo = 'bar'; module2.js 123456define(function(require,exports,)&#123; var foo1 = 'bar1'; exports.foo1 = foo1 ; //通过模块可以直接操作DOM元素 document.getElementById('test').style.color = 'green';//字体会变成绿色&#125;) module.js 123$('#test').css('backgroundColor','red');console.log('module.js',foo);console.log('module.js',foo1); index.html 1234567891011121314151617181920212223242526272829&lt;body&gt; &lt;p id='test'&gt;this is a test for seajsuse&lt;/p&gt; &lt;script&gt; seajs.use('../css/common.css') &lt;/script&gt; &lt;script&gt; seajs.use(['../../jquery-1.12.4','../js/module1','../js/module2'],function(a,b,c)&#123; // console.log($); console.log(arguments);//null null Object seajs.use('../module'); console.log('seajs',foo); console.log('seajs',c.foo1); &#125;) setTimeout(function()&#123; console.log('setTimeout',foo); console.log('setTimeout',c.foo1); &#125;,2000)//define定义的变量不会污染全局 直接引入的js文件会污染全局 &lt;/script&gt;&lt;/body&gt; 输出如下 1234567-(3) [null, null, Object, callee: function, Symbol(Symbol.iterator): function]-seajs bar-seajs bar1-module.js bar-Uncaught ReferenceError: foo1 is not defined-setTimeout bar-Uncaught ReferenceError: c is not defined 4 module 模块的生命周期1234567891011121314var STATUS = Module.STATUS = &#123; // 1 - The `module.uri` is being fetched FETCHING: 1, // 2 - The meta data has been saved to cachedMods SAVED: 2, // 3 - The `module.dependencies` are being loaded LOADING: 3, // 4 - The module are ready to execute LOADED: 4, // 5 - The module is being executed EXECUTING: 5, // 6 - The `module.exports` is available EXECUTED: 6&#125; 5 详细源码可以查看(通过npm install seajs下载的资源包里面也会有响应的代码,有兴趣的可以看下里面的源码,以下是我参考的文章)seajs源码解析1 seajs源码解析2 seajs 这篇总结的比较好]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[seajs源码实现]]></title>
      <url>%2F2017%2F04%2F28%2F201seajs%E6%BA%90%E7%A0%81%E5%AE%9E%E7%8E%B0%2F</url>
      <content type="text"><![CDATA[1 seajs核心实现包括以下几个函数use(id,callback) 入口函数 define(id?dep?factory) 模块定义函数 require(id) 模块加载函数 getModuleExports(module) 取得模块接口函数 2 代码实现2.1. use(ids, callback)use为程序启动的入口，主要干两件事：加载指定的模块待模块加载完成后，调用回调函数 12345678910111213141516171819function use(ids, callback) &#123; if (!Array.isArray(ids)) ids = [ids]; Promise.all(ids.map(function (id) &#123; return load(myLoader.config.root + id); &#125;)).then(function (list) &#123; callback.apply(global, list);// 加载完成， 调用回调函数 &#125;, function (error) &#123; throw error; &#125;); &#125; use会调用load函数，这个函数的作用是根据模块的id，加载模块，并返回一个Promise对象 12345678910111213141516171819function load(id) &#123; return new Promise(function (resolve, reject) &#123; var module = myLoader.modules[id] || Module.create(id); // 取得模块或者新建模块 此时模块正在加载或者已经加载完成 module.on("complete", function () &#123; var exports = getModuleExports(module); resolve(exports);// 加载完成-&gt; 通知调用者 &#125;) module.on("error", reject); &#125;) &#125; 2.2 define函数的实现 1234var factory = function(require, exports, module)&#123; // some code&#125;define(factory); 一个模块文件被浏览器下载下来后，并不会直接运行我们的模块定义代码，而是会首先执行一个define函数，这个函数会取得模块定义的源代码（通过函数的toString()函数来取得源代码），然后利用正则匹配找到依赖的模块（匹配require(&quot;dep.js&quot;)这样的字符串)，然后加载依赖的模块，最后发射一个自定义事件complete，通知当前模块， 模块已经加载完成，此时，当前模块的就会调用与complete事件绑定的回调函数，完成与这个模块相关的任务，比如resolve与这个模块加载绑定的Promise。具体实现为： 123456789101112131415161718function define(factory) &#123; var id = getCurrentScript(); id = id.replace(location.origin, ""); var module = myLoader.modules[id]; module.factory = factory; var dependences = getDependcencs(factory); if (dependences) &#123; Promise.all(dependences.map(function (dep) &#123; return load(myLoader.config.root + dep); &#125;)).then(function () &#123; module.fire("complete"); // 依赖加载完成，通知模块。 &#125;, function () &#123; module.fire("error"); &#125;); &#125; else &#123; module.fire("complete");//没有依赖，通知模块加载完成 &#125;&#125; 2.3 require函数的实现 123456789101112131415function require(id) &#123; var module = myLoader.modules[myLoader.config.root + id]; if (!module) throw "can not load find module by id:" + id; else &#123; return getModuleExports(module); // 返回模块的对外接口。 &#125; &#125;function getModuleExports(module) &#123; if (!module.exports) &#123; module.exports = &#123;&#125;; module.factory(require, module.exports, module); &#125; return module.exports;&#125; 参考]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[seajs核心]]></title>
      <url>%2F2017%2F04%2F27%2F201seajs%E6%A0%B8%E5%BF%83%2F</url>
      <content type="text"><![CDATA[研究下seajs到底是什么 seajs模块化的理念就是,每一个js文件都是一个单独的模块,模块中的变量,方法不能被外部访问,有效的防治了全局变量的污染;如果想要被外部文件访问,需要通过exports导出;(基本的原理还是立即执行函数的封装以及闭包的使用) 文件目录结构 1234567F: workspace sea.js seajsTest index.html main.js module.js ###1 seajs全局函数 index.html 12345678&lt;body&gt; &lt;script src='../sea.js'&gt;&lt;/script&gt;; &lt;script&gt; console.log(seajs); console.log(define);//define是一个全局函数 //consolelog(require);//报错,require不是全局函数,这点记住 &lt;/script&gt;&lt;/body&gt; 控制台输出如下 1234567891011121314// console.log(seajs);ObjectModule:function t(a,b)cache:Objectconfig:function (a)data:Objectemit:function (a,b)off:function (a,b)on:function (a,b)request:function o(a,b,c,d)require:function (a)resolve:function m(a,b)use:function (a,b)version:&quot;2.2.3&quot; 12console.log(define)function (a,c,d)&#123;var e=arguments.length;1===e?(d=a,a=b):2===e&amp;&amp;(d=c,y(a)?(c=a,a=b):c=b),!y(c)&amp;&amp;z(d)&amp;&amp;(c=s(&quot;&quot;+d));var f=&#123;id:a,uri:t.resolve(a),deps:c,factory:d&#125;;if(!f.uri&amp;&amp;M.attachEvent)&#123;var g=r();g&amp;&amp;(f.uri=g.… 2 seajs.use()index.html 123456789101112131415&lt;script src='../sea.js'&gt;&lt;/script&gt;; &lt;script&gt; // seajs.use('./main.js'); // console.log(foo);//报错,这就是模块化的理念 seajs.use(['./main.js','./module'],function()&#123; console.log('callback is exec'); console.log(arguments); &#125;); // console.log(seajs); // console.log(define); &lt;/script&gt; main.js 123456789101112define(function(require,exports,module)&#123; console.log(arguments); console.log('main.js was loaded'); var foo = 'Jhon' exports.foo = 'bar'; exports.myFunc = function()&#123; console.log('this is a func from main.js'); &#125;&#125;) module.js 12345define(function(require,exports,module)&#123; exports.mod = 'baz'; console.log('module.js is exec'); &#125;) seajs.use会按顺序加载模块,先加载main.js,那么main.js就会被执行,然后加载module.js,module.js就会被执行,等两者加载完毕之后,就会执行回调函数;回调函数中接受参数,参数是每个模块导出的exports对象;如果没有导出exports对象,那么回调函数中对应的参数是null seajs如何判断模块的加载是否完成的呢?其实底层也是封装了script标签的onload事件,加载完毕之后触发该事件,然后执行回调函数; 针对上面的代码分析下控制台的输出 1234567891011121314151617181920212223//main.js输出[function, Object, t, callee: function, Symbol(Symbol.iterator): function]0: function a(b) async: function (b,c) resolve:function (a)1:Object foo : &apos;bar&apos;, myFunc : function()&#123;&#125;2: t dependencies:Array(0) exports:Object id : uri : status : //以上是define(factory)中factory的三个参数解析main.js was loaded//module.js输出module.js is exec//index.html 中seajs.use回调函数输出callback is exec//以下是seajs.use回调函数中传入的参数,可以看出来是每个模块导出的对象 exports [Object, Object, callee: function, Symbol(Symbol.iterator): function]0: Object1: Objectcallee: function ()length: 2Symbol(Symbol.iterator): function values()__proto__: Object 3 接下来解释下factory中三个参数123define(function(require,exports,module)&#123; &#125;) 12345678910111213[function, Object, t, callee: function, Symbol(Symbol.iterator): function]0: function a(b) async: function (b,c) resolve:function (a)1:Object foo : &apos;bar&apos;, myFunc : function()&#123;&#125;2: t dependencies:Array(0) exports:Object id : uri : status : 3.1 require方法解析 require(a) 是一个方法 ,接受模块标识作为 唯一的参数, 如果require的模块有exports对象返回,返回的是a模块的exports对象; 如果require的模块没有返回exports对象返回,那么默认返回null 引入的模块定义的方法可以使用,比如引入jquery等类库 require.sync(a,callback) 是一个方法,接受两个参数,一个是模块标识,一个是回调函数,异步执行; require.resolve(a) 该函数不会加载模块，只返回解析后的绝对路径。 123456789define(function(require,exports,module)&#123; exports.mod = 'baz'; console.log('module.js is exec'); require('./jquery-1.12.4.js'); console.log($); /* function ( selector, context ) &#123; &#125; */&#125;) 3.1.1 当模块标识为顶级标识的时候:(不以 . 开头 或者不以 / 开头);require(a)路径的解析是以seajs文件所在目录为基准 1234567891011121314151617//main.jsdefine(function(require,exports,module)&#123; console.log(arguments); console.log('main.js was loaded'); var foo = 'Jhon' var retMain = require('module.js'); console.log(require.resolve('module')); //file:///F:/workspace/module.js //可以看出顶级模块标识是以seajs文件所在目录为基准进行解析的 exports.foo = 'bar'; exports.myFunc = function()&#123; console.log('this is a func from main.js'); &#125;&#125;) 3.1.2 当模块标识为相对标识的时候(以 . 开头,则该模块标识就是相对标识), 相对标识路径解析的时候,永远是相对于当前模块而言 ;出现在define的factory函数中require函数的参数中 12345678910111213141516define(function(require,exports,module)&#123; console.log(arguments); console.log('main.js was loaded'); var foo = 'Jhon' var retMain = require('./module.js'); console.log(retMain);//Object &#123;mod: "baz"&#125; console.log(require.resolve('./module')); //file:///F:/workspace//seajsTest/module.js exports.foo = 'bar'; exports.myFunc = function()&#123; console.log('this is a func from main.js'); &#125;&#125;) 3.2 exports对象解析 exports对象是module.exports对象的引用,而模块真正导出的是module.exports 当我们在定义模块的时候 123456789define(function(require, exports) &#123; // 错误用法！！! exports = &#123; foo: 'bar', doSomething: function() &#123;&#125; &#125;;&#125;); 对象并不会被导出,因为改变了exports的引用,所以导出的module.exports 是没有数据的 123456789define(function(require, exports, module) &#123; // 正确写法 module.exports = &#123; foo: 'bar', doSomething: function() &#123;&#125; &#125;;&#125;); 3.3 module 对象 module.id 12345define('id', [], function(require, exports, module) &#123; // 模块代码&#125;); module.uri 根据模块系统的路径解析规则得到的模块绝对路径。 一般情况下在没有写define中的id参数的时候,两者完全一样; module.dependencies Array 是一个数组,表示当前模块的依赖 module.exports 当前模块对外提供的接口。 传给 factory 构造方法的 exports 参数是 module.exports 对象的一个引用。只通过 exports 参数来提供接口，有时无法满足开发者的所有需求。 比如当模块的接口是某个类的实例时，需要通过 module.exports来实现： 123456789101112define(function(require, exports, module) &#123; // exports 是 module.exports 的一个引用 console.log(module.exports === exports); // true // 重新给 module.exports 赋值 module.exports = new SomeClass(); // exports 不再等于 module.exports console.log(module.exports === exports); // false&#125;); 4 seajs.use require 二者引用模块规则 当引用的模块是顶级标识的时候,那么就是相对于seajs文件所在目录为基准 当引用模块是相对标识的时候,那么就是相对于seajs.use requre所在文件目录为基准; 123456789F: workspace sea.js seajsTest index.html main.js module.js module2.js seajsConfig.js seajsConfig.js 123456seajs.config(&#123; alias : &#123; // mod2 : 'seajsTest/module2' //这是顶级标识,引用文件的时候会相对于seajs文件所在目录 mod2 : './module2' //这是相对路径,引用文件的时候会相对于当前文件或者当前模块所在目录 &#125;&#125;) index.html 此时在index.html中通过别名引用模块module2.js 可以通过别名 mod2来引用 注意如果引用模块有exports对象内容,那么回调函数传入的参数就是exports对象,如果没有,那么传入的是null 123456789101112&lt;script src='../sea.js'&gt;&lt;/script&gt;; &lt;script src='./seajsconfig.js'&gt;&lt;/script&gt;; &lt;script&gt; seajs.use(['./main.js','./module','mod2'],function()&#123; console.log('callback is exec'); console.log(arguments); &#125;); console.log(seajs); // console.log(define); &lt;/script&gt; 5 模块路径 相对标识：以 . 开头（包括.和..），相对标识永远相对当前模块的 URI 来解析。 顶级标识：不以点（.）或斜线（/）开始， 会相对模块系统的基础路径（即 SeaJS配置 的 base 路径）来解析 普通路径：除了相对和顶级标识之外的标识都是普通路径，相对当前页面解析。 绝对路径是普通路径。绝对路径比较容易理解。 根路径是以“/”开头的，取当前页面的域名+根路径; 相对路径以 ../ 开头或者以 ./ 开头的都是相对路径]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[webpack foundation]]></title>
      <url>%2F2017%2F04%2F27%2F200webpack-foundation%2F</url>
      <content type="text"><![CDATA[webpack.config.js解析1 entryentry 对象是用于 webpack 查找启动并构建 bundle。其上下文是入口文件所处的目录的绝对路径的字符串。 1context: path.resolve(__dirname, &quot;app&quot;) 12345const config = &#123; entry: './path/to/my/entry/file.js'&#125;;module.exports = config; 123456const config = &#123; entry: &#123; app: './src/app.js', vendors: './src/vendors.js' &#125;&#125;; 2 output objectoutput对象 12345678const config = &#123; output: &#123; filename: 'bundle.js', path: __dirname+'/build/' &#125;&#125;;module.exports = config; 注意output.path提供打包后的文件存放的绝对路径地址 ; output.filename提供了打包后文件的名字; 3 module这些选项决定了如何处理项目中的不同类型的模块。 loader 用于对模块的源代码进行转换。loader 可以使你在 require() 或”加载”模块时预处理文件。因此，loader 类似于其他构建工具中“任务(task)”，并提供了处理前端构建步骤的强大方法。loader 可以将文件从不同的语言（如 TypeScript）转换为 JavaScript，或将内联图像转换为 data URL。loader 甚至允许你在 JavaScript 中 require（） CSS文件！ 12npm install --save-dev css-loadernpm install --save-dev ts-loader 123456789//webpackconfig.jsmodule.exports = &#123; module: &#123; rules: [ &#123;test: /\.css$/, use: 'css-loader'&#125;, &#123;test: /\.ts$/, use: 'ts-loader'&#125; ] &#125;&#125;; 如何使用loaders有以下三种方式 通过配置 在 require 语句中显示使用 通过 CLI 通过 webpack.config.js module.rules 允许你在 webpack 配置中指定几个 loader。 这是展示 loader 的一种简明的方式，并且有助于使代码变得简洁。而且对每个相应的 loader 有一个完整的概述。 12345678910111213141516module: &#123; rules: [ &#123; test: /\.css$/, use: [ &#123; loader: &apos;style-loader&apos;&#125;, &#123; loader: &apos;css-loader&apos;, options: &#123; modules: true &#125; &#125; ] &#125; ]&#125; 通过 require 可以在 require 语句（或 define, require.ensure, 等语句）中指定 loader。使用 ! 将资源中的 loader 分开。分开的每个部分都相对于当前目录解析。 1require(&apos;style-loader!css-loader?modules!./styles.css&apos;); 通过前置所有规则及使用 !，可以对应覆盖到配置中的任意 loader。 选项可以传递查询参数，就像在 web 中那样（?key=value&amp;foo=bar）。也可以使用 JSON 对象（?{&quot;key&quot;:&quot;value&quot;,&quot;foo&quot;:&quot;bar&quot;}）。 尽可能使用 module.rules，因为这样可以在源码中减少引用，并且可以更快调试和定位 loader，避免代码越来越糟。 通过 CLI 可选项，你也可以通过 CLI 使用 loader： 1webpack --module-bind jade-loader --module-bind &apos;css=style-loader!css-loader&apos; 这会对 .jade 文件使用 jade-loader，对 .css 文件使用 style-loader 和 css-loader 4 plugins由于 plugin 可以携带参数/选项，你必须在 wepback 配置中，向 plugins 属性传入 new 实例。 根据你如何使用 webpack，这里有多种方式使用插件。 1234567891011121314151617181920212223242526//webpack.config.jsconst HtmlWebpackPlugin = require('html-webpack-plugin'); //通过 npm 安装const webpack = require('webpack'); //访问内置的插件const path = require('path');const config = &#123; entry: './path/to/my/entry/file.js', output: &#123; filename: 'my-first-webpack.bundle.js', path: path.resolve(__dirname, 'dist') &#125;, module: &#123; loaders: [ &#123; test: /\.(js|jsx)$/, loader: 'babel-loader' &#125; ] &#125;, plugins: [ new webpack.optimize.UglifyJsPlugin(), new HtmlWebpackPlugin(&#123;template: './src/index.html'&#125;) ]&#125;;module.exports = config; 5 target因为服务器和浏览器代码都可以用 JavaScript 编写，所以 webpack 提供了多种构建目标(target)，你可以在你的 webpack 配置中设置。 高速webpack这个程序的目标环境是什么 尽管 webpack 不支持向 target 传入多个字符串，你可以通过打包两份分离的配置来创建同构的库： 123456789101112131415161718192021//webpack.config.jsvar path = require('path');var serverConfig = &#123; target: 'node', output: &#123; path: path.resolve(__dirname, 'dist'), filename: 'lib.node.js' &#125; //…&#125;;var clientConfig = &#123; target: 'web', // &lt;=== 默认是 'web'，可省略 output: &#123; path: path.resolve(__dirname, 'dist'), filename: 'lib.js' &#125; //…&#125;;module.exports = [ serverConfig, clientConfig ]; target描述 async-node编译为类 Node.js 环境可用（使用 fs 和 vm 异步加载分块） atomelectron-main 的别名 electron``electron-main 的别名 electron-main编译为 Electron 渲染进程，使用 JsonpTemplatePlugin, FunctionModulePlugin 来为浏览器环境提供目标，使用 NodeTargetPlugin 和 ExternalsPlugin 为 CommonJS 和 Electron 内置模块提供目标。 node编译为类 Node.js 环境可用（使用 Node.js require 加载 chunk） node-webkit编译为 Webkit 可用，并且使用 jsonp 去加载分块。支持 Node.js 内置模块和 nw.gui 导入（实验性质） web编译为类浏览器环境里可用（默认） webworker编译成一个 WebWorker 例如，当 target 设置为 &quot;electron&quot;，webpack 引入多个 electron 特定的变量。有关使用哪些模板和 externals 的更多信息，你可以直接参考 webpack 源码。 6 命令 如果存在 webpack.config.js，webpack 命令将默认选择使用它 通过npm配合使用,改变package.json文件 1234"scripts": &#123; "example": "babel-node"&#125;, //可以通过 npm run example 执行 babel-node命令 或者 1234"scripts": &#123; "build": "webpack" &#125;, // 可以通过 npm run build 执行 webpack 命令]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[webpack]]></title>
      <url>%2F2017%2F04%2F27%2F199webpack%2F</url>
      <content type="text"><![CDATA[1 WebPack的安装 安装命令 1$ npm install webpack -g 使用webpack 12$ npm init # 会自动生成一个package.json文件$ npm install webpack --save-dev #将webpack增加到package.json文件中 可以使用不同的版本 1$ npm install webpack@1.2.x --save-dev 如果想要安装开发工具 1$ npm install webpack-dev-server --save-dev 每个项目下都必须配置有一个 webpack.config.js ，它的作用如同常规的 gulpfile.js/Gruntfile.js ，就是一个配置项，告诉 webpack 它需要做什么。 下面是一个例子 12345678910111213141516171819202122232425262728293031323334var webpack = require(&apos;webpack&apos;);var commonsPlugin = new webpack.optimize.CommonsChunkPlugin(&apos;common.js&apos;);module.exports = &#123; //插件项 plugins: [commonsPlugin], //页面入口文件配置 entry: &#123; index : &apos;./src/js/page/index.js&apos; &#125;, //入口文件输出配置 output: &#123; path: &apos;dist/js/page&apos;, filename: &apos;[name].js&apos; &#125;, module: &#123; //加载器配置 loaders: [ &#123; test: /\.css$/, loader: &apos;style-loader!css-loader&apos; &#125;, &#123; test: /\.js$/, loader: &apos;jsx-loader?harmony&apos; &#125;, &#123; test: /\.scss$/, loader: &apos;style!css!sass?sourceMap&apos;&#125;, &#123; test: /\.(png|jpg)$/, loader: &apos;url-loader?limit=8192&apos;&#125; ] &#125;, //其它解决方案配置 resolve: &#123; root: &apos;E:/github/flux-example/src&apos;, //绝对路径 extensions: [&apos;&apos;, &apos;.js&apos;, &apos;.json&apos;, &apos;.scss&apos;], alias: &#123; AppStore : &apos;js/stores/AppStores.js&apos;, ActionType : &apos;js/actions/ActionType.js&apos;, AppAction : &apos;js/actions/AppAction.js&apos; &#125; &#125;&#125;; plugins 是插件项，这里我们使用了一个 CommonsChunkPlugin的插件，它用于提取多个入口文件的公共脚本部分，然后生成一个 common.js 来方便多页面之间进行复用。 entry 是页面入口文件配置，output 是对应输出项配置 （即入口文件最终要生成什么名字的文件、存放到哪里） module.loaders 是最关键的一块配置。它告知 webpack 每一种文件都需要使用什么加载器来处理。 所有加载器需要使用npm来加载 最后是 resolve 配置，配置查找模块的路径和扩展名和别名（方便书写） 2 WebPack开始使用这里有最基本的使用方法，给大家一个感性的认识 正确安装了WebPack，方法可以参考上面 书写entry.js文件 1document.write(&quot;看看如何让它工作！&quot;); 书写index.html文件 12345678&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;/head&gt;&lt;body&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;bundle.js&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 执行命令，生成bundle.js文件 1$ webpack ./entry.js bundle.js 在浏览器中打开index.html文件，可以正常显示出预期 增加一个content.js文件 1module.exports = &quot;现在的内容是来自于content.js文件！&quot;; 修改entry.js文件 1document.write(require(&quot;./content.js&quot;)); 执行第四步的命令 进行加载器试验 增加style.css文件 123body &#123;background: yellow;&#125; 修改entry.js文件 12require(&quot;!style!css!./style.css&quot;);document.write(require(&quot;./content.js&quot;)); 执行命令，安装加载器 1$ npm install css-loader style-loader # 安装的时候不使用 -g 执行webpack命令，运行看效果 可以在命令行中使用loader 1$ webpack ./entry.js bundle.js --module-bind &quot;css=style!css&quot; 使用配置文件默认的配置文件为webpack.config.js 增加webpack.config.js文件 123456789101112module.exports = &#123; entry: &quot;./entry.js&quot;, output: &#123; path: __dirname, filename: &quot;bundle.js&quot; &#125;, module: &#123; loaders: [ &#123; test: /\.css$/, loader: &quot;style!css&quot; &#125; ] &#125;&#125;; 执行程序 1$ webpack 发布服务器 安装服务器 12$ npm install webpack-dev-server -g$ webpack-dev-server --progress --colors 服务器可以自动生成和刷新，修改代码保存后自动更新画面 1http://localhost:8080/webpack-dev-server/bundle 3 使用配置文件webpack.config.js 我们只需要执行命令 webpack即可，而如果没有配置文件，我们需要webpack指定要打包的入口文件以及文件生成的路径和文件名]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Redux React 基本环境的搭建]]></title>
      <url>%2F2017%2F04%2F26%2F197Redux-React-%E5%9F%BA%E6%9C%AC%E7%8E%AF%E5%A2%83%E7%9A%84%E6%90%AD%E5%BB%BA%2F</url>
      <content type="text"><![CDATA[Redux环境的基本搭建]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[seajs基础]]></title>
      <url>%2F2017%2F04%2F26%2F198seajs%E5%9F%BA%E7%A1%80%2F</url>
      <content type="text"><![CDATA[模块标识模块标识是一个字符串，用来标识模块。在 require、 require.async 等加载函数中，第一个参数都是模块标识。 顶级标识始终相对 base 基础路径解析。 绝对路径和根路径始终相对当前页面解析。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100Sea.js 中的模块标识是 CommonJS 模块标识 的超集:一个模块标识由斜线（/）分隔的多项组成。每一项必须是小驼峰字符串、 . 或 .. 。模块标识可以不包含文件后缀名，比如 .js 。模块标识可以是 相对 或 顶级 标识。如果第一项是 . 或 ..，则该模块标识是相对标识。顶级标识根据模块系统的基础路径来解析。相对标识相对 require 所在模块的路径来解析。注意，符合上述规范的标识肯定是 Sea.js 的模块标识，但 Sea.js 能识别的模块标识不需要完全符合以上规范。 比如，除了大小写字母组成的小驼峰字符串，Sea.js 的模块标识字符串还可以包含下划线（_）和连字符（-）， 甚至可以是 http://、https://、file:/// 等协议开头的绝对路径。相对标识相对标识以 . 开头，只出现在模块环境中（define 的 factory 方法里面）。相对标识永远相对当前模块的 URI 来解析：// 在 http://example.com/js/a.js 的 factory 中：require.resolve(&apos;./b&apos;); // =&gt; http://example.com/js/b.js// 在 http://example.com/js/a.js 的 factory 中：require.resolve(&apos;../c&apos;); // =&gt; http://example.com/c.js顶级标识顶级标识不以点（.）或斜线（/）开始， 会相对模块系统的基础路径（即 Sea.js 的 base 路径）来解析：// 假设 base 路径是：http://example.com/assets/// 在模块代码里：require.resolve(&apos;gallery/jquery/1.9.1/jquery&apos;); // =&gt; http://example.com/assets/gallery/jquery/1.9.1/jquery.js模块系统的基础路径即 base 的默认值，与 sea.js 的访问路径相关：如果 sea.js 的访问路径是： http://example.com/assets/sea.js则 base 路径为： http://example.com/assets/当 sea.js 的访问路径中含有版本号时，base 不会包含 seajs/x.y.z 字串。 当 sea.js 有多个版本时，这样会很方便。如果 sea.js 的路径是： http://example.com/assets/seajs/1.0.0/sea.js则 base 路径是： http://example.com/assets/当然，也可以手工配置 base 路径：seajs.config(&#123; base: &apos;http://code.jquery.com/&apos;&#125;);// 在模块代码里：require.resolve(&apos;jquery&apos;); // =&gt; http://code.jquery.com/jquery.js普通路径除了相对和顶级标识之外的标识都是普通路径。普通路径的解析规则，和 HTML 代码中的 &lt;script src=&quot;...&quot;&gt;&lt;/script&gt; 一样，会相对当前页面解析。// 假设当前页面是 http://example.com/path/to/page/index.html// 绝对路径是普通路径：require.resolve(&apos;http://cdn.com/js/a&apos;); // =&gt; http://cdn.com/js/a.js// 根路径是普通路径：require.resolve(&apos;/js/b&apos;); // =&gt; http://example.com/js/b.js// use 中的相对路径始终是普通路径：seajs.use(&apos;./c&apos;); // =&gt; 加载的是 http://example.com/path/to/page/c.jsseajs.use(&apos;../d&apos;); // =&gt; 加载的是 http://example.com/path/to/d.js提示：顶级标识始终相对 base 基础路径解析。绝对路径和根路径始终相对当前页面解析。require 和 require.async 中的相对路径相对当前模块路径来解析。seajs.use 中的相对路径始终相对当前页面来解析。文件后缀的自动添加规则Sea.js 在解析模块标识时， 除非在路径中有问号（?）或最后一个字符是井号（#），否则都会自动添加 JS 扩展名（.js）。如果不想自动添加扩展名，可以在路径末尾加上井号（#）。// &quot;.js&quot; 后缀可以省略：require.resolve(&apos;http://example.com/js/a&apos;);require.resolve(&apos;http://example.com/js/a.js&apos;); // =&gt; http://example.com/js/a.js// &quot;.css&quot; 后缀不可省略：require.resolve(&apos;http://example.com/css/a.css&apos;); // =&gt; http://example.com/css/a.css// 当路径中有问号（&quot;?&quot;）时，不会自动添加后缀：require.resolve(&apos;http://example.com/js/a.json?callback=define&apos;); // =&gt; http://example.com/js/a.json?callback=define// 当路径以井号（&quot;#&quot;）结尾时，不会自动添加后缀，且在解析时，会自动去掉井号：require.resolve(&apos;http://example.com/js/a.json#&apos;); // =&gt; http://example.com/js/a.json 1 seajs.use 用来加载一个模块加载的模块中的代码会被执行,所以加载的模块暴露出来的方法都可以使用; 1234567891011121314seajs.use(id, callback?)// 加载一个模块seajs.use('./a');// 加载一个模块，在加载完成时，执行回调seajs.use('./a', function(a) &#123; a.doSomething();&#125;);// 加载多个模块，在加载完成时，执行回调seajs.use(['./a', './b'], function(a, b) &#123; a.doSomething(); b.doSomething();&#125;); 注意：seajs.use 与 DOM ready 事件没有任何关系。如果某些操作要确保在 DOM ready 后执行，需要使用 jquery 等类库来保证。比如 12345seajs.use(['jquery', './main'], function($, main) &#123; $(document).ready(function() &#123; main.init(); &#125;);&#125;); 1seajs.use(&quot;abc/main&quot;); //导入seajs.js同级的abc文件夹下的main.js模块的（后缀名可略去不写）.因为这是顶级标识 ##2 seajs.configObject 所谓的配置文件可以理解为对模块标识的一个变量表示,进行简化模块标识的操作; baseUrl object1234seajs.config(&#123; // Sea.js 的基础路径（修改这个就不是路径就不是相对于seajs文件了） base: 'http://example.com/path/to/base/'&#125;); aliasObject别名配置，配置之后可在模块中使用require调用 require(&#39;jquery&#39;); 用变量表示文件，解决路径层级过深和实现路径映射 123seajs.config(&#123; alias: &#123; &apos;jquery&apos;: &apos;jquery/jquery/1.10.1/jquery&apos; &#125;&#125;); 1234define(function(require, exports, module) &#123; //引用jQuery模块 var $ = require(&apos;jquery&apos;);&#125;); pathsObject设置路径，方便跨目录调用。通过灵活的设置path可以在不影响base的情况下指定到某个目录。 （用变量表示路径，解决路径层级过深的问题） 1234567891011seajs.config(&#123; //设置路径 paths: &#123; &apos;gallery&apos;: &apos;https://a.alipayobjects.com/gallery&apos; &#125;, // 设置别名，方便调用 alias: &#123; &apos;underscore&apos;: &apos;gallery/underscore&apos; &#125;&#125;); 1234define(function(require, exports, module) &#123; var _ = require(&apos;underscore&apos;); //=&gt; 加载的是 https://a.alipayobjects.com/gallery/underscore.js&#125;); varsObject变量配置。有些场景下，模块路径在运行时才能确定，这时可以使用 vars 变量来配置。 vars 配置的是模块标识中的变量值，在模块标识中用 {key} 来表示变量。 123456seajs.config(&#123; // 变量配置 vars: &#123; &apos;locale&apos;: &apos;zh-cn&apos; &#125;&#125;); 1234define(function(require, exports, module) &#123; var lang = require(&apos;./i18n/&#123;locale&#125;.js&apos;); //=&gt; 加载的是 path/to/i18n/zh-cn.js&#125;); mapArray该配置可对模块路径进行映射修改，可用于路径转换、在线调试等。 12345seajs.config(&#123; map: [ [ &apos;.js&apos;, &apos;-debug.js&apos; ] ]&#125;); 1234define(function(require, exports, module) &#123; var a = require(&apos;./a&apos;); //=&gt; 加载的是 path/to/a-debug.js&#125;); preloadArray使用preload配置项，可以在普通模块加载前，提前加载并初始化好指定模块。 preload中的空字符串会被忽略掉。 1234567// 在老浏览器中，提前加载好 ES5 和 json 模块seajs.config(&#123; preload: [ Function.prototype.bind ? &apos;&apos; : &apos;es5-safe&apos;, this.JSON ? &apos;&apos; : &apos;json&apos; ]&#125;); 注意：preload中的配置，需要等到 use 时才加载。比如： 123456seajs.config(&#123; preload: &apos;a&apos;&#125;);// 在加载 b 之前，会确保模块 a 已经加载并执行好seajs.use(&apos;./b&apos;); preload 配置不能放在模块文件里面： 1234567seajs.config(&#123; preload: &apos;a&apos;&#125;);define(function(require, exports) &#123; // 此处执行时，不能保证模块 a 已经加载并执行好&#125;); debugBoolean值为true时，加载器不会删除动态插入的 script 标签。插件也可以根据debug配置，来决策 log 等信息的输出。 baseStringSea.js 在解析顶级标识时，会相对 base 路径来解析。 注意：一般请不要配置 base 路径，把 sea.js 放在合适的路径往往更简单一致。 charsetString | Function获取模块文件时， 或 标签的charset属性。 默认是utf-8 charset还可以是一个函数： 1234567891011seajs.config(&#123; charset: function(url) &#123; // xxx 目录下的文件用 gbk 编码加载 if (url.indexOf(&apos;http://example.com/js/xxx&apos;) === 0) &#123; return &apos;gbk&apos;; &#125; // 其他文件用 utf-8 编码 return &apos;utf-8&apos;; &#125;&#125;); 1234567891011121314seajs.config(&#123; // Sea.js 的基础路径（修改这个就不是路径就不是相对于seajs文件了） base: 'http://example.com/path/to/base/', // 别名配置（用变量表示文件，解决路径层级过深和实现路径映射） alias: &#123; 'es5-safe': 'gallery/es5-safe/0.9.3/es5-safe', 'json': 'gallery/json/1.0.2/json', 'jquery': 'jquery/jquery/1.10.1/jquery' &#125;, // 路径配置（用变量表示路径，解决路径层级过深的问题） paths: &#123; 'gallery': 'https://a.alipayobjects.com/gallery' &#125;&#125;); 3 模块的定义1define(factory) //define 是一个全局函数，用来定义模块。 12345678910111213141516171819202122232425define 接受 factory 参数，factory 可以是一个函数，也可以是一个对象或字符串。factory 为对象、字符串时，表示模块的接口就是该对象、字符串。比如可以如下定义一个 JSON 数据模块：define(&#123; "foo": "bar" &#125;);也可以通过字符串定义模板模块：define('I am a template. My name is &#123;&#123;name&#125;&#125;.');factory 为函数时，表示是模块的构造方法。执行该构造方法，可以得到模块向外提供的接口。factory 方法在执行时，默认会传入三个参数：require、exports 和 module：define(function(require, exports, module) &#123; // 模块代码&#125;);define define(id?, deps?, factory)define 也可以接受两个以上参数。字符串 id 表示模块标识，数组 deps 是模块依赖。比如：define('hello', ['jquery'], function(require, exports, module) &#123; // 模块代码&#125;);id 和 deps 参数可以省略。省略时，可以通过构建工具自动生成。 1234567891011121314// 所有模块都通过 define 来定义define(function(require, exports, module) &#123; // 通过 require 引入依赖 var $ = require('jquery'); var Spinning = require('./spinning'); // 通过 exports 对外提供接口 exports.doSomething = ... // 或者通过 module.exports 提供整个接口 module.exports = ...&#125;); 4 关于模块标识和路径问题常见问题关于模块标识Seajs模块标识主要以小驼峰字符串、.或.. 1234567// 在 http://example.com/js/a.js 的 factory 中：require.resolve(&apos;./b&apos;); // =&gt; http://example.com/js/b.js// 在 http://example.com/js/a.js 的 factory 中：require.resolve(&apos;../c&apos;); // =&gt; http://example.com/c.js 分为 相对 与 顶级 标识。以.或..开头，则为相对标识 。以小驼峰字符串开关，则为顶级标识。 12345// 假设 base 路径是：http://example.com/assets/// 在模块代码里：require.resolve(&apos;gallery/jquery/1.9.1/jquery&apos;); // =&gt; http://example.com/assets/gallery/jquery/1.9.1/jquery.js 关于路径Seajs除了相对与顶级标识之外，还可以使用普通路径来加载模块。 就到当前页面的脚本分析（可以右键查看源码） 123456789101112131415161718192021222324//sea.js的路径，即 base 路径，相对于当前页面&lt;script src=&quot;http://yslove.net/actjs/assets/sea-modules/seajs/2.1.1/sj.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt;//配置Seajsseajs.config(&#123; alias: &#123; //顶级标识，基于 base 路径 &apos;actjs&apos;: &apos;actjs/core/0.0.7/core.js&apos;, // =&gt; http:// &apos;position&apos;: &apos;actjs/util/0.0.2/position.js&apos; &#125;&#125;);seajs.config(&#123; alias: &#123; //普通路径，相对于当前页面 &apos;affix&apos;: &apos;../../actjs/assets/widget/src/widget-affix.js&apos;, //相对标识，相对于当前页面 &apos;init&apos;: &apos;./src/init.js&apos; &#125;&#125;);&lt;/script&gt; 5 其他函数seajs.resloveFunction类似require.resolve，会利用模块系统的内部机制对传入的字符串参数进行路径解析。 12345seajs.resolve(&apos;jquery&apos;);// =&gt; http://path/to/jquery.jsseajs.resolve(&apos;./a&apos;, &apos;http://example.com/to/b.js&apos;);// =&gt; http://example.com/to/a.js seajs.resolve 方法不光可以用来调试路径解析是否正确，还可以用在插件开发环境中。 seajs简易文档 CMD语法规范]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[reactContext]]></title>
      <url>%2F2017%2F04%2F25%2F194reactContext%2F</url>
      <content type="text"></content>
    </entry>

    
    <entry>
      <title><![CDATA[npm]]></title>
      <url>%2F2017%2F04%2F25%2F196npm%2F</url>
      <content type="text"><![CDATA[本地安装npm install 模块名 \1. 将安装包放在 ./node_modules 下（运行 npm 命令时所在的目录），如果没有 node_modules 目录，会在当前执行 npm 命令的目录下生成 node_modules 目录。 \2. 可以通过 require() 来引入本地安装的包。 全局安装 \1. 将安装包放在 /usr/local 下或者你 node 的安装目录。 \2. 可以直接在命令行里使用。 模块操作创建模块 $ npm initThis utility will walk you through creating a package.json file.It only covers the most common items, and tries to guess sensible defaults. 更新模块 $ npm update module npm install msbuild: 会把msbuild包安装到node_modules目录中 不会修改package.json 之后运行npm install命令时，不会自动安装msbuild npm install msbuild –save: 会把msbuild包安装到node_modules目录中 会在package.json的dependencies属性下添加msbuild 之后运行npm install命令时，会自动安装msbuild到node_modules目录中 之后运行npm install –production或者注明NODE_ENV变量值为production时，会自动安装msbuild到node_modules目录中 npm install msbuild –save-dev: 会把msbuild包安装到node_modules目录中 会在package.json的devDependencies属性下添加msbuild 之后运行npm install命令时，会自动安装msbuild到node_modules目录中 之后运行npm install –production或者注明NODE_ENV变量值为production时，不会自动安装msbuild到node_modules目录中 使用原则:运行时需要用到的包使用–save，否则使用–save-dev。通过package.json进行安装如果我们的项目依赖了很多package，一个一个地安装那将是个体力活。我们可以将项目依赖的包都在package.json这个文件里声明，然后一行命令搞定 1npm install npm ls：查看安装了哪些包运行如下命令，就可以查看当前目录安装了哪些package npm ls pkg：查看特定package的信息运行如下命令，输出grunt-cli的信息 npm update pkg：package更新1npm update grunt-cli npm search pgk：搜索输入如下命令 1npm search grunt-cli packjson文件属性解释npmRyf npm常用命令总结 npm命令详解]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Redux]]></title>
      <url>%2F2017%2F04%2F25%2F195Redux%2F</url>
      <content type="text"><![CDATA[建议先看这篇GitHub上的基础 Redux基础 深入浅出Redux3 1 action 创建函数 仅仅是一个函数，作用是用来生成一个action，action本质是一个javascript对象这个函数会返回一个 Action 对象，这个对象里描述了“页面发生了什么”。随后这个对象会被传入到 Reducer 中。 官方定义:Actions are payloads of information that send data from your application to your store. They are the only source of information for the store. You send them to the store using store.dispatch(). Action 是把数据从应用（这里之所以不叫 view 是因为这些数据有可能是服务器响应，用户输入或其它非 view 的数据 ）传到 store 的有效载荷。它是 store 数据的唯一来源。一般来说你会通过 store.dispatch() 将 action 传到 store。 描述发生了什么 1234567var actionCreator = function() &#123; // ...that creates an action (yeah, the name action creator is pretty obvious now) and returns it return &#123; type: 'AN_ACTION', name:'Jhon' &#125;&#125; Redux约定Action内使用一个字符串类型的type字段来表示将要执行的动作，比如上栗的 AN_ACTION，除了type之外可以存放其他要操作的数据； 1234567891011121314import &#123;createStore&#125; from 'redux';var userReducer = function(state = &#123;&#125;,action)&#123; console.log('userReducer was called with ',state,'and action',action); switch(action.type)&#123; case 'SET_NAME' : return &#123; ...state, name : action.name &#125; default : return state ; &#125; &#125;var store_0 = createStore(userReducer); 传入store_0的可以是一个action对象 1234store_0.dispatch(&#123;type:'SET_NAME',name : "Jhon"&#125;);//userReducer was called with &#123;&#125; and action &#123; type: 'SET_NAME', name: 'Jhon' &#125;console.log('store_0 state after action',store_0.getState());////store_0 state after action &#123; name: 'Jhon' &#125; 同样也可以是一个action创建函数，该函数返回action对象 123456789101112function setNameActionCreator(name)&#123; return &#123; type : 'SET_NAME', name //这里用到了ES6声明对象的简洁语法 &#125;&#125;store_0.dispatch(setNameActionCreator('JiM'));//userReducer was called with &#123; name: 'Jhon' &#125; and action &#123; type: 'SET_NAME', name: 'JiM' &#125;console.log('store_0 state after action',store_0.getState());//store_0 state after action &#123; name: 'JiM' &#125; 2 reducer根据action更新state，reducer 就是一个纯函数，接收旧的 state 和 action，返回新的 state。 官方定义:Actions describe the fact that something happened, but don’t specify how the application’s state changes in response. This is the job of a reducer. 之所以称作 reducer 是因为它将被传递给 Array.prototype.reduce(reducer, ?initialValue) 方法。保持 reducer 纯净非常重要。永远不要在 reducer 里做这些操作： 修改传入参数； 执行有副作用的操作，如 API 请求和路由跳转； 调用非纯函数，如 Date.now() 或 Math.random()。 123456(previousState, action) =&gt; newState//How do I handle data modifications?// Using reducers (called "stores" in traditional flux).// A reducer is a subscriber to actions.// A reducer is just a function that receives the current state of your application, the action,// and returns a new state modified (or reduced as they call it) 12345678910function todoApp(state = &#123;&#125;, action) &#123; switch (action.type) &#123; case SET_VISIBILITY_FILTER: return Object.assign(&#123;&#125;, state, &#123; visibilityFilter: action.filter &#125;) default: return state &#125;&#125; 传入state的默认值可以是null undefined [ ] 布尔类型 字符串等 ,也就是说，reducer函数可以处理任何数据结构类型，根据需求不同可以传入不同的state默认值； 12345678910111213141516import &#123;createStore&#125; from 'redux';function myReducer(state = null,action)&#123; console.log('myReducer was called with state',state,'and action',action); switch(action.type)&#123; case 'SOMETHING' : return &#123; ...state , message : 'done' &#125; default : return state &#125;&#125;var store_0 = createStore(myReducer) 如果随着我们的业务越来越复杂，如何让不同的reducer进行合并呢？redux提供了combineReducers函数，该函数接受一个对象，会执行传入的所有的reducer； combineReducers 生成了一个类似于Reducer的函数。为什么是类似于，因为它不是真正的Reducer，它只是一个调用Reducer的函数，只不过它接收的参数与真正的Reducer一模一样~ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import &#123;createStore,combineReducers&#125; from 'redux';var userReducer = function(state = &#123;&#125;,action)&#123; console.log('userReducer was called with the state',state,'and action',action); switch(action.type)&#123; case 'SOmething' : return &#123; ...state, message:action.value &#125; default : return state ; &#125;&#125;var itemsReducer = function(state = [],action)&#123; console.log('itemsReducer was called with the state',state,'and action',action); switch(action.type)&#123; //etc default : return state ; &#125;&#125;var reducer = combineReducers(&#123;userReducer,itemsReducer&#125;);//其实等价于 var reducer = combineReducers(&#123;userReducer:userReducer,itemsReducer:itemsReducer&#125;);//ES6对象新的语法特性//这行代码执行之后输出/*userReducer was called with the state &#123;&#125; and action &#123; type: '@@redux/INIT' &#125;userReducer was called with the state &#123;&#125; and action &#123; type: '@@redux/PROBE_UNKNOWN_ACTION_q.y.p.r.j.q.z.6.7.x.t.b.a.6.j.b.r.z.f.r' &#125;itemsReducer was called with the state [] and action &#123; type: '@@redux/INIT' &#125;itemsReducer was called with the state [] and action &#123; type: '@@redux/PROBE_UNKNOWN_ACTION_f.y.3.u.2.q.q.w.d.h.q.c.w.p.g.2.p.g.b.9' &#125;*/console.log(combineReducers);//[Function: combineReducers]console.log(reducer);//[Function: combination] 可以看出combineReducers这个函数调用一系列的reducer然后返回一个新的reducer函数var store_0 = createStore(reducer);/** * userReducer was called with the state &#123;&#125; and action &#123; type: '@@redux/INIT' &#125;itemsReducer was called with the state [] and action &#123; type: '@@redux/INIT' &#125; */console.log('store_0 state after initialization',store_0.getState());//输出如下: store_0 state after initialization &#123; userReducer: &#123;&#125;, itemsReducer: [] &#125; 看下combineReducers底层实现 12345678910111213141516171819202122function combineReducers(reducers) &#123; // 过滤reducers，把非function类型的过滤掉~ var finalReducers = pick(reducers, (val) =&gt; typeof val === 'function'); // 一开始我一直以为这个没啥用，后来我发现，这个函数太重要了。它在一开始，就已经把你的State改变了。变成了，Reducer的key 和 Reducer返回的initState组合。 var defaultState = mapValues(finalReducers, () =&gt; undefined); return function combination(state = defaultState, action) &#123; // finalReducers 是 reducers var finalState = mapValues(finalReducers, (reducer, key) =&gt; &#123; // state[key] 是当前Reducer所对应的State，可以理解为当前的State var previousStateForKey = state[key]; var nextStateForKey = reducer(previousStateForKey, action); return nextStateForKey; &#125;); // finalState 是 Reducer的key和stat的组合。。 &#125;&#125; 从上面的源码可以看出，combineReducers 生成一个类似于Reducer的函数combination。 当使用combination的时候，combination会把所有子Reducer都执行一遍，子Reducer通过action.type 匹配操作，因为是执行所有子Reducer，所以如果两个子Reducer匹配的action.type是一样的，那么都会成功匹配。 注意: 不要修改 state。 使用 Object.assign() 新建了一个副本。不能这样使用 Object.assign(state, {visibilityFilter: action.filter })，因为它会改变第一个参数的值。你必须把第一个参数设置为空对象。你也可以开启对ES7提案对象展开运算符的支持, 从而使用 { ...state, ...newState } 达到相同的目的。 12state = &#123;name:&apos;Jhon&apos;,age:18&#125; &#123;...state,address : &apos;China&apos;&#125; =&gt; &#123; name: &apos;Jhon&apos;, age: 18, address: &apos;China&apos; &#125; 在 default 情况下返回旧的 state。遇到未知的 action 时，一定要返回旧的 state。if you don’t, you’ll end up having your reducer return undefined (and lose your state). 我们可以看下源代码为什么必须返回一个state;如下所示，如果reducer函数没有显式返回state,那么 currentReducer()函数执行之后，函数的默认返回值是undefined;这就是为什么我们会失去state的根本原因； 在使用combineReducers方法时，它也会检测你的函数写的是否标准。如果不标准，那么会抛出一个大大的错误！！ 12// currentState 是当前的State，currentReducer 是当前的ReducercurrentState = currentReducer(currentState, action); ​ 注意每个 reducer 只负责管理全局 state 中它负责的一部分。每个 reducer 的 state 参数都不同，分别对应它管理的那部分 state 数据 3 storestore就是将action和reducers联系到一起的对象；注意也就是一个javascript对象，这个对象里面有一些方法； 维持应用的 state； 提供 getState() 方法获取 state； 提供 dispatch(action) 唯一一个方法更新 state；action是一个对象，可以直接传入对象，也可以传入定义action 通过 subscribe(listener) 注册监听器，每当state状态改变的时候，注册的函数就会被调用 通过 replaceReducer(listener) 返回的函数注销监听器。用于替换创建store的reducer Redux 应用只有一个单一的 store。当需要拆分数据处理逻辑时，你应该使用 reducer 组合 而不是创建多个 store。 官方定义:In the previous sections, we defined the actions that represent the facts about “what happened” and the reducers that update the state according to those actions. The Store is the object that brings them together. The store has the following responsibilities: Holds application state; Allows access to state via getState(); Allows state to be updated via dispatch(action); Registers listeners via subscribe(listener). 如何创建一个store? 12//创建Store非常简单。createStore 有两个参数，Reducer 和 initialState。let store = createStore(rootReducers, initialState); ...是对象扩展运算符，会将对象展开 , 同时也会将数组展开 123456import &#123; createStore &#125; from 'redux'var reducer = function (...args) &#123; console.log('Reducer was called with args', args)&#125;var store_1 = createStore(reducer) ;// 12345//创建的store_1打印输出如下,可以看出store_1是一个对象，该对象有如下的方法(函数);&#123; dispatch: [Function: dispatch], subscribe: [Function: subscribe], getState: [Function: getState], replaceReducer: [Function: replaceReducer] &#125; 当我们创建reduex实例的时候，需要传递一个函数，也就是说createStore( reducer ,optional) 第一个参数需要传入函数处理逻辑；reducer是一个函数，reducer接受两个参数，第一个是state 第二是 action； 当执行createStore的时候，传入的第一个函数会被执行 123456789function addItem(text) &#123; return &#123; type: types.ADD_ITEM, text &#125;&#125;// 新增数据store.dispatch(addItem('Read the docs')); 看下dispatch底层是如何实现的:dispatch 核心源码 12345678910function dispatch(action) &#123; // currentReducer 是当前的Reducer currentState = currentReducer(currentState, action); listeners.slice().forEach(function (listener) &#123; return listener(); &#125;); return action;&#125; 可以看到其实就是把当前的Reducer执行了。并且传入State和Action。 dispatch异步实现 subscribe(listener) 可以使我们的state状态改变的时候，将数据的变化反映到视图view层 123456789101112131415161718192021222324252627282930313233343536373839import &#123;createStore,combineReducers&#125; from 'Redux';var itemReducers = function(state = [],action)&#123; console.log('itemsReducers was called with ',state,'and action',action); switch(action.type)&#123; case 'ADD_ITEM' : return [ ...state, action.item ] default : return state ; &#125;&#125;var reducers = combineReducers(&#123;items : itemReducers &#125;);var store_0 = createStore(reducers);console.log(store_0.getState());store_0.subscribe(function()&#123; //这个事件只有在state改变了才会触发，此时不会触发，因为还没有改变state,没有传入action console.log('store_0 has been updated,lasted store state ',store_0.getState()); //update your view &#125;)var addItemActionCreator = function(item)&#123; return &#123; type : 'ADD_ITEM', item &#125;&#125;store_0.dispatch(addItemActionCreator(&#123;id:4,description:'anything'&#125;));//这一行代码执行之后，上面的subscribe函数才会被触发]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[jsx in depth]]></title>
      <url>%2F2017%2F04%2F24%2F189jsx-in-depth%2F</url>
      <content type="text"><![CDATA[1 在JSX中我们可以使用 . 来引用一个组件1234567891011121314151617181920212223&lt;div id="root"&gt;&lt;/div&gt; &lt;script type='text/babel'&gt; function TestOne (props)&#123; const style = &#123;color : 'red'&#125; return ( &lt;div style = &#123;style&#125;&gt; this is red Component &#123;props.flag&#125; &lt;/div&gt; ); &#125; const MyComponent = &#123; TestOne : TestOne &#125; function TestTwo ()&#123; return ( &lt;MyComponent.TestOne /&gt; ); &#125; ReactDOM.render( &lt;TestTwo /&gt;, document.getElementById('root') ) &lt;/script&gt; 2 JSX中的props属性详解2.1 属性值可以是js表达式，也可以是字符串，默认值是true；以下属性可以通过 props.foo props.message props.autocomplete进行访问； 1234567&lt;MyComponent foo=&#123;1 + 2 + 3 + 4&#125; /&gt;&lt;MyComponent message=&quot;hello world&quot; /&gt;&lt;MyComponent message=&#123;&apos;hello world&apos;&#125; /&gt;&lt;MyTextBox autocomplete /&gt;&lt;MyTextBox autocomplete=&#123;true&#125; /&gt; 2.2 Children in JSX 首先来了解下定义，也就是说，在有开闭标签组件的中的内容就是 props.children对象对应的值 In JSX expressions that contain both an opening tag and a closing tag, the content between those tags is passed as a special prop: props.children. There are several different ways to pass children: 2.2.1 字符串 作为props.chidlren 1234567891011121314&lt;div id="root"&gt;&lt;/div&gt; &lt;script type='text/babel'&gt; function MyComponent (props)&#123; return ( &lt;div&gt; &#123;props.children&#125; &lt;/div&gt; ); &#125; ReactDOM.render( &lt;MyComponent &gt;this is passed by props.children&lt;/MyComponent&gt;, document.getElementById('root') ) &lt;/script&gt; 2.2.2 js表达式 作为props.children 首先要了解 React会将数组中的内容展开然后渲染到页面 123456789101112131415161718&lt;div id="root"&gt;&lt;/div&gt; &lt;script type='text/babel'&gt; function MyComponent(props)&#123; return ( &lt;ul&gt; &#123;props.children&#125; &lt;/ul&gt; ); &#125; const numbers = [1,2,3,4]; const listItems = numbers.map((number)=&gt;&#123;return &lt;li&gt;&#123;number&#125;&lt;/li&gt;&#125;) ReactDOM.render( &lt;MyComponent &gt;&#123;listItems&#125;&lt;/MyComponent&gt;, document.getElementById('root') ) &lt;/script&gt; 2.2.3 JSX 表达式也可以作为 props.children 传入 12345678910111213141516171819202122&lt;div id="root"&gt;&lt;/div&gt; &lt;script type='text/babel'&gt; function MyComponent(props)&#123; return ( &lt;ul&gt; &#123;props.children&#125; &lt;/ul&gt; ); &#125; function MyInnerComponent ()&#123; return ( &lt;li&gt;this is innerCmponent&lt;/li&gt; ); &#125; ReactDOM.render( &lt;MyComponent &gt; &lt;MyInnerComponent /&gt; &lt;/MyComponent&gt;, document.getElementById('root') ) &lt;/script&gt; 2.2.4 函数作为props.children传入 没有被函数操作之前 123456789101112131415161718&lt;div id="root"&gt;&lt;/div&gt; &lt;script type='text/babel'&gt; function Repeat()&#123; let arr = []; for(let i = 0 ; i &lt; 10 ; i++)&#123; arr.push(i) &#125; return ( &lt;div&gt; &#123;arr&#125; &lt;/div&gt; ); &#125; ReactDOM.render( &lt;Repeat /&gt;, document.getElementById('root') ) &lt;/script&gt; 被props.children函数操作之后 123456789101112131415161718&lt;div id="root"&gt;&lt;/div&gt; &lt;script type='text/babel'&gt; function Repeat(props)&#123; let arr = []; for(let i = 0 ; i &lt; 10 ; i++)&#123; arr.push(props.children(i)) &#125; return ( &lt;div&gt; &#123;arr&#125; &lt;/div&gt; ); &#125; ReactDOM.render( &lt;Repeat&gt;&#123;(index)=&gt;index*2&#125;&lt;/Repeat&gt;, document.getElementById('root') ) &lt;/script&gt; 2.2.5 null undefined false true 都不会被渲染 false, null, undefined, and true are valid children. They simply don’t render. These JSX expressions will all render to the same thing: 12345678910&lt;div id="root"&gt;&lt;/div&gt; &lt;script type='text/babel'&gt; ReactDOM.render( &lt;div&gt; &#123;null &#125; &lt;/div&gt;, document.getElementById('root') ) &lt;/script&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Refs And DOM]]></title>
      <url>%2F2017%2F04%2F24%2F191Refs-And-DOM%2F</url>
      <content type="text"><![CDATA[1 ref 属性是一个函数的时候 当一个组件被加载完成之后，ref指向的函数会被执行。 React supports a special attribute that you can attach to any component. The ref attribute takes a callback function, and the callback will be executed immediately after the component is mounted or unmounted. React will call the ref callback with the DOM element when the component mounts, and call it with null when it unmounts. 12345678910111213141516171819202122232425262728293031&lt;div id="root"&gt;&lt;/div&gt; &lt;script type='text/babel'&gt; class CustomTextInput extends React.Component&#123; constructor(props)&#123; super(props); this.focus = this.focus.bind(this); &#125; focus()&#123; this.textInput.focus(); console.log(this.textInput); console.log(this); &#125; render()&#123; return( &lt;div&gt; &lt;input type="text" ref = &#123;(input)=&gt;this.textInput = input&#125;/&gt; &lt;input type="button" value="Focus on this" onClick = &#123;this.focus&#125;/&gt; &lt;/div&gt; ); &#125; &#125; ReactDOM.render( &lt;CustomTextInput /&gt;, document.getElementById('root') ) &lt;/script&gt; 2 当ref属性是一个字符串的时候注意：官方文档已经不建议使用字符串作用ref属性的值 12345678910111213141516171819202122232425262728293031&lt;div id="root"&gt;&lt;/div&gt; &lt;script type='text/babel'&gt; class CustomTextInput extends React.Component&#123; constructor(props)&#123; super(props); this.focus = this.focus.bind(this); &#125; focus()&#123; console.log(this); this.refs.myFocus.focus(); &#125; render()&#123; return( &lt;div&gt; &lt;input type="text" ref = 'myFocus' /&gt; &lt;input type="button" value="Focus on this" onClick = &#123;this.focus&#125;/&gt; &lt;/div&gt; ); &#125; &#125; ReactDOM.render( &lt;CustomTextInput /&gt;, document.getElementById('root') ) &lt;/script&gt; 3 Uncontrolled ComponentsIn most cases, we recommend using controlled components to implement forms. In a controlled component, form data is handled by a React component. The alternative is uncontrolled components, where form data is handled by the DOM itself. To write an uncontrolled component, instead of writing an event handler for every state update, you can use a ref to get form values from the DOM. 123456789101112131415161718192021222324252627282930313233343536&lt;div id="root"&gt;&lt;/div&gt; &lt;script type='text/babel'&gt; class NameForm extends React.Component&#123; constructor(props)&#123; super(props); this.handleSubmit = this.handleSubmit.bind(this); &#125; handleSubmit(e)&#123; console.log(this.input); console.log(this.input.value); e.preventDefault(); &#125; render()&#123; return( &lt;form onSubmit = &#123;this.handleSubmit&#125;&gt; &lt;input type="text" ref = &#123;(input)=&gt;&#123;console.log(input);console.log(this); this.input = input ; &#125;&#125;/&gt; &lt;input type="submit" value="click to submit" ref = &#123;(input)=&gt;&#123;console.log(input);this.input = input ; &#125;&#125;/&gt; &lt;/form&gt; ); &#125; &#125; ReactDOM.render( &lt;NameForm /&gt;, document.getElementById("root") ) &lt;/script&gt; 以上代码案例可以解释箭头函数中的内部this指向 箭头函数内部的this指向class类 this.input = input 决定 当前类的 input指向哪个 input标签，后面的会覆盖掉前面的 4 React 中的 value属性值 defaultValueIn the React rendering lifecycle, the value attribute on form elements will override the value in the DOM. With an uncontrolled component, you often want React to specify the initial value, but leave subsequent updates uncontrolled. To handle this case, you can specify a defaultValue attribute instead of value. 如果我们添加value = ‘this can not be changed’给input标签，那么该标签是无法重新写入内容的 12345678&lt;form onSubmit = &#123;this.handleSubmit&#125;&gt; &lt;input type="text" value = 'this can not be changed' ref = &#123;(input)=&gt;&#123;console.log(input);console.log(this); this.input = input ; &#125;&#125;/&gt; &lt;input type="submit" value="click to submit" ref = &#123;(input)=&gt;&#123;console.log(input);this.input = input ; &#125;&#125;/&gt; &lt;/form&gt; 改成defaultValue可以重新写入 defaultValue = ‘this can not be changed’ 除了input之外 Likewise, &lt;input type=&quot;checkbox&quot;&gt; and &lt;input type=&quot;radio&quot;&gt; support defaultChecked, and &lt;select&gt; and &lt;textarea&gt; supports defaultValue.也是一样的道理]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[React Optimizing Performance]]></title>
      <url>%2F2017%2F04%2F24%2F192React-Optimizing-Performance%2F</url>
      <content type="text"><![CDATA[1 首先理解shouldComponentUpdate 作用shouldComponentUpdate: 这是一个和性能非常相关的方法，在每一次render方法之前被调用。它提供了一个机会让你决定是否要对组件进行实际的render 它是react性能优化非常重要的一环。组件接受新的state或者props时调用，我们可以设置在此对比前后两个props和state是否相同，如果相同则返回false阻止更新，因为相同的属性状态一定会生成相同的dom树，这样就不需要创造新的dom树和旧的dom树进行diff算法对比，节省大量性能，尤其是在dom结构复杂的时候。不过调用this.forceUpdate会跳过此步骤。 In some cases, your component can speed all of this up by overriding the lifecycle function shouldComponentUpdate, which is triggered before the re-rendering process starts. The default implementation of this function returns true, leaving React to perform the update: 123shouldComponentUpdate(nextProps, nextState) &#123; return true;&#125; If you know that in some situations your component doesn’t need to update, you can return false from shouldComponentUpdate instead, to skip the whole rendering process, including calling render() on this component and below. 也就是说，如果shouldComponentUpdate返回true,那么React会调用render方法重新渲染页面，如果返回false,则React不会调用render方法。该方法接受两个参数，一个是下一个状态，一个是下一个props.可以和原来的props和state做对比; 12345678910111213141516171819202122232425262728293031323334&lt;div id="root"&gt;&lt;/div&gt; &lt;script type='text/babel'&gt; class CounterButton extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123;count: 1&#125;; &#125; shouldComponentUpdate(nextProps, nextState) &#123; if (this.props.color !== nextProps.color) &#123; return true; &#125; if (this.state.count !== nextState.count) &#123; return true; &#125; return false; &#125; render() &#123; return ( &lt;button color=&#123;this.props.color&#125; onClick=&#123;() =&gt; this.setState(state =&gt; (&#123;count: state.count + 1 &#125;))&#125;&gt; Count: &#123;this.state.count&#125; &lt;/button&gt; ); &#125;&#125; ReactDOM.render( &lt;CounterButton /&gt;, document.getElementById('root') ) &lt;/script&gt; 当我们改动一下代码，当count值改变之后，比较前后两者的值，如果不相等，返回false；此时不会更新视图,也就是说React没有再次调用render函数去重新渲染视图。 123if (this.state.count !== nextState.count) &#123; return false; &#125; 2 React.PureComponentIn this code, shouldComponentUpdate is just checking if there is any change in props.coloror state.count. If those values don’t change, the component doesn’t update. If your component got more complex, you could use a similar pattern of doing a “shallow comparison” between all the fields of props and state to determine if the component should update. This pattern is common enough that React provides a helper to use this logic - just inherit from React.PureComponent. So this code is a simpler way to achieve the same thing: React同样提供了简单的方法，可以不让我们每次都要写shouldComponnetUpdate判断props和state的状态 12345678910111213141516class CounterButton extends React.PureComponent &#123; constructor(props) &#123; super(props); this.state = &#123;count: 1&#125;; &#125; render() &#123; return ( &lt;button color=&#123;this.props.color&#125; onClick=&#123;() =&gt; this.setState(state =&gt; (&#123;count: state.count + 1&#125;))&#125;&gt; Count: &#123;this.state.count&#125; &lt;/button&gt; ); &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[React Router]]></title>
      <url>%2F2017%2F04%2F24%2F193React-Router%2F</url>
      <content type="text"></content>
    </entry>

    
    <entry>
      <title><![CDATA[react lifting State Up]]></title>
      <url>%2F2017%2F04%2F21%2F188react-lifting-State-Up%2F</url>
      <content type="text"><![CDATA[1 In React, sharing state is accomplished by moving it up to the closest common ancestor of the components that need it. This is called “lifting state up”.props应该是只读的属性，如果我们要改变输出，可以通过state属性改变； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;script src="../build/react.js"&gt;&lt;/script&gt; &lt;script src="../build/react-dom.js"&gt;&lt;/script&gt; &lt;script src="../build/browser.min.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="root"&gt;&lt;/div&gt; &lt;script type='text/babel'&gt; const scaleNames = &#123; c: 'Celsius', f: 'Fahrenheit'&#125;;function toCelsius(fahrenheit) &#123; return (fahrenheit - 32) * 5 / 9;&#125;function toFahrenheit(celsius) &#123; return (celsius * 9 / 5) + 32;&#125;function tryConvert(temperature, convert) &#123; const input = parseFloat(temperature); if (Number.isNaN(input)) &#123; return ''; &#125; const output = convert(input); const rounded = Math.round(output * 1000) / 1000; return rounded.toString();&#125;function BoilingVerdict(props) &#123; if (props.celsius &gt;= 100) &#123; return &lt;p&gt;The water would boil.&lt;/p&gt;; &#125; return &lt;p&gt;The water would not boil.&lt;/p&gt;;&#125;class TemperatureInput extends React.Component &#123; constructor(props) &#123; console.log(props) super(props); this.handleChange = this.handleChange.bind(this); &#125; handleChange(e) &#123; this.props.onTemperatureChange(e.target.value); &#125; render() &#123; const temperature = this.props.temperature; const scale = this.props.scale; return ( &lt;fieldset&gt; &lt;legend&gt;Enter temperature in &#123;scaleNames[scale]&#125;:&lt;/legend&gt; &lt;input value=&#123;temperature&#125; onChange=&#123;this.handleChange&#125; /&gt; &lt;/fieldset&gt; ); &#125;&#125;class Calculator extends React.Component &#123; constructor(props) &#123; console.log(props) super(props); this.handleCelsiusChange = this.handleCelsiusChange.bind(this); this.handleFahrenheitChange = this.handleFahrenheitChange.bind(this); this.state = &#123;temperature: '', scale: 'c'&#125;; &#125; handleCelsiusChange(temperature) &#123; this.setState(&#123;scale: 'c', temperature&#125;); &#125; handleFahrenheitChange(temperature) &#123; this.setState(&#123;scale: 'f', temperature&#125;); &#125; render() &#123; const scale = this.state.scale; const temperature = this.state.temperature; const celsius = scale === 'f' ? tryConvert(temperature, toCelsius) : temperature; const fahrenheit = scale === 'c' ? tryConvert(temperature, toFahrenheit) : temperature; return ( &lt;div&gt; &lt;TemperatureInput scale="c" temperature=&#123;celsius&#125; onTemperatureChange=&#123;this.handleCelsiusChange&#125; /&gt; &lt;TemperatureInput scale="f" temperature=&#123;fahrenheit&#125; onTemperatureChange=&#123;this.handleFahrenheitChange&#125; /&gt; &lt;BoilingVerdict celsius=&#123;parseFloat(celsius)&#125; /&gt; &lt;/div&gt; ); &#125;&#125;ReactDOM.render( &lt;Calculator /&gt;, document.getElementById('root')); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 2 props中的children1234567891011121314151617181920212223242526272829&lt;body&gt; &lt;div id="root"&gt;&lt;/div&gt; &lt;script type='text/babel'&gt; function FacnyBorder(props)&#123; console.log(props); console.log(props.children); return ( &lt;div className = &#123;'FancyBorder FancyBorder-'+ props.color&#125;&gt; &#123;props.children&#125; &lt;/div&gt; ) &#125; function WelecomeDialog(props)&#123; console.log(props) return ( &lt;FacnyBorder color = 'blue'&gt; &lt;h1 className = 'Dialog-title'&gt;welcome&lt;/h1&gt; &lt;p&gt; className = 'Dialog-message'&gt;thank you for visiting our website&lt;/p&gt; &lt;/FacnyBorder&gt; ) &#125; ReactDOM.render( &lt;WelecomeDialog /&gt;, document.getElementById('root') ) &lt;/script&gt; WelcomeDialog组件输出的props如下 123456Object &#123;&#125;key:(...)ref:(...)get key:function ()get ref:function ()__proto__:Object FacnyBorder输出的props如下 12345678Object &#123;color: &quot;blue&quot;, children: Array(2)&#125;children:Array(2)color:&quot;blue&quot;key:(...)ref:(...)get key:function ()get ref:function ()__proto__:Object FacnyBorder输出的 props.children 如下 1234[Object, Object]0:Object1:Objectlength:2 其中 数组中的第一项展开内容如下 12345678910111213141516$$typeof:Symbol(react.element)key:nullprops:Object children:&quot;welcome&quot; className:&quot;Dialog-title&quot; key:(...) ref:(...) get key:function () get ref:function () __proto__:Objectref:nulltype:&quot;h1&quot;_owner:ReactCompositeComponentWrapper_store:Object_self:null_source:null 其中数组第二项展开如下 12345678910111213141516$$typeof:Symbol(react.element)key:nullprops:Object children:&quot;thank you for visiting our website&quot; className:&quot;Dialog-message&quot; key:(...) ref:(...) get key:function () get ref:function () __proto__:Objectref:nulltype:&quot;p&quot;_owner:ReactCompositeComponentWrapper_store:Object_self:null_source:null&quot; 同样在React中 1React elements like &lt;Contacts /&gt; and &lt;Chat /&gt; are just objects, so you can pass them as props like any other data. 还是上面的例子，我们尝试着打印出 1console.log(&lt;WelecomeDialog color = &apos;red&apos;/&gt;) 输出结果如下 12345678910Object &#123;$$typeof: Symbol(react.element), key: null, ref: null, props: Object, type: function…&#125;$$typeof:Symbol(react.element)key:nullprops:Objectref:nulltype:function WelecomeDialog(props)_owner:null_store:Object_self:null_source:null submit 根据以上的输出我们可以得到结论： 组件上通过属性添加的数据，会绑定在props对象中 组件上通过子节点，比如文本节点或者元素节点添加在组件上的，会绑定到props.children对象上 1&lt;WelecomeDialog&gt;hello&lt;/WelecomeDialog&gt; 比如中的hello文本节点 12345&lt;FacnyBorder color = &apos;blue&apos;&gt; &lt;h1 className = &apos;Dialog-title&apos;&gt;welcome&lt;/h1&gt; &lt;p className = &apos;Dialog-message&apos;&gt;thank you for visiting our website&lt;/p&gt;&lt;/FacnyBorder&gt;中的元素节点 h1和p 组件以标签形式显示的时候，其实也就是一个对象 如果想要向组件中传递参数，可以通过属性或者子节点进行传递，传递的数据可以在组件定义中的props和props.children中获取到。 React区分标签是一个组件还是一个HTML标签是根据标签的首字母大小写来区分的 12&lt;div /&gt; 这个就是代表HTML标签&lt;Contact /&gt; 这个就代表组件 React中无论是组件还是标签，都必须被正确的闭合 每一个标签或者组件的 / 必不可少 ; 3 除了通过children传递data数据，我们其实可以利用props传递组件对象1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;div id="root"&gt;&lt;/div&gt; &lt;script type='text/babel'&gt; function Contacts()&#123; return ( &lt;div className = 'contacts'&gt; this is contacts &lt;/div&gt; ) &#125; function Chat()&#123; return ( &lt;div className = 'chat' &gt;this is chat &lt;/div&gt; ) &#125; function SplitPane(props)&#123; console.log(props) return( &lt;div className = 'SplitPane'&gt; &lt;div className = 'SplitPane-left'&gt; &#123;props.left&#125; &lt;/div&gt; &lt;div className = 'SplitPane-right'&gt; &#123;props.right&#125; &lt;/div&gt; &lt;/div&gt; ) &#125; function App(props)&#123; return ( &lt;SplitPane left = &#123;&lt;Contacts/&gt;&#125; right = &#123;&lt;Chat/&gt;&#125; /&gt; ) &#125; ReactDOM.render( &lt;App /&gt;, document.getElementById('root') ) &lt;/script&gt; 通过以上用法，我们就可以传递多个不一样的组件，也就是可以对组件进行不一样的拼接。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[isNaN And NumberisNaN]]></title>
      <url>%2F2017%2F04%2F19%2F187isNaN-And-NumberisNaN%2F</url>
      <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;script&gt; //Number.isNaN() 不会进行类型转化，直接进行isNaN的判断；简而言之就是分两步 //第一步，如果传入的参数不是类型不是number直接返回 false //第二步，如果传入的参数类型是number,判断是不是NaN，如果是返回true,否则返回false //这里需要注意的一点是 NaN也是number类型的数据 /* Number.isNan() does not convert the values to a Number, and will return false for any value that is not of the type Number【If Type(number) is not Number, return false.If number is NaN, return true.Otherwise, return false.*/ console.log(Number.isNaN(1));//false console.log(Number.isNaN('str'));//false console.log(Number.isNaN(NaN));//True //全局方法isNaN（）会先将参数转为Number 类型，在判断是否为NaN ，所以在类型转换失败或运算错误时值为NaN，返回true，其他全为false //全局isNaN会先进行类型转化为Number类型,这个时候需要掌握Number类型转化的规则，如果转化结果是NaN，那么isNaN返回true,其他全部为false /* The global isNaN() function converts the tested value to a Number, then tests it.【 If value can not convert to Number, return true. else If number arithmethic result is NaN, return true. Otherwise, return false.*/ console.log(isNaN('str'));//true console.log(isNaN(1));//fasle console.log(isNaN(undefined));//true console.log(isNaN("Hello"));//true /* isNaN() 函数通常用于检测 parseFloat() 和 parseInt() 的结果，以判断它们表示的是否是合法的数字。当然也可以用 isNaN() 函数来检测算数错误，比如用 0 作除数的情况。*/ &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[react State 和 lifeCycle]]></title>
      <url>%2F2017%2F04%2F19%2F184reactStateAndLifeCycle%2F</url>
      <content type="text"><![CDATA[1 先来看下函数定义组件123456789101112131415161718192021&lt;div id="root"&gt;&lt;/div&gt; &lt;script type='text/babel'&gt; function Clock(props)&#123; return ( &lt;div&gt; &lt;p&gt;hello world&lt;/p&gt; &lt;p&gt;it is &#123;props.date.toLocaleTimeString()&#125;&lt;/p&gt; &lt;/div&gt; ); &#125; function tick ()&#123; ReactDOM.render( &lt;Clock date = &#123;new Date()&#125;/&gt;, document.getElementById('root') ) &#125; setInterval(tick,1000); &lt;/script&gt; 如何让Clock拥有自动更新UI的能力？就像这个样子实现功能？ 1234ReactDOM.render( &lt;Clock /&gt;, document.getElementById('root')); To implement this, we need to add “state” to the Clock component. State is similar to props, but it is private and fully controlled by the component. We mentioned before that components defined as classes have some additional features. Local state is exactly that: a feature available only to classes. 2 将函数定义组件的方式改为类定义组件12345678910class Clock extends React.Component&#123; render()&#123; return ( &lt;div&gt; &lt;p&gt;hello world&lt;/p&gt; &lt;p&gt;it is &#123;this.props.date.toLocaleTimeString()&#125;&lt;/p&gt; &lt;/div&gt; ); &#125; &#125; 2.1 如何将当前状态添加进类定义的组件？如何将 date 属性从props 对象迁移至 state对象？ 添加一个constructor构造函数 将date赋值给this.state 我们需要将this.props.date 改成 this.state.date 移除掉组件上的date 123456789101112131415161718192021class Clock extends React.Component&#123; constructor(props) &#123; super(props); this.state = &#123;date : new Date()&#125; //第一步 &#125; render()&#123; return ( &lt;div&gt; &lt;p&gt;hello world&lt;/p&gt; &lt;p&gt;it is &#123;this.state.date.toLocaleTimeString()&#125;&lt;/p&gt; //第二步 &lt;/div&gt; ); &#125; &#125; ReactDOM.render( &lt;Clock /&gt;, //第三步 document.getElementById('root') ) 2.2 接下来就需要设定定时器，可以是组件Clock设置自己的定时器，并且可以自动更新 Adding Lifecycle Methods to a Class In applications with many components, it’s very important to free up resources taken by the components when they are destroyed. We want to set up a timer whenever the Clock is rendered to the DOM for the first time. This is called “mounting” in React. We also want to clear that timer whenever the DOM produced by the Clock is removed. This is called “unmounting” in React. We can declare special methods on the component class to run some code when a component mounts and unmounts: 我们可以在组件上定义一些特殊的方法，当组件装配或者装卸的时候，运行某些代码 React有两个内置的方法 componentDidMount() componentWillUnmount() These methods are called “lifecycle hooks”. The componentDidMount() hook runs after the component output has been rendered to the DOM. This is a good place to set up a timer: 123456componentDidMount() &#123; this.timerID = setInterval( () =&gt; this.tick(), 1000 ); &#125; We will tear down the timer in the componentWillUnmount() lifecycle hook: 123componentWillUnmount() &#123; clearInterval(this.timerID); &#125; 完整代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940&lt;div id="root"&gt;&lt;/div&gt; &lt;script type='text/babel'&gt; class Clock extends React.Component&#123; constructor(props) &#123; super(props); this.state = &#123;date : new Date()&#125; &#125; tick()&#123; this.setState( &#123;date:new Date()&#125; ); &#125; componentDidMount()&#123; this.timerID = setInterval(()=&gt;this.tick(),1000) &#125; componentWillUnmount()&#123; clearInterval(this.timerID) &#125; render()&#123; return ( &lt;div&gt; &lt;p&gt;hello world&lt;/p&gt; &lt;p&gt;it is &#123;this.state.date.toLocaleTimeString()&#125;&lt;/p&gt; &lt;/div&gt; ); &#125; &#125; ReactDOM.render( &lt;Clock /&gt;, document.getElementById('root') ) &lt;/script&gt; Let’s quickly recap what’s going on and the order in which the methods are called: 1) When &lt;Clock /&gt; is passed to ReactDOM.render(), React calls the constructor of the Clock component. Since Clock needs to display the current time, it initializes this.statewith an object including the current time. We will later update this state. 2) React then calls the Clock component’s render() method. This is how React learns what should be displayed on the screen. React then updates the DOM to match the Clock‘s render output. 3) When the Clock output is inserted in the DOM, React calls the componentDidMount()lifecycle hook. Inside it, the Clock component asks the browser to set up a timer to call tick() once a second. 4) Every second the browser calls the tick() method. Inside it, the Clock component schedules a UI update by calling setState() with an object containing the current time. Thanks to the setState() call, React knows the state has changed, and calls render()method again to learn what should be on the screen. This time, this.state.date in the render() method will be different, and so the render output will include the updated time. React updates the DOM accordingly. 5) If the Clock component is ever removed from the DOM, React calls the componentWillUnmount() lifecycle hook so the timer is stopped. 3 setState( )函数3.1 接受一个对象作为参数 1this.setState(&#123;comment: 'Hello'&#125;); 3.2 接受一个函数作为参数,箭头函数返回值还是一个对象,也可以直接接受一个函数，返回一个对象 12345this.setState((prevState, props) =&gt; (&#123; counter: prevState.counter + props.increment&#125;));//如果用用箭头函数自定义对象 需要用小括号将花括号包起来，这个时候返回的结果才是一个对象 12345this.setState(function(prevState, props) &#123; return &#123; counter: prevState.counter + props.increment &#125;;&#125;); 3.3 注意对于state和props，它们的值可能被异步更新，所以当我们计算它们的下一个状态值的时候，不能依赖它们的当前值，比如如下demo不会更新 1234// Wrongthis.setState(&#123; counter: this.state.counter + this.props.increment,&#125;); 12345678910111213141516171819202122&lt;div id="root"&gt;&lt;/div&gt; &lt;script type='text/babel'&gt; class CounterButton extends React.Component&#123; constructor(props)&#123; super(props); this.state = &#123;count : 1 &#125; &#125; render()&#123; return ( &lt;button color = &#123;this.props.color&#125; onClick = &#123;()=&gt;this.setState(&#123;count : this.state.count++&#125;)&#125;&gt; count : &#123;this.state.count&#125; &lt;/button&gt; ); &#125; &#125; ReactDOM.render( &lt;CounterButton /&gt;, document.getElementById('root') ) &lt;/script&gt; 1234// Correctthis.setState((prevState, props) =&gt; (&#123; counter: prevState.counter + props.increment&#125;)); 12345678910111213141516171819202122&lt;div id="root"&gt;&lt;/div&gt; &lt;script type='text/babel'&gt; class CounterButton extends React.Component&#123; constructor(props)&#123; super(props); this.state = &#123;count : 1 &#125; &#125; render()&#123; return ( &lt;button color = &#123;this.props.color&#125; onClick = &#123;() =&gt; this.setState(state=&gt;(&#123;count:state.count + 1&#125;))&#125;&gt; count : &#123;this.state.count&#125; &lt;/button&gt; ); &#125; &#125; ReactDOM.render( &lt;CounterButton /&gt;, document.getElementById('root') ) &lt;/script&gt; 或者直接传入setState一个函数，该函数显示的返回一个对象 123456789101112131415161718192021222324252627&lt;div id="root"&gt;&lt;/div&gt; &lt;script type='text/babel'&gt; class CounterButton extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123;count: 1&#125;; &#125; render() &#123; return ( &lt;button color=&#123;this.props.color&#125; onClick=&#123;() =&gt; this.setState(function(state)&#123; return &#123; count : state.count + 1 &#125; &#125;)&#125;&gt; Count: &#123;this.state.count&#125; &lt;/button&gt; ); &#125; &#125; ReactDOM.render( &lt;CounterButton /&gt;, document.getElementById('root') ) &lt;/script&gt; 以下贴上一段React中关于setstate的源码，便于理解； 1234567891011121314151617ReactComponent.prototype.setState = function(partialState, callback) &#123; ("production" !== "development" ? invariant( typeof partialState === 'object' || typeof partialState === 'function' || partialState == null, 'setState(...): takes an object of state variables to update or a ' + 'function which returns an object of state variables.' ) : invariant(typeof partialState === 'object' || typeof partialState === 'function' || partialState == null)); if ("production" !== "development") &#123; ("production" !== "development" ? warning( partialState != null, 'setState(...): You passed an undefined or null state object; ' + 'instead, use forceUpdate().' ) : null); &#125; setState会自动调用render函数，触发视图的重新渲染，如果仅仅只是state数据的变化而没有调用setState，并不会触发更新。 4 react组件生命周期对于自定义组件，唯一必须实现的方法就是render()，除此之外，还有一些方法会在组件生命周期中被调用，如下 constructor: 构造函数，组件被创建时执行； componentDidMount: 当组件添加到DOM树之后执行； componentWillUnmount: 当组件从DOM树中移除之后执行，在React中可以认为组件被销毁； componentDidUpdate: 当组件更新时执行。 shouldComponentUpdate: 这是一个和性能非常相关的方法，在每一次render方法之前被调用。它提供了一个机会让你决定是否要对组件进行实际的render 123shouldComponentUpdate(nextProps, nextState) &#123; return nextProps.id !== this.props.id;&#125; 当此函数返回false时，组件就不会调用render方法从而避免了虚拟DOM的创建和内存中的Diff比较，从而有助于提高性能。当返回true时，则会进行正常的render的逻辑。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[react Compare Vue]]></title>
      <url>%2F2017%2F04%2F19%2F186react-Compare-Vue%2F</url>
      <content type="text"><![CDATA[1 react和vue优劣对比1.1 react 更适合大型应用和更好的可测试性 Web端和移动端原生APP通用 更大的生态系统，更多的支持和好用的工具，大量数据渲染react优势明显 可以创建一个同时适用于Web端和原生APP的框架 react由facebook维护，并且相应的社区以及组件都比较成熟 1.2 vue 模板和渲染函数的弹性选择 简单的语法和项目配置 更快的渲染速度和更小的体积 更加适合小且快，‘简单能用’，的单页面应用程序 vue 不适合持续的工程迭代，因为数据可以在view和model双向流动，但是带来的一个缺点是：工程规模比较大的时候，数据双向流动会带来难以预测的结果 vue是尤雨溪个人开发和维护，相应 的社区和组件不够成熟 2 react 和 vue 技术点对比2.1 react 采用ES6语法规范以及jsx语法 创建virtualDOM ,因为虚拟DOM是内存数据，大大提高了性能。 组件化的开发思路，带来了UI功能模块之间的分离 数据绑定: 采用单向数据流 React可以拓展到服务端，移动端Native部分 2.2 vue 采用模板语法，通过模板渲染前端页面 同时借鉴了angular和react,更加轻量级、简单、快捷 数据绑定默认单向数据流，也可以实现双向绑定 同样可以组件化开发，对于部署小型应用特别方便 Vue因为比较轻量，还能用于业务场景非常轻的页面中。 ###]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[react Event]]></title>
      <url>%2F2017%2F04%2F19%2F185react-Event%2F</url>
      <content type="text"><![CDATA[1 Handling events with React elements is very similar to handling events on DOM elements. There are some syntactic differences: React events are named using camelCase, rather than lowercase. With JSX you pass a function as the event handler, rather than a string. 函数的this指向null,而原先的HTML绑定时间this指向的是绑定事件的元素 react并不会真正的绑定事件到每一个具体的元素上，而是采用事件代理的模式：在根节点document上为每种事件添加唯一的Listener，然后通过事件对象的event.target找到真实的触发元素。这样从触发元素到顶层节点之间的所有节点如果有绑定这个事件，React都会触发对应的事件处理函数。这就是所谓的React模拟事件系统。 建议先了解下箭头函数，我也有些过关于箭头函数的博文 123456789&lt;body&gt; &lt;a href="http://www.baidu.com" onclick="console.log('The link was clicked.'); console.log(this);return false"&gt; Click me &lt;/a&gt; &lt;a href="http://www.baidu.com" onclick="console.log('The link was clicked.');"&gt; Click me&lt;/a&gt;&lt;/body&gt; 以上：这里面的this代表的是a标签 ；可以通过return false阻止默认事件 ；事件绑定命名用小写字母 12345678910111213141516171819&lt;div id="root"&gt;&lt;/div&gt; &lt;script type='text/babel'&gt; function ActionLink(props)&#123; function HandlerClick(e)&#123; e.preventDefault(); console.log(this) &#125; return ( &lt;a href="http://www.baidu.com" onClick = &#123;HandlerClick&#125;&gt;click me react&lt;/a&gt; ) &#125; ReactDOM.render( &lt;ActionLink /&gt;, document.getElementById('root') ) &lt;/script&gt; 以上：这里面的this代表的是null ；不可以通过return false阻止默认事件 ，只能用e.preventDefalut() ；事件绑定命名用驼峰命名的方式 以上函数声明组件等价于以下class类声明组件，重点注意this指向null,而不是元素标签,为了使handle函数内部的this不是指向null或者undefined，需要我们手动绑定这些函数执行的时候this的指向 123456789101112131415161718192021&lt;div id="root"&gt;&lt;/div&gt; &lt;script type='text/babel'&gt; class ActionLink extends React.Component&#123; HandlerClick(e)&#123; e.preventDefault(); console.log(this); &#125; render()&#123; return ( &lt;a href="http://www.baidu.com" onClick = &#123;this.HandlerClick&#125;&gt;click me react&lt;/a&gt; ) &#125; &#125; ReactDOM.render( &lt;ActionLink /&gt;, document.getElementById('root') ) &lt;/script&gt; 那么如何使得HandlerClick函数内部的this指向改变？ 1234567891011121314151617181920212223242526&lt;div id="root"&gt;&lt;/div&gt; &lt;script type='text/babel'&gt; class ActionLink extends React.Component&#123; constructor(props)&#123; super(props); this.HandlerClick = this.HandlerClick.bind(this); &#125; HandlerClick(e)&#123; e.preventDefault(); console.log(this); &#125; render()&#123; return ( &lt;a href="http://www.baidu.com" onClick = &#123;this.HandlerClick&#125;&gt;click me bind&lt;/a&gt; ) &#125; &#125; ReactDOM.render( &lt;ActionLink /&gt;, document.getElementById('root') ) &lt;/script&gt; 这个时候可以发现控制台输出的this指向的是 1ActionLink &#123;props: Object, context: Object, refs: Object, updater: Object, HandlerClick: function…&#125; 2 接下来走一个改变this指向应用的实例1234567891011121314151617181920212223242526272829&lt;div id="root"&gt;&lt;/div&gt; &lt;script type='text/babel'&gt; class Toggle extends React.Component&#123; constructor(props)&#123; super(props); this.state = &#123;isToggleOn : true&#125;; this.handlerClick = this.handlerClick.bind(this); &#125; handlerClick()&#123; console.log(this); this.setState((prevState)=&gt;(&#123;isToggleOn : !prevState.isToggleOn&#125;)); &#125; render()&#123; return ( &lt;button onClick = &#123;this.handlerClick&#125;&gt; &#123;this.state.isToggleOn?'on':'off'&#125; &lt;/button&gt; ); &#125; &#125; ReactDOM.render( &lt;Toggle /&gt;, document.getElementById('root') ) &lt;/script&gt; 同样使用箭头函数也可以达到类似的效果，改变render函数，一定要明确箭头函数的特性，同时()不要忘记加； 1234567render()&#123; return ( &lt;button onClick = &#123;()=&gt;this.handlerClick()&#125;&gt; &#123;this.state.isToggleOn?'on':'off'&#125; &lt;/button&gt; ); &#125; 看一下这段代码,也是通过箭头函数指定的this指向. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import React, &#123; Component &#125; from &apos;react&apos;import PropTypes from &apos;prop-types&apos;class Counter extends Component &#123; static propTypes = &#123; value: PropTypes.number.isRequired, onIncrement: PropTypes.func.isRequired, onDecrement: PropTypes.func.isRequired &#125; incrementIfOdd = () =&gt; &#123; if (this.props.value % 2 !== 0) &#123; this.props.onIncrement() &#125; &#125; incrementAsync = () =&gt; &#123; setTimeout(this.props.onIncrement, 1000) &#125; render() &#123; const &#123; value, onIncrement, onDecrement &#125; = this.props return ( &lt;p&gt; Clicked: &#123;value&#125; times &#123;&apos; &apos;&#125; &lt;button onClick=&#123;onIncrement&#125;&gt; + &lt;/button&gt; &#123;&apos; &apos;&#125; &lt;button onClick=&#123;onDecrement&#125;&gt; - &lt;/button&gt; &#123;&apos; &apos;&#125; &lt;button onClick=&#123;this.incrementIfOdd&#125;&gt; Increment if odd &lt;/button&gt; &#123;&apos; &apos;&#125; &lt;button onClick=&#123;this.incrementAsync&#125;&gt; Increment async &lt;/button&gt; &lt;/p&gt; ) &#125;&#125;export default Counter 理解箭头函数 12345678910111213141516&lt;body&gt; &lt;input id='btn' value = 'button' type="button" &gt; &lt;script&gt; function arrow()&#123; console.log('this is arrow func'); &#125; document.getElementById('btn').onclick = ()=&gt;arrow() //等价于 document.getElementById('btn').onclick = function()( arrow() ; ) //当点击按钮的时候 onclick的事件监听函数执行,该函数执行的过程中,内部代码 arrow()会执行函数arrow，所以这就是()不要忘记加的原因 &lt;/script&gt;&lt;/body&gt; 控制台输出的this都是 1Toggle &#123;props: Object, handlerClick:function (),context: Object, refs: Object, updater: Object, state: Object…&#125; 3 使用箭头函数注意细节但是如果使用以下写法就不会绑定this到Togglel了]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[svn]]></title>
      <url>%2F2017%2F04%2F18%2F181svn%2F</url>
      <content type="text"><![CDATA[一、SVN工作原理SVN（SubVersion）的基本工作思路是这样的：在一台服务器上建立一个源代码库，库里可以存放许多不同项目的源程序，由源代码库管理员统一管理这些源程序。 每个用户在使用源代码库之前，首先要把源代码库里的项目文件下载到本地（Checkout），然后用户可以在本地任意修改，最后用svn命令进行提交（Commit），由svn源代码库统一管理修改;update可以更新服务器上的最新的代码； SVN服务器：运行SubVersion服务的计算机，SubVersion支持Linux和Windows，更多的是安装在Linux下。SVN提供服务有两种方式（运行方式）：独立服务器和借助Apache服务器，分别使用SVN协议和Http协议。 SVN客户端：用户通过SVN客户端同SVN服务器打交道，SVN客户端分为命令行工具和图形化工具。最流行的客户端是TortoiseSVN。也可以在Eclipse中使用SVN插件。 二、SubVersion的使用shift+右键 可以直接在摸个目录打开终端命令行 1、创建SVN仓库 1）先创建一个目录：E:\svnrepo\repoDemo1。后面就使用该目录作为SVN仓库。 2）创建仓库：svnadmin create E:\svnrepo\repoDemo1。 3）启动SVN服务：svnserve -d -r E:\svnrepo\repoDemo1， 这样就启动了repoDemo1这个仓库的服务（单仓库），如果在svnrepo目录下还有其他仓库，且要同时启动多个仓库，执行svnserve -d -r E:\svnrepo即可（多仓库）。 注：-d参数效果同于-daemon-r参数效果同于-rootsvnserve 将会在端口 3690 等待请求，-daemon（两个短横线）告诉 svnserve 以守护 进程方式运行，这样在手动终止之前不会退出。不要关闭命令行窗口，关闭窗口会把 svnserve 停止。-root设置根位置来限制服务器的访问目录，从而增加安全性和节约输入svnserve URL的时间。如果不加root参数，服务url为：svn://192.168.1.188/svnrepo/repoDemo1如果加上root参数，服务url为：svn://192.168.1.188/repoDemo1此处的启动配置会影响服务url，如果输入url错误，会导致访问的时候出现异常。 一般情况下，访问SVN仓库的URL格式形如：svn://192.168.1.6/repoDemo1，但如果启动的是单仓库，则URL直接用：svn://192.168.1.6表示。svn协议的默认端口号为3690。 2、SVN客户端操作（命令行） 重点：checkout（检出）、commit（提交）、update（更新） 1）在E盘下建立user1、user2两个目录，模拟两个协同工作的用户的workspace。 2）检出：第一次和SVN服务器交互时，需要使用checkout将仓库检出到本地。 说明：检出一次，就建立了与SVN仓库的连接。 3）提交：commit 在user1目录下新建Demo1.java文件，将该文件提交到SVN仓库，提交之后，别人就可以从这个源代码库进行更新代码了 4）更新：update 切换到user2的工作空间（user2目录下），user2第一次使用SVN仓库，需要检出。user2修改Demo1.java后提交。切换到user1目录，更新（update）。 5）启动SVN服务。这步需要在命令行中输入：svnserve -d -r E:\svnrepo 6）访问SVN仓库。在任意空白位置右击 — TortoiseSVN — Repo browser，URL输入：svn://192.168.1.6/repoDemo2即可浏览SVN仓库中的内容 三、SVN的目录约定 /trunck：开发主线 /branches：支线副本 /tags：标签副本（一旦创建，不允许修改） 1 使用trunk作为主要的开发目录 一般的，我们的所有的开发都是基于trunk进行开发，当一个版本（release）开发告一段落（开发、测试、文档、制作安装程序、打包等结束后），代码处于冻结状态（人为规定，可以通过hook来进行管理）。此时应该基于当前冻结的代码库，打tag。 当下一个版本/阶段的开发任务开始时，继续在trunk进行开发。此时，如果发现了上一个已发行版本（Released Version）有一些bug，或者一些很急迫的功能要求，而正在开发的版本（Developing Version）无法满足时间要求，这时候就需要在上一个版本上进行修改了。解决方法是基于发行版对应的tag，做相应的分支（branch）进行开发。 2、其他操作 下面的操作都位于右键菜单的TortoiseSVN中。 1）删除：delete 删除文件或目录，不能直接用Windows的删除命令来操作，那样只是没有显示出来，实际并没有删除，在更新后，删除的文件又会被更新出来的。要想从库中 删除，必须选中你要删除的内容，TortoiseSVN — delete，这样才会将这个文件标记成要删除的。确认需要删除后，使用前面所讲的提交命令，就会真正的在库中删除了。否则版本库中依旧存在这原先的代码 2）重命名：rename 重命名也不能直接用Windows的重命名命令来操作，必须选中你要重命名的文件，TortoiseSVN — rename。修改后提交就可以更新到仓库。 改名的处理方式相当于新增了一个以新名称命名的文件，原名称命名的文件进行了删除。 3）还原：revert 在未提交之前，你对前面做的操作反悔了，可以使用revert来恢复。 4）检查更新：Check for modifications ① 此功能可以显示你所做的修改有哪些还没有提交的。② 还可以看到版本库里的改动，即别人提交了哪些文件的改动，你还没更新到本地。 5）导出：export 使用SVN的工作空间每个目录下面都有一个.svn隐藏目录，利用SVN的export命令可轻松地导出不含.svn目录的工作空间。 3、冲突问题的解决（☆） 何时发生：假设user3和user4目录下的Demo1.java都更新到了最新版本号100。user3修改Demo1.java，提交至仓库，此时显示提交成功，这个时候Demo.java文件版本号变成了101。若 user4也修改Demo1.java并提交(在版本号为100的上面进行文件修改，由于不是在最新的101版本号上进行的修改和提交，所以显示提交失败)，此时user4的TortoiseSVN会报提交版本过时的错误，并提醒user4需要更新，更新时就会发 生冲突。 如果两个程序员同时修改了同一个文件呢, SVN可以合并这两个程序员的改动，实际上SVN管理源代码是以行为单位的，就是说两个程序员只要不是修改了同一行程序，SVN都会自动合并两种修改。如果是同一行，SVN会提示文件Confict, 冲突，需要手动确认。 也就是说，如果两个人同时修改了文件，然后同时进行提交，那么就会出现冲突，解决冲突的办法就是编辑冲突，或者在另外一个人提交之后，先update到最新版本，然后进行文件修改。 对于每个更新冲突的文件，Subversion会在冲突文件所在目录下放置了三个文件： Demo1.java.mine：发生冲突时的本地版本。 Demo1.java.r3：最后更新之后的本地版本。 Demo1.java.r4：仓库中的最新版本。 解决方法 1： ① 在Demo1.java上右击 — TortoiseSVN — Edit conflicts，这时你需要确定哪些代码是需要的，做一些必要的修改然后保存。小技巧：编辑冲突时，可使用直接复制需要的代码到Merged窗口即可。 ② 编辑完成后保存，直接选择Mark as resolved，即标记为冲突已解决。退出编辑冲突窗口，发现冲突发生时生成的三个文件被自动删除了，且Demo1.java变成了未提交状态。 ③ commit，OK。 解决方法 2： 直接修改Demo1.java，把其中的一些标记删除即可（前提是服务器上的和本地的内容都需要保存）。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[jsx基础]]></title>
      <url>%2F2017%2F04%2F18%2F182jsx%2F</url>
      <content type="text"><![CDATA[1 初识jsxReact 使用 JSX 来替代常规的 JavaScript。 JSX 是一个看起来很像 XML 的 JavaScript 语法扩展。 我们不需要一定使用 JSX，但它有以下优点： JSX 执行更快，因为它在编译为 JavaScript 代码后进行了优化。 它是类型安全的，在编译过程中就能发现错误。 使用 JSX 编写模板更加简单快速。 JSX 的基本语法规则：遇到 HTML 标签（以 &lt; 开头），就用 HTML 规则解析；遇到代码块（以 { 开头），就用 JavaScript 规则解析。上面代码的运行结果如下。 JSX语法，像是在Javascript代码里直接写XML的语法，实质上这只是一个语法糖，每一个XML标签都会被JSX转换工具转换成纯Javascript代码，React 官方推荐使用JSX， 当然你想直接使用纯Javascript代码写也是可以的，只是使用JSX，组件的结构和组件之间的关系看上去更加清晰。 JSX是一种语法糖，关于如何编译JSX代码可以参见如下链接 1var person = &lt;Person name=&#123;window.isLoggedIn ? window.name : ''&#125; /&gt;; 上述代码经过JSX编译后会得到： 1234var person = React.createElement( Person, &#123;name: window.isLoggedIn ? window.name : ''&#125;); 123&lt;MyButton color=&quot;blue&quot; shadowSize=&#123;2&#125;&gt; Click Me&lt;/MyButton&gt; 12345React.createElement( MyButton, &#123;color: &apos;blue&apos;, shadowSize: 2&#125;, &apos;Click Me&apos;) 12345678910111213141516171819//使用JSXReact.render( &lt;div&gt; &lt;div&gt; &lt;div&gt;content&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;, document.getElementById('example')); //不使用JSXReact.render( React.createElement('div', null, React.createElement('div', null, React.createElement('div', null, 'content') ) ), document.getElementById('example')); r如果标签是以小写字母开头，那么React会寻找内置标签，比如div sapn等 如果标签是以大写字母开头，React会调用React.createElement去编译这个标签 2 我们可以在JSX中 插入任何js表达式 123456function getGreeting(user) &#123; if (user) &#123; return &lt;h1&gt;Hello, &#123;formatName(user)&#125;!&lt;/h1&gt;; &#125; return &lt;h1&gt;Hello, Stranger.&lt;/h1&gt;;&#125; 12345678&lt;div id="root"&gt;&lt;/div&gt;&lt;script type='text/babel'&gt; ReactDOM.render( &lt;div &gt;&#123;1+3&#125;&lt;/div&gt; , document.getElementById('root') )&lt;/script&gt; props如果没有提供值，那么默认值是true,以下声明是等价的 123&lt;MyTextBox autocomplete /&gt;&lt;MyTextBox autocomplete=&#123;true&#125; /&gt; props声明可以是字符串类型以及js表达式 {} 包括的代码 123&lt;MyComponent message=&quot;hello world&quot; /&gt;&lt;MyComponent message=&#123;&apos;hello world&apos;&#125; /&gt; 指明类 12345678910111213141516const element1 = &lt;div className='hello'&gt;hello1&lt;/div&gt;//等价于以下const element2 = React.createElement( 'div', &#123;className:'sayHello2'&#125;, 'hello2' )//内部大概的解析过程// Note: this structure is simplifiedconst element = &#123; type: 'h1', props: &#123; className: 'greeting', children: 'Hello, world' &#125;&#125;; 完整代码如下 123456789101112131415161718192021222324252627282930313233&lt;div id="root1"&gt;&lt;/div&gt;&lt;div id="root2"&gt;&lt;/div&gt;&lt;script type='text/babel'&gt; const user = &#123; firstName:'Jhon', lastName:'Kobe' &#125;; function formatName(user)&#123; if(user)&#123; return user.firstName + " " + user.lastName ; &#125; return 'stranger hello ' &#125; const element1 = &lt;div className='hello'&gt;hello1&lt;/div&gt; const element2 = React.createElement( 'div', &#123;className:'sayHello2'&#125;, 'hello2' ) ReactDOM.render( element1, document.getElementById('root1') ) ReactDOM.render( element2, document.getElementById('root2') )&lt;/script&gt; 注意render函数中只能有一个顶层标签 12345678910&lt;div id="root"&gt;&lt;/div&gt;&lt;script type='text/babel'&gt; ReactDOM.render( &lt;div data-attr = 'name'&gt;this is a test &lt;h2&gt;this is a test 2 &lt;/h2&gt; &lt;/div&gt;, document.getElementById('root') )&lt;/script&gt; 以下是错误写法,顶层标签只能含有一个。 12345678&lt;div id="root"&gt;&lt;/div&gt; &lt;script type='text/babel'&gt; ReactDOM.render( &lt;div data-attr = 'name'&gt;this is a test&lt;/div&gt; &lt;h2&gt;this is a test 2 &lt;/h2&gt;, document.getElementById('root') ) &lt;/script&gt; 1234567891011&lt;script type='text/babel'&gt; var HelloWorld = React.createClass(&#123; render : function()&#123; return &lt;h1&gt;hello &#123;this.props.name1&#125;&lt;/h1&gt; &lt;h1&gt;hello &#123;this.props.name2&#125;&lt;/h1&gt; &#125; &#125;) &lt;HelloWorld name1 = 'Jhon' name2 = "JiM"/&gt; //这样也无法渲染出来 &lt;/script&gt; 可以使用三元运算符，但是不能使用if-else表达式 12345678910const i = 1 ;ReactDOM.render( &lt;div &gt;&#123; i == 1 ? ' 2' : '3' &#125; &lt;/div&gt; , document.getElementById('root'))]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[react 元素渲染和组件]]></title>
      <url>%2F2017%2F04%2F18%2F183react-%E5%85%83%E7%B4%A0%E6%B8%B2%E6%9F%93%E5%92%8C%E7%BB%84%E4%BB%B6%2F</url>
      <content type="text"><![CDATA[react特点 1.声明式设计 −React采用声明范式，可以轻松描述应用。 2.高效 −React通过对DOM的模拟，最大限度地减少与DOM的交互。 3.灵活 −React可以与已知的库或框架很好地配合。 4.JSX − JSX 是 JavaScript 语法的扩展。React 开发不一定使用 JSX ，但我们建议使用它。 5.组件 − 通过 React 构建组件，使得代码更加容易得到复用，能够很好的应用在大项目的开发中。 6.单向响应的数据流 − React 实现了单向响应的数据流，从而减少了重复代码，这也是它为什么比传统数据绑定更简单。 React的原理在Web开发中，我们总需要将变化的数据实时反应到UI上，这时就需要对DOM进行操作。而复杂或频繁的DOM操作通常是性能瓶颈产生的原因（如何进行高性能的复杂DOM操作通常是衡量一个前端开发人员技能的重要指标）。React为此引入了虚拟DOM（Virtual DOM）的机制：在浏览器端用Javascript实现了一套DOM API。基于React进行开发时所有的DOM构造都是通过虚拟DOM进行，每当数据变化时，React都会重新构建整个DOM树，然后React将当前整个DOM树和上一次的DOM树进行对比，得到DOM结构的区别，然后仅仅将需要变化的部分进行实际的浏览器DOM更新。而且React能够批处理虚拟DOM的刷新，在一个事件循环（Event Loop）内的两次数据变化会被合并，例如你连续的先将节点内容从A变成B，然后又从B变成A，React会认为UI不发生任何变化，而如果通过手动控制，这种逻辑通常是极其复杂的。尽管每一次都需要构造完整的虚拟DOM树，但是因为虚拟DOM是内存数据，性能是极高的，而对实际DOM进行操作的仅仅是Diff部分，因而能达到提高性能的目的。这样，在保证性能的同时，开发者将不再需要关注某个数据的变化如何更新到一个或多个具体的DOM元素，而只需要关心在任意一个数据状态下，整个界面是如何Render的。 1 HTML 标签 vs. React 组件React 可以渲染 HTML 标签 (strings) 或 React 组件 (classes)。 要渲染 HTML 标签，只需在 JSX 里使用小写字母的标签名。 12var myDivElement = &lt;div className="foo" /&gt;;ReactDOM.render(myDivElement, document.getElementById('example')); 要渲染 React 组件，只需创建一个大写字母开头的本地变量。 123var MyComponent = React.createClass(&#123;/*...*/&#125;);var myElement = &lt; MyComponent someProperty=&#123;true&#125; /&gt;;ReactDOM.render(myElement, document.getElementById('example')); React 的 JSX 使用大、小写的约定来区分本地组件的类和 HTML 标签。 注意， 原生 HTML 元素名以小写字母开头，而自定义的 React 类名以大写字母开头，比如 HelloMessage 不能写成 helloMessage。除此之外还需要注意组件类只能包含一个顶层标签，否则也会报错。 在定义一个组件的时候,output的所有的标签必须被正确的闭合，这样子react框架才能正确识别每个标签 12345678910render()&#123;return (&lt;form onSubmit = &#123;this.handleSubmit&#125;&gt; &lt;label for="name"&gt;name &lt;input type = "text" name="gender" value = &#123;this.state.value&#125; onChange = &#123;this.handleChange&#125;/&gt; &lt;/label&gt; &lt;input type="submit" value="submit"/&gt;&lt;/form&gt;)&#125; 注意每一个input标签里面的 最后的 / 不能缺少 Components must return a single root element. 2 react 元素的不可变性2.1 React Only Updates What’s Necessary React DOM compares the element and its children to the previous one, and only applies the DOM updates necessary to bring the DOM to the desired state. 3 react组件 组件是React中构建用户界面的基本单位。它们和外界的交互除了状态（state）之外，还有就是属性（props）。事实上，状态更多的是一个组件内部去自己维护，而属性则由外部在初始化这个组件时传递进来（一般是组件需要管理的数据）。React认为属性应该是只读的，一旦赋值过去后就不应该变化。 每个组件只需要前端开发者提供一个 render 函数，把 props 和 state 映射成网页元素。 setState : 组件规范中定义了setState方法，每次调用时都会更新组件的状态，触发render方法。需要注意，render方法是被异步调用的，这可以保证同步的多个setState方法只会触发一次render，有利于提高性能。和props不同，state是组件的内部状态，除了初始化时可能由props来决定，之后就完全由组件自身去维护。在组件的整个生命周期中，React强烈不推荐去修改自身的props，因为这会破坏UI和Model的一致性，props只能够由使用者来决定。 props : 组件自身定义了一组props作为对外接口，展示一个组件时只需要指定props作为XML节点的属性。组件很少需要对外公开方法，唯一的交互途径就是props。这使得使用组件就像使用函数一样简单，给定一个输入，组件给定一个界面输出。 this.props.children : this.props.children 的值有三种可能：如果当前组件没有子节点，它就是 undefined ;如果有一个子节点，数据类型是 object ；如果有多个子节点，数据类型就是 array 。所以，处理 this.props.children 的时候要小心。 声明组件有两种方式，一种是直接函数function声明 一种是直接class类声明 Components let you split the UI into independent, reusable pieces, and think about each piece in isolation. Conceptually, components are like JavaScript functions. They accept arbitrary inputs (called “props”) and return React elements describing what should appear on the screen. 函数声明组件 1234567891011121314&lt;div id="root"&gt;&lt;/div&gt;&lt;script type='text/babel'&gt; function Welcome(props)&#123; return &lt;h1&gt;hello &#123;props.name&#125;&lt;/h1&gt; &#125; const element = &lt;Welcome name = "Jhon"/&gt; ReactDOM.render( element, document.getElementById('root') )&lt;/script&gt; 类声明组件 super调用了父类的constructor创造了父类的实例对象this，然后用子类的构造函数进行修改 123456789101112131415&lt;div id="root"&gt;&lt;/div&gt;&lt;script type='text/babel'&gt; class Welcome extends React.Component &#123; render()&#123; return &lt;h1&gt;hello &#123;this.props.name&#125;&lt;/h1&gt; &#125; &#125; const element = &lt;Welcome name = 'Jhon'/&gt; ReactDOM.render( element, document.getElementById('root') )&lt;/script&gt; 当我们使用组件&lt;Welcome /&gt;时，其实是对Main类的实例化——new Welcome，只不过react对这个过程进行了封装，让它看起来更像是一个标签。类和模块内部默认使用严格模式，所以不需要用use strict指定运行模式。 React.Component is an abstract base class, so it rarely makes sense to refer to React.Component directly. Instead, you will typically subclass it, and define at least a render() method. 组件的 Let’s recap what happens in this example: We call ReactDOM.render() with the &lt;Welcome name=&quot;Jhon&quot; /&gt; element. React calls the Welcome component with {name: &#39;Jhon&#39;} as the props. Our Welcome component returns a &lt;h1&gt;Hello, Jhon&lt;/h1&gt; element as the result. React DOM efficiently updates the DOM to match &lt;h1&gt;Hello,Jhon&lt;/h1&gt;. 我们可以通过 this.props对象向组件传递参数 1234567891011121314&lt;div id="root"&gt;&lt;/div&gt; &lt;script type='text/babel'&gt; var HelloWorld = React.createClass(&#123; render : function()&#123; return &lt;h1&gt;hello &#123;this.props.name1&#125; &lt;p&gt;hello &#123;this.props.name2&#125;&lt;/p&gt; &lt;/h1&gt; &#125; &#125;) ReactDOM.render( &lt;HelloWorld name1 = 'Jhon' name2 = "JiM"/&gt;, document.getElementById('root') ) &lt;/script&gt; 复合组件 1234567891011121314151617181920212223&lt;div id="root"&gt;&lt;/div&gt; &lt;script type='text/babel'&gt; function Welcome(props)&#123; return &lt;h1&gt;hello &#123;props.name&#125;&lt;/h1&gt; &#125; function App()&#123; return ( &lt;div&gt; &lt;Welcome name = 'Jhon'/&gt; &lt;Welcome name = 'JiM'/&gt; &lt;Welcome name = 'Kobe'/&gt; &lt;/div&gt; ) &#125; const element = &lt;App /&gt; ReactDOM.render( element , document.getElementById('root') ) &lt;/script&gt; 注意组件实例化的时候传入的属性是js表达式的时候，要用{} 括起来 , javascritpExpression必须要用{ } 括起来 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;div id="root"&gt;&lt;/div&gt; &lt;script type='text/babel'&gt; function formateDate(date)&#123; return date.toLocaleDateString(); &#125; function Comment(props)&#123; console.log(props) return ( &lt;div className = "Comment"&gt; &lt;div className = 'UserInfo'&gt; &lt;img className = 'avatar' src=&#123;props.author.avatarUrl&#125; alt=&#123;props.author.name&#125;/&gt; &lt;div className = 'UserInfo-name'&gt; &#123;props.author.name&#125; &lt;/div&gt; &lt;/div&gt; &lt;div className = 'Comment-text'&gt; &#123;props.text&#125; &lt;/div&gt; &lt;div className = 'Comment-data'&gt; &#123;formateDate(props.date)&#125; &lt;/div&gt; &lt;/div&gt; ); &#125; const comment = &#123; date : new Date(), text : 'Thank you for give me the chance', author : &#123; name : 'Jhon', avatarUrl : 'http://placekitten.com/g/64/64' &#125; &#125; const element = &lt;Comment author = &#123;comment.author&#125; text = &#123;comment.text&#125; date = &#123;comment.date&#125; /&gt; ReactDOM.render( element, document.getElementById('root') ) &lt;/script&gt; 对于组合组件要进行抽取出来，即使功能在小，要充分利用react的组件化思想,以上代码通过组件化思想进行抽取之后 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;div id="root"&gt;&lt;/div&gt; &lt;script type='text/babel'&gt; function formateDate(date)&#123; return date.toLocaleDateString(); &#125; function UserInfo(props)&#123; return ( &lt;div className = 'UserInfo'&gt; &lt;img calssName = 'avatar' src = &#123;props.author.avatarUrl&#125; alt = &#123;props.author.name&#125;/&gt; &lt;div className = 'UserInfo-name'&gt; &#123;props.author.name&#125; &lt;/div&gt; &lt;/div&gt; ) &#125; function CommentText(props)&#123; return ( &lt;div className = 'Comment-text'&gt; &#123;props.text&#125; &lt;/div&gt; ) &#125; function CommentData (props)&#123; return ( &lt;div className = 'Comment-data'&gt; &#123;formateDate(props.date)&#125; &lt;/div&gt; ) &#125; function Comment(props)&#123; console.log(props) return ( &lt;div className = "Comment"&gt; &lt;UserInfo author = &#123;props.author&#125; /&gt; &lt;CommentText text = &#123;props.text&#125;/&gt; &lt;CommentData date = &#123;props.date&#125;/&gt; &lt;/div&gt; ); &#125; const comment = &#123; date : new Date(), text : 'Thank you for give me the chance', author : &#123; name : 'Jhon', avatarUrl : 'http://placekitten.com/g/64/64' &#125; &#125;const element = &lt;Comment author = &#123;comment.author&#125; text = &#123;comment.text&#125; date = &#123;comment.date&#125; /&gt; ReactDOM.render( element, document.getElementById('root') ) &lt;/script&gt; 123456789101112131415161718192021222324252627282930313233343536 &lt;div id="root"&gt;&lt;/div&gt; &lt;script type='text/babel'&gt; var WebSite = React.createClass(&#123; render : function()&#123; return ( &lt;div&gt; &lt;Name name = &#123;this.props.name&#125;/&gt; &lt;Link link = &#123;this.props.link&#125;/&gt; &lt;/div&gt; ); &#125; &#125;) var Name = React.createClass(&#123; render : function()&#123; return ( &lt;p&gt;hello &#123;this.props.name&#125;&lt;/p&gt; ); &#125; &#125;) var Link = React.createClass(&#123; render : function()&#123; return ( &lt;a href = &#123;this.props.link&#125;&gt; &#123;this.props.link&#125;&lt;/a&gt; ); &#125; &#125;) ReactDOM.render( &lt;WebSite name = 'Jhon' link = 'www.baidu.com'/&gt;, document.getElementById('root') ) &lt;/script&gt; 4 组件的属性我们声明一个组件，然后看下组件到底是什么 12345678910111213141516&lt;script type='text/babel'&gt; class ListItem extends React.Component&#123; render()&#123; return ( &lt;li&gt;&#123;this.props.name&#125;&lt;/li&gt; ) &#125; &#125; var element = &lt;ListItem name = 'Jhon'/&gt; ; console.log(element); ReactDOM.render( element, document.getElementById('root') ) &lt;/script&gt; 控制台输出如下 1Object &#123;$$typeof: Symbol(react.element), key: null, ref: null, props: Object, type: function…&#125; 123456789101112131415161718192021222324252627&lt;div id="root"&gt;&lt;/div&gt; &lt;script type='text/babel'&gt; class Clock extends React.Component&#123; constructor(props) &#123; super(props); console.log(this); &#125; render()&#123; return ( &lt;div&gt; &lt;p&gt;hello world&lt;/p&gt; &lt;/div&gt; ); &#125; &#125; ReactDOM.render( &lt;Clock /&gt;, document.getElementById('root') ) &lt;/script&gt; console.log(this)输出如下 1Clock &#123;props: Object, context: undefined, refs: Object, updater: Object&#125; console.log(&lt;Clock /&gt;) 输出如下 1Object &#123;$$typeof: Symbol(react.element), key: null, ref: null, props: Object, type: function…&#125; 刚开始学习React,总是有点模糊 props和state的区别，可以看出在打印this的时候，props就是存在的，而state需要定义之后才会显示 改变constructor函数，可以看出输出了state对象 state必须被设置为一个对象，否则React编译会报错，大家可以自行尝试下 1234567constructor(props) &#123; super(props); this.state = &#123;color : &apos;red&apos;&#125; console.log(this); console.log(this.setState); console.log(this.props); &#125; 1Clock &#123;props: Object, context: undefined, refs: Object, updater: Object, state: Object&#125; 以上consturctor函数中，我们也打印了 console.log(this.setState); 其实在React源码中，setState是存在于 React.Component上的原型上的 1ReactComponent.prototype.setState = function (partialState, callback) &#123; sonmeCode &#125; ; 5 组件的render函数The render() method is required. When called, it should examine this.props and this.state and return a single React element. This element can be either a representation of a native DOM component, such as &lt;div /&gt;, or another composite component that you’ve defined yourself. You can also return null or false to indicate that you don’t want anything rendered. When returning null or false, ReactDOM.findDOMNode(this) will return null. The render() function should be pure, meaning that it does not modify component state, it returns the same result each time it’s invoked, and it does not directly interact with the browser. If you need to interact with the browser, perform your work in componentDidMount()or the other lifecycle methods instead. Keeping render() pure makes components easier to think about. 需要注意的是: render() will not be invoked if shouldComponentUpdate() returns false. 6 PropTypes该属性用来规范组件的props属性的类型 1234567891011121314151617181920212223242526272829303132React.PropTypes.array // 陣列React.PropTypes.bool.isRequired // Boolean 且必要。React.PropTypes.func // 函式React.PropTypes.number // 數字React.PropTypes.object // 物件React.PropTypes.string // 字串React.PropTypes.node // 任何類型的: numbers, strings, elements 或者任何這種類型的陣列React.PropTypes.element // React 元素React.PropTypes.instanceOf(XXX) // 某種XXX類別的實體React.PropTypes.oneOf([&apos;foo&apos;, &apos;bar&apos;]) // 其中一個字串React.PropTypes.oneOfType([React.PropTypes.string, React.PropTypes.array]) // 其中一種格式類型React.PropTypes.arrayOf(React.PropTypes.string) // 某種類型的陣列(字串類型)React.PropTypes.objectOf(React.PropTypes.string) // 具有某種屬性類型的物件(字串類型)React.PropTypes.shape(&#123; // 是否符合指定格式的物件 color: React.PropTypes.string, fontSize: React.PropTypes.number&#125;);React.PropTypes.any.isRequired // 可以是任何格式，且必要。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[面试题]]></title>
      <url>%2F2017%2F04%2F13%2F180%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
      <content type="text"><![CDATA[总结一些平时在电脑上写的很溜，但是在面试白班测试总是写不好的一些面试题吧!个人不喜欢白板测试，没有那种敲代码的感觉，并且一些细节也不好把控。 1 编写函数sum(2,3)和sum(2)(3)都能得到5 123456789101112131415function sum()&#123; var cache = arguments[0]; if(!arguments)&#123; return ; &#125;else if(arguments.length === 1)&#123; return function(num)&#123; return cache+num &#125;; &#125;else if(arguments.length === 2 )&#123; return arguments[0]+arguments[1]; &#125; &#125; console.log(sum(2,3)); console.log(sum(2)(3)); 2 url地址的操作 12345678910111213141516171819202122var url =' http://item.taobao.com/item.htm?a=1&amp;b=2&amp;c=&amp;d=xxx&amp;e'; function getJson (url)&#123; var flag = url.indexOf('?')+1; console.log(flag); var res = url.slice(flag); console.log(res); var arr = res.split('&amp;'); var Json = &#123;&#125;; for(var i = 0 ; i &lt;arr.length ;i++)&#123; var temp = arr[i].split('='); console.log(temp); console.log(temp[0]); console.log(temp[1]); Json[temp[0]] = temp[1]; &#125; return Json ; &#125; getJson(url); console.log(getJson(url)); 3 运算符的操作，主要是 + ++ - &amp;&amp; || 以及运算符的优先级的问题(感兴趣可以看看我这篇总结) 这里在回顾一下 + 运算符 如果一个运算数是字符串，那么这个运算环境就是字符串环境，另外一个运算数，不论是布尔类型，数字类型，undefined null NaN 以及数组，对象都会转化为字符串，然后进行字符串拼接 如果一个运算数是数字，另外一个运算数是布尔类型，会将布尔类型转化为数字 如果一个运算数是数组或者对象，会将数组或者对象转化为原始数据类型(调用toString方法)，然后进行运算(一般也就是将数组或者对象转化为字符串，所以后续也是进行的字符串的拼接) - 运算符 -运算符提供的是一个数字运行环境，会将字符串，布尔类型的值转化为数字(Number和parseInt方法)，如果转化失败则返回NaN 如果有运算数是对象或者数组，会先调用对象或者数组的toString方法，然后调用Number和parseInt方法转化为数字，进行数字的运算，如果转化失败则返回NaN 123456789101112console.log(true + false);//1console.log(&#123;&#125;+true);//[object Object]trueconsole.log([]+true);//trueconsole.log(true + []);//trueconsole.log(1 + [] + 1 );//11console.log(typeof(1 + []));//stringconsole.log([].valueOf());//[]console.log([] - true);//-1console.log(&#123;&#125; - true);//NaNconsole.log(1 - [] - 1 );//0console.log('2' - false);//2console.log("2" - undefined);//NaN 4 有关闭包的一个测试 如何实现点击每个 li 输出其 index 值，注册事件之后，触发事件，然后事件监听器函数就会执行 12345&lt;ul id = 'test'&gt; &lt;li&gt;ee&lt;/li&gt; &lt;li&gt;ee&lt;/li&gt; &lt;li&gt;ee&lt;/li&gt;&lt;/ul&gt; 12345678var liObj = document.getElementById('test').children;console.log(liObj);for(var i = 0 ; i &lt; liObj.length ; i++)&#123; liObj[i].onclick = function()&#123; console.log(i); &#125;&#125;//这个是不行的 注册事件之后，当点击的时候，i的值已经是 3 的，所以每次输出都是3 利用闭包 返回一个函数作为listener 1234567for(var i = 0 ; i &lt; liObj.length ; i++)&#123; liObj[i].onclick = (function(n)&#123; return function()&#123; console.log(n); &#125; &#125;)(i+1)&#125; 还有一个简单的实现思路就是 给每一个li设置一个属性即可 1234567for(var i = 0 ; i &lt; liObj.length ; i++)&#123; liObj[i].setAttribute('index',i+1); liObj[i].onclick = function()&#123; console.log(this); console.log(this.getAttribute('index')); &#125;&#125; 5 类数组转化为数组 apply，call 第一个参数改变函数的this指向,第二个参数表示传入函数的参数 12345678var arrayLike = &#123; 0 : "hai", 1 : "Jhon", 2 : "nam", length : 3&#125;var ret = Array.prototype.slice.call(arrayLike,0);console.log(ret); 6 数组的去重 12345678910111213141516171819var arr = [1,2,3,4,5,5,3,1,8,9];Array.prototype.unique = function()&#123; var arr = [this[0]]; for(var i = 0 ; i &lt; this.length ; i++)&#123; //如果新数组中没有当前比较项，则将当前比较项加入新数组 var flag = true ; for(var j = 0 ; j &lt; arr.length ; j++)&#123; if(this[i] === arr[j])&#123; flag = false; break ; &#125; &#125; if(flag == true)&#123; arr.push(this[i]); &#125; &#125; return arr ;&#125;console.log(arr.unique()); 7 字符串的去重 1234567891011121314151617181920212223242526Array.prototype.unique = function()&#123; var arr = [this[0]]; for(var i = 0 ; i &lt; this.length ; i++)&#123; //如果新数组中没有当前比较项，则将当前比较项加入新数组 var flag = true ; for(var j = 0 ; j &lt; arr.length ; j++)&#123; if(this[i] === arr[j])&#123; flag = false; break ; &#125; &#125; if(flag == true)&#123; arr.push(this[i]); &#125; &#125; return arr ;&#125;var str = 'aaasdafafaasdddfggh';function detRep(str)&#123; var arr = str.split(''); var newArr = arr.unique(); var newStr = newArr.join(''); return newStr ;&#125;console.log(detRep(str)); 8 break和continue 123456789//break会直接跳出循环var iNum = 0;for (var i=1; i&lt;10; i++) &#123; if (i % 5 == 0) &#123; break; &#125; iNum++;&#125;alert(iNum);//4 123456789//continue会退出当前这一次的循环，进行下一次循环，后面表达式都不会在执行var iNum = 0;for (var i=1; i&lt;10; i++) &#123; if (i % 5 == 0) &#123; continue; &#125; iNum++;&#125;alert(iNum);//8 9 + - 运算符以及NaN undefined 123456789var a;//undefined var b = a * 0;//NaNconsole.log(b * 2 + "2" - 0 + 4);if (b == b) &#123; //false console.log(b * 2 + "2" - 0 + 4);&#125; else &#123; console.log(!b * 2 + "2" - 0 + 4);&#125;//输出26 主要考察以下知识点 带有undefined的基本运算结果返回NaN ： undefined*2 undefined+2等 带有NaN的比较运算符结果返回false; NaN == NaN 也是false x 和+ 运算中数字和布尔类型的运算，会将布尔类型转化为数字在进行运算 !b*2 = 2 带有字符串的 + 性环境中，会将另外一个运算数转化为字符串，然后进行字符串的拼接 !b*2+’2’ : ‘22’; - 性环境中，会将字符串，如果一个是字符串，另外一个是数字会将字符串转化为数字(即使两个都是字符串也会将两个都转化为字符串) ‘22’-0 : 22 数字类型的22 如果没有 - 0 这步运算，那么返回的结果将是 字符串 ‘224’; 10 日期操作 1234567891011121314//假设今天是 2017-4-12var date = new Date();console.log(date.getFullYear());//2017console.log(date.getMonth());//3 注意Month获取的月份是从0开始的console.log(date.getDate());//12var year = date.getFullYear();var Month = date.getMonth()+1 ;var day = date.getDate();Month = Month &lt; 10 ? '0'+Month : Month ;day = day &lt; 10 ? '0'+day : day ;var res = year + '-'+ Month + '-'+day;console.log(res); 11 实时获取页面中的元素 1234567891011121314151617&lt;ul&gt; &lt;li&gt;Item&lt;/li&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;Item&lt;/li&gt; &lt;li&gt;Item&lt;/li&gt;&lt;/ul&gt;&lt;script&gt; var items = document.getElementsByTagName('li'); for(var i = 0; i &lt; items.length; i++)&#123; if(items[i].innerHTML == '1')&#123; console.log(i); items[i].parentNode.removeChild(items[i]); console.dir(items);//items已经剩下四个了而此时的索引值并没有改变 &#125; &#125;&lt;/script&gt; 执行后 1234Item1ItemItem 这里需要注意的一点是 DOM获取的元素 items是实时更新的； 12 变量声明提升 函数声明优先于变量声明 1234console.log(a);//是一个函数var a = 3;function a()&#123;&#125;console.log(a);////3]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[live for life ? or live to life]]></title>
      <url>%2F2017%2F03%2F25%2Flive%20or%20life%2F</url>
      <content type="text"><![CDATA[life or live ?1 有时候，为了生活或者更好的生活，为了父母可以有个安稳的、健康的晚年，为了未来的家庭可以安稳，自己总要去经历很多，孤军奋战，默默地去努力，去奋斗. ​ 时光就是像沙漏，它溜走的速度超过你的想象，在北京漂泊总是回想过去的日子，有人陪你玩，有人陪你笑 ​ 很多人说，孤独吗？那就对了，孤独就是你成长的时候； ​ 也有很多人说，能承受多大的委屈和孤独，就能撑起多大的梦想和责任； 其实我觉得，幸福感才是最重要的，一个人的幸福感来自于他对于生活节奏的把控，对于时间管理的合理化；如果感到了孤独，那就联络下朋友，新朋友，老朋友都可以；如果感到委屈了，那就去努力去忘掉那些委屈，没有谁的生活是不委屈的，没有背景，没有依赖，那就得靠自己； 2 很多人知道马云那句:梦想还是要有的，万一实现了呢？ 我觉得 梦想可以有， 无论能不能实现，不放弃，不浮躁，埋下它的种子， 实现了则为它喝彩， 不实现，至少我们曾经为了它真正的战斗过； 坚持一下下，阳光总会来的； 3 毕业转眼两年了，对于市面上的各种鸡汤从来不感冒，一直觉得一个人的强大不在于外在的力量驱使，也不在于别人的鼓励和支持，一个人真正的强大来自于过去所有的时间的打磨和沉淀，或者说，一个人的不强大来自于过去所有的时间的打磨和沉淀； 愿我们每个正值青春奋斗的年纪的各位，走在路上，并且健康、积极的走在路上，成为自己想要成为的人，过自己想要的生活。 4 一个人要有自己的爱好，对于我来说，音乐和篮球是我爱好的主战场，有了它们，确实会让我感到平静许多；每次触摸到篮球，我就会感到充实和快乐；浮躁的时候听一些自己喜欢的音乐，会让自己安静下来。 有爱好的人是幸福的，它会让我们感到存在。 5 最近一段时间确实感到很累，记一笔吧。 ​ 2017.3.20 12:48 继续学习，一点点啃掉各个技术难点。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[NodeJs中的path路径浅析]]></title>
      <url>%2F2017%2F01%2F17%2F168NodeJs%E4%B8%AD%E7%9A%84path%E8%B7%AF%E5%BE%84%E6%B5%85%E6%9E%90%2F</url>
      <content type="text"><![CDATA[1 node 服务器端 文件路径的相关问题首先来看下基础概念 node提供了两个全局变量 _ filename (表示当前文件的绝对根路径) 和 _dirname (表示当前文件所在目录的绝对根路径) 先来看下测试代码的目录结构 1234567F : -workspace -app -hero-admin -common.js -path -a.js common.js 1console.log('this is some data from hero-admin') a.js 123456var path = require('path');console.log('path__dirname=='+ __dirname);console.log('path.process==' + __filename);console.log('process.cwd=='+process.cwd());console.log('path.resolve=='+path.resolve('./')); 第一种情况，在path目录下 执行命令 node a.js 在node 终端输出结果如下 1234//path__dirname==F:\workspace\app\path//path.process==F:\workspace\app\path\a.js//process.cwd==F:\workspace\app\path//path.resolve==F:\workspace\app\path 第二种情况，在 app 目录下 执行命令 node path/a.js 1234//path__dirname==F:\workspace\app\path//path.process==F:\workspace\app\path\a.js//process.cwd==F:\workspace\app//path.resolve==F:\workspace\app 通过上面的代码演示，我们可以发现， dirname 和 filename 的值是 和node命令执行的时候所在的目录没有关系的，无论我们在哪个目录执行 a.js 文件 dirnam 和 filename的值 永远都是返回 a.js 该文件所属目录的绝对路径(相对于根目录)，这个特性记住，下面会有应用。 2 对于一般文件的引用的路径，会受到启动nodejs终端不同路径的影响接下来我们改变下a.js文件的内容 1234567var fs = require('fs');fs.readFile('../hero-admin/common.js','utf-8',function(err,data)&#123; if(err) return console.log(err); console.log(data);&#125;) 2.1 此时我们在path目录下运行 node a.js 可以得到common.js里面的内容 2.2 如果我们改在 app 目录下运行 node path/a.js 此时会抛出错误，找不到文件路径 12345678&#123; Error: ENOENT: no such file or directory, open 'F:\workspace\hero-admin\common.js' at Error (native) errno: -4058, code: 'ENOENT', syscall: 'open', path: 'F:\\workspace\\hero-admin\\common.js' //可以看到此时请求的路径 ../hero-admin/common.js 是相对于 app 目录而言的&#125; 如果我们改下readFile的请求路径 还在app 目录下运行 node path/a.js 123456var fs = require('fs');//相对于app当前目录，此时就可以得打文件的内容fs.readFile('./hero-admin/common.js','utf-8',function(err,data)&#123; if(err) return console.log(err); console.log(data);&#125;) 根据以上，我们可以得出结论 ./ 和 ../ 是相对于启动服务器所在路径为基准的，而不是被启动的文件所在的路径为基准 这个是我们需要注意的一点，node中的文件的路径都是相对于启动node终端的那个目录为基准的，重要事情说两遍 同样包括如果我们引入的模块中也有相对路径的引用，此时，引用的模块中的路径还是相对于启动node终端的那个目录为基准的，重要事情说三遍 当然以上仅仅指的是文件的路径引用，会受到node启用终端的位置不同而受到影响，但是定义的模块不会受node终端启用的影响，这个稍后会有demo解释 2.3 / 代表服务器所在磁盘的根目录 修改readFile请求的路径 还在app 目录下运行 node path/a.js 12345var fs = require('fs');fs.readFile('/hero-admin/common.js','utf-8',function(err,data)&#123; if(err) return console.log(err); console.log(data);&#125;) 12345678&#123; Error: ENOENT: no such file or directory, open 'F:\hero-admin\common.js' at Error (native) errno: -4058, code: 'ENOENT', syscall: 'open', path: 'F:\\hero-admin\\common.js' //可以看到服务器去F盘根目录去寻找这个文件了&#125; 2.4 但是我们在实际开发中总是避免不了对文件的路径的改变和移动，使得我们的项目结构更加清晰，或者说启动服务器位置不同，这个时候对于文件的相对路径问题如何解决？ 还是以上目录结构 a.js 文件如下 123456789var path = require('path');console.log(__dirname);console.log(path.join(__dirname,'../02hero-admin/common.js'));var fs = require('fs');fs.readFile(path.join(__dirname,'../02hero-admin/common.js'),'utf-8',function(err,data)&#123; if(err) return console.log(err); console.log(data);&#125;) 我们在path目录下执行 node a.js 和我们在app目录下执行 node path/a.js 输出的结果都是一样的 123F:\workspace\app\pathF:\workspace\app\hero-admin\common.jsconsole.log('this is some data from lib') 由此可见，我们可以利用 __dirname不受启动服务其所在路径的影响的这个特性，使用绝对路径来动态读取文件内容, 这个时候无论我们在任何位置启用a.js文件，路径问题就不在有了 3 对于模块的的引用的路径，不会受到启动nodejs终端的不同路径影响我们队目录结构稍微做一下修改 12345678F : -workspace -app -hero-admin -common.js -myModule.js -path -a.js myModule.js 我们就简单的返回一个对象 1module.exports = &#123;name:"Jhon",age:14&#125;; a.js 12var ret = require('../02hero-admin/myModule');console.log(ret); 这个时候，无论我们是在任何目录启动node终端执行 a.js 都可以引用到myModule.js这个模块 也就是说模块的引用永远都是相对于a.js文件的，而文件的引用却是相对于启用node终端的路径 path目录下执行 node a.js 以及 app目录下执行 node path/a.js 终端输出如下 1&#123; name: &apos;Jhon&apos;, age: 14 &#125; 4 平常我们在部署项目的时候，路径的引用问题是一个令人头疼的问题，不过最基本的原理搞明白了，问题还是可以迎刃而解的。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[the difference between null and undefined]]></title>
      <url>%2F2017%2F01%2F15%2F94-apply%20%20call%20%20bind%20%E5%AF%B9%E6%AF%94%E5%88%86%E6%9E%90%2F</url>
      <content type="text"><![CDATA[##apply call bind 对比分析 1 基本语法,第一个参数必须传入一个对象12345fun.bind(thisArg[, arg1[, arg2[, ...]]])fun.call(thisArg[, arg1[, arg2[, ...]]])fun.apply(thisArg[, argsArray])//bind call apply可以改变原来的 fn 函数以 thisarg为对象进行执行//第一个参数是代表fun函数执行的this指向 2 三者之间的区别2.1 bind只绑定方法执行的对象，并不执行方法，改变的是函数的this指向；根据bind的这个特性，经常会结合setTimeout执行 2.2 call apply绑定方法的执行对象的同时，也会直接执行方法； 2.2.1 fun.apply(thisArg[, argsArray]) thisArg在 fun 函数运行时指定的 this 值。需要注意的是，指定的 this 值并不一定是该函数执行时真正的 this 值，如果这个函数处于非严格模式下，则指定为 null 或 undefined 时会自动指向全局对象（浏览器中就是window对象），同时值为原始值（数字，字符串，布尔值）的 this 会指向该原始值的自动包装对象。argsArray一个数组或者类数组 对象，其中的数组元素将作为单独的参数传给 fun 函数 。如果该参数的值为null 或 undefined，则表示不需要传入任何参数。从ECMAScript 5 开始可以使用类数组对象。浏览器兼容性请参阅本文底部内容。 同时除了可以传入一个数组，也可以传入arguments,代表当前函数的参数的一个类数组 如果 argsArray 不是一个有效的数组或者不是 arguments 对象，那么将导致一个 TypeError。如果没有提供 argsArray 和 thisArg 任何一个参数，那么 Global 对象将被用作 thisArg， 并且无法被传递任何参数。 2.2.2 fun.call(thisArg[, arg1[, arg2[, …]]]) 如果thisArg指定为null和undefined的this值会自动指向全局对象(浏览器中就是window对象)，同时值为原始值(数字，字符串，布尔值)的this会指向该原始值的自动包装对象。 2.3 主要改变函数体执行的时候，函数体内this的指向； 123456789101112131415&lt;script&gt; var name = "Jhon" function getName ()&#123; console.log(this.name) &#125; var obj = &#123; name:"JiM" &#125; getName();//Jhon getName.apply(obj);//JiM getName.call(obj);//JiM getName.bind(obj);//不会执行getName函数 getName.bind(obj)(); //JiM&lt;/script&gt; 2.3 call方法传入的参数是参数列表形式的，apply传入的参数必须是数组 形式的 apply参数数组化的应用场景：求数组最值 123456 var arr= [1,2,3,4,5,777]// var max = Math.max.apply(null,arr);//777 var max = Math.max.call(null,arr);//NaN // var max = Math.max(arr) ; //NaN console.log(max);// 这是apply方法的特性，apply方法第二个参数为参数的数组，虽然我们传入的是数组参数apply会将一个数组转化为一个参数接一个参数的传递给方法。但是call并不会 如何将一个数组追加到另外一个数组呢？ 1234var arr1 = [1,2,3];var arr2 = [4,5,6];var arr3 = arr1.concat(arr2);//是的，这种方法可以，但是问题是concat方法并不会改变原来的数组，而是会返回一个新的元素 或者你也会这么做 1234567var arr1 = [1,2,3];var arr2 = [4,5,6];//arr1.push(arr2)//这么做是不行的,push会将arr2整体添加到arr1中for(var i = 0 ; i &lt; arr2.length;i++)&#123; arr1.push(arr2[i]);&#125;//这么做也可以，通过循环，但是挺麻烦 看看apply参数数组化的优势 apply会将数组拆分，将每个元素传入调用的函数push 12345 var arr1 = [1,2,3]; var arr2 = [4,5,6]; arr1.push.apply(arr1,arr2) //apply起了决定性的作用，将传入的数组或者类数组中的参数一个个的分开 // arr1.push(arr2) //这么做不行，直接将arr2整体添加给了arr1 console.dir(arr1); 如何将一个 类数组对象 添加到另外一个 对象 呢？ 12345678910var arrLike = &#123; 0:"name", 1:"age", 2:"address", length:3 //如果将类数组作为apply的参数传入(因为apply第二个参数必须是数组)，类数组必须有length属性,如果没有该属性，那么类数组中的值不会被push进去; &#125; var obj = &#123; &#125;; Array.prototype.push.apply(obj,arrLike); //关键还是apply方法会将传入的类数组元素一个个传递给push，然后push方法就可以将所有的元素以单独的形式添加给obj console.dir(obj); 下面代码可以看下，看下apply的参数对于数组以及类数组的要求 12345678910111213 var obj1 = &#123; name:"Jhon", age:13, address:"American", 1:"JiM", other:&#123; gender:"man" &#125;,// length:4 &#125; var obj2 = &#123;&#125;; Array.prototype.push.apply(obj2,obj1) console.dir(obj2); apply操作DOM元素 NodeList类数组 123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang="en"&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;script&gt; var divs = document.querySelectorAll("div"); console.dir(divs);//这是一个类数组 console.dir(divs[0]); var obj = &#123;&#125;; Array.prototype.push.apply(obj,divs);//push+obj+apply可以将DOM NodeList转化为对象 console.dir(obj); console.dir(obj[0]);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; bind 1234567891011121314151617181920212223function bind(fn, obj) &#123; return function() &#123; return fn.apply(obj, arguments); &#125;&#125;var obj = &#123; a: 20, getA: function() &#123; setTimeout(bind(function() &#123; console.log(this.a) &#125;, this), 1000) &#125;&#125;obj.getA();//---------------------------------var obj = &#123; a: 20, getA: function() &#123; setTimeout(function() &#123; console.log(this.a) &#125;.bind(this), 1000) &#125;&#125; 3 this的指向123456789101112131415161718//1 非严格模式下，this默认指向全局对象，call/apply显式指定this参数时也会强制转换参数为对象（如果不是对象）。其中，null/undefined被替换为全局对象，基础类型被转换为包装对象。 function nsm() &#123;console.log(this);&#125; nsm(); // Window&#123;top: xxxx&#125; nsm.call(null/undefined); // Window&#123;top: xxxx&#125; nsm.call(1); // Number &#123;[[PrimitiveValue]]: 1&#125; nsm.call('str'); // String &#123;0: "s", 1: "t", 2: "r", length: 3, [[PrimitiveValue]]: "str"&#125; nsm.call(true); // Boolean &#123;[[PrimitiveValue]]: true&#125;//----------------------------------------------------------------------------------------//2 严格模式下，this默认为undefined，且call/apply显式指定this参数时也不会有强制转换 function sm() &#123;'use strict'; console.log(this);&#125; sm(); // undefined sm.call(null); // null sm.call(undefined); // undefined sm.call(1); // 1 sm.call('str'); // str sm.call(true); // true]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[NodeJs Event]]></title>
      <url>%2F2017%2F01%2F15%2F128NodeJsEvent%2F</url>
      <content type="text"><![CDATA[1 events事件 123//引入events模块并创建eventEmitter对象var events = require('events');var eventEmitter = new events.EventEmitter(); 12//声明事件函数var eventNameHandle = function eventName()&#123;&#125; 123//绑定事件处理程序，并触发执行eventEmitter.on('eventName',eventNameHandle);eventEmitter.emit('eventName'); 2 我们可以输出 events 模块 console.log(events); 查看其所包含内容 events模块只提供了一个对象: events.EventEmitter .该对象的核心就是事件的触发和事件的监听的整体封装； events.EventEmitter 对象提供了多个属性，比如on可以绑定事件 emit用于触发事件,当事件触发的时候，注册到这个事件的监听器会被依次调用，事件参数作为回调函数参数传递； on(event,listener) emit(event,arg1,arg2,····) 1234567891011121314var events = require('events');var eventsEmitter = new events.EventEmitter();eventsEmitter.on("eventName",function(arg1,arg2)&#123; console.log("listener1",arg1,arg2);&#125;);eventsEmitter.on("eventName",function(arg1,arg2)&#123; console.log("listener2",arg1,arg2);&#125;);//以下给同一个事件注册了两个监听器eventsEmitter.on("anotherName",function(arg1,arg2)&#123; console.log("listener3",arg1,arg2);&#125;);eventsEmitter.emit('eventName','argone','argtwo');//eventsEmitter.emit('anothertName','argone','argtwo'); once(event,listener) 为指定事件注册一个单次监听器，即监听器最多只能触发一次，触发之后马上解绑 12345678var events = require('events');var eventsEmitter = new events.EventEmitter();eventsEmitter.once("name1",function(arg1,arg2)&#123; console.log("listener4",arg1,arg2);&#125;);eventsEmitter.emit('name1','argone','argtwo');eventsEmitter.emit('name1','argone','argtwo');//在node终端执行的时候，即使emit了两次，该事件监听器也只执行一次，而on绑定的事件可以多次执行 addListener(event,listener) 给指定事件添加一个事件监听器，到监听器数组的尾部 removeListener(event,listener) 删除指定事件的listener，此操作会影响处于被删监听器之后的那些监听器的索引 listenerCount(emmit,listener) emmit是 new events.EventEmitter()对象，所有的事件都是通过该对象进行绑定，触发等操作。该方法可以返回指定事件的监听器数量 listeners(event) 该方法返回某个事件上的监听器所组成的数组 12345678910111213141516171819var events = require('events');var emmit = new events.EventEmitter();function listener1 ()&#123; console.log("this is listernr1");&#125;function listener2()&#123; console.log("this is listener2");&#125;emmit.on('event1',listener1);emmit.on('event1',listener2);//给event1注册两个监听器，listenerConut可以得到该事件的监听器数量//let count = emmit.listenerCount(emmit,'event1');let count = require('events').EventEmitter.listenerCount(emmit,'event1');console.log(count);//2console.log(emmit.listeners('event1'));//[ [Function: listener1], [Function: listener2] ]emmit.emit('event1');emmit.removeListener('event1',listener1);emmit.on('event1',listener1);//这个监听事件被移除，不会再次被触发]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[NodeJsFileSystem WriteFileAndReadFile]]></title>
      <url>%2F2017%2F01%2F08%2F131NodeJsFS%2F</url>
      <content type="text"><![CDATA[FileSystem文件 I/O 是由简单封装的标准 POSIX 函数提供的。 通过 require(‘fs’)使用该模块。 所有的方法都有异步和同步的形式。 异步形式始终以完成回调作为它最后一个参数。 传给完成回调的参数取决于具体方法，但第一个参数总是留给异常。 如果操作成功完成，则第一个参数会是 null或 undefined，如果操作失败，则第一个参数将是一个错误对象； 需要注意一点，异步操作无法通过try-catch来捕获异常 当使用同步形式时，任何异常都会被立即抛出。 可以使用 try/catch 来处理异常，或让它们往上冒泡。 nodejs fs1 读取文件操作readFile(file,options,callback) file是要读取的文件的路径 options encoding | null //默认值是null,所以如果不指定编码方式，读取文件的结果默认返回的值是二进制数据,返回的结果会作为参数传递给callback回调函数 flag 默认是 ‘r’ callback 回调函数又有两个参数，第一个参数是error对象，第二个参数是读取到的数据 如果读取文件成功，err返回null data返回读取到的文件数据;(如果字符编码未指定，则返回原始的buffer数据) 如果读取文件失败，err返回一个错误对象，data返回undefined; 注意读取文件的内容返回的结果要么是Buffer类型的数据，要么是字符串类型的数据 123456789101112131415//创建文件读取对象var fs = require('fs');fs.readFile('input.txt',function(err,data)&#123; //假如input.txt里面的内容是 hello world console.log(arguments);//我们可以打印出来回调函数的参数进行查看，即使文件读取失败，回调函数也会执行 console.log(err); console.log(data);//readFile返回的data数据是buffer类型的数据 if(err)&#123; console.log(err.stack); &#125; console.log(data.toString());//需要调用toString方法转化为字符串&#125;);console.log("program is done");//program is done//hello world //程序无阻塞运行 123456//readFile语法fs.readFile('etc/passwd',(err,data)=&gt;&#123; if(err) throw err; //使用箭头函数可以使代码更加简洁 console.log(data);&#125;);//readFile用于异步读取文件内容， 2 写入文件的操作writeFile(file,data,[option],callback) file可以是文件名或者文件描述 data是异步地写入的数据内容，可以是一个string或者buffer option 编码格式，如果data是一个buffer,则默认encoding是utf-8 callback 回调函数,该回调函数里面只有一个参数就是err错误处理对象，如果写入成功err返回null 看下面这个简单的例子 12345678910var fs = require('fs');fs.writeFile('../write.txtf','hello nodejs',function(err)&#123; console.log(arguments); if (err)&#123; return console.log("写入文件失败") &#125; console.log("写入文件成功");&#125;);console.log("pro is done"); 需要注意的是，我们只能写入字符串或者Buffer类型的数据，如果写入复杂数据类型 12345fs.writeFileSync('./text',' sync write'); // 写入文件的内容是 sync write fs.writeFileSync('./text.txt',&#123;name:"Jhon"&#125;);//写入文件的内容是[object Object]fs.writeFileSync('./text.txt',function()&#123;&#125;);//写入文件的内容是 function()&#123;&#125; fs.writeFileSync('./text.txt',[1,2,3]); //写入文件的内容是 1,2,3fs.writeFileSync('./text.txt',1);//写入文件的内容是 1 3 以上文件的读写都是异步进行的，不会阻塞程序的执行，同时我们在日常工作中通过服务器端的数据的读写也会经常用到这两个API 4 对于异步 的任务，很多时候，每个任务的执行先后顺序是无法控制的，那么如何去解决这个问题？ 此时，如果需要异步任务按照我们的意愿顺序进行，那么则需要将形成异步嵌套，形成一个回调链]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[NodeJs 事件驱动]]></title>
      <url>%2F2016%2F12%2F28%2F167NodeJs%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%2F</url>
      <content type="text"><![CDATA[1 在了解nodejs的事件驱动模型的时候，先来看下传统线程网络模型1.1 传统线程网络模型 发起请求，请求进入web服务器(IIS、Apache)之后,会在线程池中分配一个线程来线性同步完成请求处理，直到请求处理完成并发出响应,结束之后线程池回收。 这就会就会带来以下几个问题 : 由于线程池中线程个数有限,对于频繁请求时,就会出现等待,严重的甚至会把服务器挂掉 同时线程的增多也会占用大量的 CPU 时间来处理内存上下文切换， 而且还容易遭受低速连接攻击 对于高并发的时候,为了防止出现脏数据就会使用锁来解决,一些I/O事务可能消耗很长得时间,这样就会出现一些线程等待,效率低下 1.2 Node.Js使用事件驱动模型 当web server接收到请求，就把它关闭然后进行处理，然后去服务下一个web请求。当这个请求完成，它被放回处理队列，当到达队列开头，这个结果被返回给用户。这个模型非常高效可扩展性非常强，因为webserver一直接受请求而不等待任何读写操作。（这也被称之为非阻塞式IO或者事件驱动IO） Node.js 的异步机制是基于事件的，所有的 磁盘 I/O 、 网络通信、 数据库查询 客户端的请求 都以非阻塞的方式请求，返回的结果由事件循环来处理。如图 描述了这个机制。Node.js 进程在同一时刻只会处理一个事件，完成后立即进入事件循环检查并处理后面的事件。这样做的好处是CPU 和内存在同一时间集中处理一件事，同时尽可能让耗时的 I/O 操作并行执行 Nodejs事假驱动机制是通过Nodejs内部通过 单线程高效率地 维护事件队列来实现的，没有多线程的资源占用和频繁的上下文切换 像Java、Python这个可以具有多线程的语言。多线程同步模式是这样的，将cpu分成几个线程，每个线程同步运行。 而node.js采用单线程异步非阻塞模式，也就是说每一个计算独占cpu，遇到I/O请求不阻塞后面的计算，当I/O完成后，以事件的方式通知，继续执行计算 1.3 同步与异步 同步和异步关注的是消息通信机制 (synchronous communication/ asynchronous communication) 所谓同步，就是在发出一个调用之后，在没有得到结果，该调用就不会返回；得到返回值之后，该调用返回 所谓异步，就是在发出一个调用之后，直接返回该调用，所以没有返回结果；也就是说当一个异步调用发出后，调用者不会立刻得到结果，而是在调用发出后，被调用者通过状态的变化通知调用者，或者通过回调函数处理这个调用 举个通俗的例子：你打电话问书店老板有没有《分布式系统》这本书，如果是同步通信机制，书店老板会说，你稍等，”我查一下”，然后开始查啊查，等查好了（可能是5秒，也可能是一天）告诉你结果（返回结果）。而异步通信机制，书店老板直接告诉你我查一下啊，查好了打电话给你，然后直接挂电话了（不返回结果）。然后查好了，他会主动打电话给你。在这里老板通过“回电”这种方式来回调。 异步操作的时候回调函数的第一个参数通常是上一步传入的错误对象，异步操作不能使用try-catch捕获异常，因为在回调函数运行的时候，上一步的操作早就结束了，错误的栈也已经不存在了，所以只能将错误数据传递给回调函数进行处理 1.4 阻塞与非阻塞 常见I/O阻塞 磁盘读取 、 网络通信、 数据库查询 客户端的请求 阻塞和非阻塞关注的是程序在等待调用结果（消息，返回值）时的状态. 阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。 非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。 还是上面的例子，你打电话问书店老板有没有《分布式系统》这本书，你如果是阻塞式调用，你会一直把自己“挂起”，直到得到这本书有没有的结果，如果是非阻塞式调用，你不管老板有没有告诉你，你自己先一边去玩了，当然你也要偶尔过几分钟check一下老板有没有返回结果。在这里阻塞与非阻塞与是否同步异步无关。跟老板通过什么方式回答你结果无关。 1.5 线程和进程 多线程单进程 多线程的 设计之初就是为了在共享的内存程序空间中，实现并行 处理任务，从而达到充分利用CPU的效果。多线程的缺点就是在于执行的时候上下文的切换开销比较大，使得程序的编写和调用复杂化 单线程多进程 为了避免多线程造成的使用不便的问题，有的语言选择使用单线程保持调用的简单化，采用启动多进程的方式来达到充分利用CPU和提升整体的并行处理能力。它的缺点在于业务逻辑复杂的时候，涉及多个I/O操作的时候，因为业务逻辑不能分布到多个进程之间，事务处理时长要远远大于多线程模式。 2 代码实现，理解上述概念 2.1 阻塞与非阻塞 假如hello.txt 1hello world 以下程序会非阻塞运行，当我们发起一个文件读取操作的时候，不会阻塞js代码的执行，后续的js代码会继续执行，当文件读取完毕之后，会调用回调函数； 1234567891011var fs = require('fs');fs.readFile('hello.txt',function(err,data)&#123; if(err)&#123; console.log(err.stack); return; &#125; console.log(data.toString());&#125;);console.log("pro is don");//pro is don //hello world 以下程序会阻塞运行，当我们发起一个文件读取操作的时候，会阻塞js代码的执行，当文件读取完毕之后，后续的js代码才开始执行 1234567var fs = require("fs");var data = fs.readFileSync('hello.js');console.log(data.toString());console.log("pro is done");//hello world//pro is don 2.2 事件循环线程与事件队列 对于遇到I/O操作，node.js不会停止后面的文件的内容的执行，会继续执行后续代码，然后另外一个线程处理I/O，处理完毕之后，将回调函数放入事件队列等待执行 12345678910111213141516171819var fs = require('fs');console.log("begin");setTimeout(function()&#123; console.log("Timeout1");&#125;,100)fs.readFile('hello.tet',function(err,data)&#123; if(err)&#123; console.log(err.stack); return; &#125; console.log(data.toString());&#125;);setTimeout(function()&#123; console.log("Timeout2");&#125;,0)//即使设置为0，最少也会有5ms的延迟console.log("end"); 输出如下 12345begin end timeout2timeout1helloworld 需要注意的是 setTimeout和readFile的操作，会将回调函数放入事件队列，回调函数执行的顺序取决于文件读取的速度，以及延时任务的时间的大小比较； 通俗来讲，假如文件读取的用了200ms ，那么执行顺序就是上面的输出结果 假如文件读取用了50ms，那么执行顺序就是 12345begin end timeout2helloworldtimeout1 3]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[NodeJs Util]]></title>
      <url>%2F2016%2F12%2F21%2F170NodeJs-Util-net%2F</url>
      <content type="text"><![CDATA[1 Node.js Net 模块提供了一些用于底层的网络通信的小工具，包含了创建服务器/客户端的方法，我们可以通过以下方式引入该模块：1.1 net相关API net.js 文件 12var net = require('net');console.log(net); 执行命令 node net.js 1234567891011121314151617181920&#123; createServer: [Function], createConnection: [Function], connect: [Function], _normalizeConnectArgs: [Function: normalizeConnectArgs], Socket: &#123; [Function: Socket] super_: &#123; [Function: Duplex] super_: [Object] &#125; &#125;, Stream: &#123; [Function: Socket] super_: &#123; [Function: Duplex] super_: [Object] &#125; &#125;, Server: &#123; [Function: Server] super_: &#123; [Function: EventEmitter] EventEmitter: [Circular], usingDomains: false, defaultMaxListeners: [Getter/Setter], init: [Function], listenerCount: [Function] &#125; &#125;, _createServerHandle: [Function: createServerHandle], isIP: [Function: isIP], isIPv4: [Function: isIPv4], isIPv6: [Function: isIPv6], _setSimultaneousAccepts: [Function] &#125; 1.2 net.createServer([options],[ connectionListener])创建一个 TCP 服务器。参数 connectionListener 自动给 ‘connection’ 事件创建监听器。 connection事件会在一个新连接创建后被触发 net.socket对象实的实例现了一个双工流的接口 用户创建客户端(使用 connect())时使用, 由 Node 创建它们，并通过 connection 服务器事件传递给用户。 1.2.1 net.Socket类是 EventEmitter的实例有以下事件 data事件，当接收到数据的时候触发该事件，向该事件的监听器传入 end事件，当socket连接的另一端发出FIN包时被触发，也就是说数据传输完毕的时候触发该事件 2 Nodejs.path模块12345678910111213var path = require("path");// 格式化路径console.log('normalization : ' + path.normalize('/test/test1//2slashes/1slash/tab/..'));// 连接路径,用于根据电脑的不同的操作系统连接路径 console.log('joint path : ' + path.join('/test', 'test1', '2slashes/1slash', 'tab', '..'));// 转换为绝对路径,会解析文件所在路径的绝对路径,如果是服务器就是相对于服务器根目录所在路径,如果是磁盘就是相对于磁盘的根目录console.log('resolve : ' + path.resolve('main.js'));// 路径中文件的后缀名console.log('ext name : ' + path.extname('main.js')); 123456$ node main.js 执行main.js文件 normalization : /test/test1/2slashes/1slashjoint path : /test/test1/2slashes/1slashresolve : /web/com/1427176256_27423/main.jsext name : .js]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ES6-Promise]]></title>
      <url>%2F2016%2F12%2F20%2F190ES6Promise%2F</url>
      <content type="text"><![CDATA[1 Promise定义Promise是一种异步编程的解决方案,是一个对象(构造函数),从该对象可以获取异步操作的消息 Promise对象的特点 （1）对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：Pending（进行中）、Resolved（已完成，又称 Fulfilled）和Rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是Promise这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。 （2）一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从Pending变为Resolved和从Pending变为Rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果。如果改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。 缺点 (1) 首先，无法取消Promise，一旦新建它就会立即执行，无法中途取消。 (2) 当新建promise对象的时候,Promise里面必须传入回调函数,否则内部会抛出错误 1var promise = new Promise() //报错 (3) 当处于Pendding状态的时候,无法确切知道处于哪个阶段的状态 我们可以打印出来看下有什么 123456789console.dir(Promise);//我们可以看到起原型上有 then 和catch等方法// var promise = new Promise(); Promise是一个构造函数,构造函数中必须传入一个函数作为参数,否则会报错var promise = new Promise(function(resolve,reject)&#123; console.log(arguments);// // resolve(); reject();&#125;)console.log(promise); 1234//promise实例上有如下属性 Promise[[PromiseStatus]]:&quot;resolved&quot;[[PromiseValue]]:undefined 2 基本使用 Promise是一个构造函数,该构造函数接受一个函数作为参数(必须的)写在前面,promise对象创建的时候立即执行&gt;同步&gt;异步&gt;回调函数 接受的函数中又有两个函数作为参数, Promise构造函数中必须有一个函数作为构造函数的参数,作为参数的函数的参数有两个函数 一个是resolve函数,在异步操作成功的时候执行该函数,将Pendding状态改变为Resolved 一个是reject函数,在异步操作失败的时候执行该函数,将Pendding状态改变为Rejected 创建promise对象之后,根据异步操作成功与否,调用resolve或者reject函数,改变状态的结果,then方法会根据改变的状态结果调用响应的回调函数,then方法接受两个函数, 第一个函数在Resolved状态的时候执行 第二个函数在Rejected状态的时候执行 基本的实现思路是 123456789var promise = new Promise(function(resolve, reject) &#123; // ... some code if (/* 异步操作成功 */)&#123; resolve(value); &#125; else &#123; reject(error); &#125;&#125;); 12345promise.then(function(value) &#123; // success&#125;, function(error) &#123; // failure&#125;); 如下demo所示 123456789101112131415var promise = new Promise(function(resolve,reject)&#123; console.log('promise对象创建之后立即执行'); // resolve(); // rejecte(); &#125;) console.log('helloWorld'); promise.then(function()&#123; console.log('this is the status of Resolved'); &#125;,function()&#123; console.log('this is the status of Rejected'); &#125;) 当打开resolve()的注释的时候,改变了promise实例的状态,触发then函数中的第一个回调函数的执行 123promise对象创建之后立即执行helloWorldthis is the status of Resolved 当打开reject()的注释的时候,改变了promise实例的状态,触发then函数中的第二个回调函数的执行 123promise对象创建之后立即执行helloWorldthis is the status of Rejected 3 实例化一个Promise对象的时候传入Promise构造函数的参数是一个函数,该函数立即执行内部实现大概是这个样子的,我猜 ; 所以才会有上面的输处顺序 12345678&lt;script&gt; function foo(f1)&#123; f1()&#125;new foo(function()&#123; console.log('f1 is exected');&#125;);&lt;/script&gt; 4 如果 resolve 或者 reject 函数执行的时候有参数,那么参数会传递给then方法中相应的回调函数1234567891011121314&lt;script&gt; var promise = new Promise((resolve,reject)=&gt;&#123; var res = 'RES'; var rej = 'REJ'; resolve(res); reject(rej); &#125;) promise.then(value =&gt; &#123; console.log('这是通过resolve函数传递过来的参数',value); &#125;,value =&gt; &#123;console.log('这是通过reject函数传递过来的参数',value); &#125;)&lt;/script&gt; 另外,一般而言reject函数的参数一般是一个ERROR对象的实例,resolve函数的参数也可能是另外一个Promise对象的实例 先看下面一段代码, 如果promise对象不是另外一个promise对象的resolve函数的参数,那么promise实例 p1 p2的状态互不影响 12345678910111213&lt;script&gt; var p1 = new Promise(function(resolve,reject)&#123; &#125;) var p2 = new Promise(function(resolve,reject)&#123; resolve() ; &#125;) console.log('p1',p1); //p1 Pendding console.log('p2',p2);//p2 Resolved &lt;/script&gt; 但是如果promise实例是另外一个promise对象的resolve的参数的话,那么promise实例将会和resolve参数的promise对象的状态保持一致 12345678910111213&lt;script&gt; var p1 = new Promise(function(resolve,reject)&#123; //此时p1对象的状态是Pendding &#125;) var p2 = new Promise(function(resolve,reject)&#123; resolve(p1) ; //将p1对象作为resolve函数的参数 &#125;) console.log('p1',p1);//p1 Pendding console.log('p2',p2);//p2 Pendding &lt;/script&gt; 改变p1对象的状态 12345678910111213&lt;script&gt; var p1 = new Promise(function(resolve,reject)&#123; resolve();//此时p1对象的状态是Resolved &#125;) var p2 = new Promise(function(resolve,reject)&#123; resolve(p1) ; &#125;) console.log('p1',p1);//p1 Resolved console.log('p2',p2);//p2 Resolved &lt;/script&gt; 1234567891011121314&lt;script&gt; var p1 = new Promise(function(resolve,reject)&#123; // resolve(); reject(); &#125;) var p2 = new Promise(function(resolve,reject)&#123; resolve(p1) ; &#125;) console.log('p1',p1); console.log('p2',p2); &lt;/script&gt; 5 Promise.prototype.then Promise.prototype.catch then方法是定义在Prototype构造函数原型上的一个方法 该方法接受两个函数作为参数 第一个参数函数在promise实例状态变为Resolved的时候会执行 第二个参数函数在promise实例状态变为Rejected的时候会执行 该方法返回值是 另外一个promise对象 catch方法:当一个Promise实例的状态变为Rejected的时候会调用catch方法里面的回调函数 123456789101112&lt;script&gt; var p = new Promise(function(resolve,reject)&#123; resolve() &#125;) var ret = p.then(function()&#123; console.log('this is the status of Resolved'); &#125;) console.log(ret);//Promise对象 &lt;/script&gt; 123456789&lt;script&gt; var p = new Promise((resolve,reject)=&gt;&#123; reject(); &#125;) p.catch(function()&#123; console.log('REJECTED'); &#125;)&lt;/script&gt; 基本使用暂时到此,后期其他方法会有时间更新 =========== 2017/5/11 21:21]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ES6 class]]></title>
      <url>%2F2016%2F12%2F15%2F129ES6class%2F</url>
      <content type="text"><![CDATA[1 class declarations 可以用以下三种方式声明class类，必须先声明在使用；每一个使用class方式定义的类默认都有一个constructor函数， 这个函数是构造函数的主函数， 该函数体内部的this指向生成的实例An important difference between function declarations and class declarations is that function declarations are hoisted(变量提升) and class declarations are not. You first need to declare your class and then access it, 1234567891011121314151617181920var Rect = class Rect &#123; constructor(height,width)&#123; this.height = height ; this.width = width ; &#125; &#125; var Rect = class &#123; constructor(height,width)&#123; this.height = height ; this.width = width ; &#125; &#125; class Rect &#123; constructor(height,width)&#123; this.height = height ; this.width = width ; &#125; &#125; 2 对比ES5和ES6中的差别constructor内定义的方法和属性是实例对象自己的，而constructor外定义的方法和属性则是所有实例对象可以共享的。 2.1 创建类的过程差别 ES5中: 123456789101112131415function RectAngle(height,width)&#123; this.height = height ; this.width = width ;&#125;RectAngle.prototype.getArea = function()&#123; return this.calcArea();&#125;RectAngle.prototype.calcArea = function()&#123; return this.height*this.width;&#125;console.dir(RectAngle) ;//输出下构造函数var rectAngle = new RectAngle(10,10);console.log(rectAngle);console.log(rectAngle.getArea());console.log(rectAngle.__proto__ === Rectangle.prototype); //true ES6中: 12345678910111213141516171819 class Rect &#123; constructor(height,width)&#123; this.height = height ; this.width = width ; &#125; //定义原型方法 类似于ES5中的Rect.prototype.getArea = function()&#123;&#125;; getArea()&#123; return this.calcArea(); &#125; calcArea()&#123; return this.height*this.width ; &#125; &#125;console.dir(Rect) ;const square = new Rect(10,10);console.log(square);console.log(square.getArea());console.log(square.__proto__ === Rect.prototype); //true//class类的prototype属性和其实例化对象的__proto__ 全等,这点和ES5中的构造函数prototype和其实例化对象的__proto__全等一致 2.2 类中的方法独立调用的时候，函数内部this指向不同 ES5中:原型上的方法被独立调用，非严格模式下，this会指向window，严格模式下指向undefined 1234567891011function RectAngle(height,width)&#123; this.height = height ; this.width = width ; &#125; RectAngle.prototype.getArea = function()&#123; return this; &#125; var rectAngle = new RectAngle(10,10); let getArea = rectAngle.getArea; console.log(getArea());//window ES6中: static方法或者原型上的方法被独立调用的时候，无论是否严格模式，其this指向都是undefined 12345678910111213class Rect &#123; constructor(height,width)&#123; this.height = height ; this.width = width ; &#125; //定义原型方法 类似于ES5中的Rect.prototype.getArea = function()&#123;&#125;; getArea()&#123; return this; &#125;&#125;const square = new Rect(10,10);let getArea = square.getArea;console.log(getArea());//undefined 2.3 class类中static声明的方法不能被实例调用，也不会出现在实例化对象上 ; 可以直接通过类名调用； The static keyword defines a static method for a class. Static methods are called without instantiating )their class and cannot be called through a class instance. Static methods are often used to create utility functions for an application. 12345678910111213141516171819class Rect &#123; constructor(height,width)&#123; this.height = height ; this.width = width ; &#125; getArea()&#123; //这个是Rect类的属性prototype上的方法 return this.calcArea(); &#125; calcArea()&#123; return this.height*this.width ; &#125; //静态方法为class类定义了一个方法，该方法不能再class类的实例对象上使用 static shortHBW (H,W)&#123; return H-W ; &#125;&#125;console.log(Rect);//static方法其实就是class类的属性console.log(Rect.shortHBW(21,12) );//9 //static方法直接通过类名可以直接调用console.log(Rect.getArea() ); //prototype method 不能直接通过类名调用 2.4 先来看下extends关键字的作用 class类实现继承的根本原因就是通过extends关键字，将子类的 proto 属性指向父类构造函数 123456789101112131415161718class Animal &#123; constructor(name) &#123; this.name = name; &#125; speak() &#123; console.log(this.name + ' makes a noise.'); &#125;&#125;class Dog &#123; //没有继承的情况下 speak1() &#123; console.log(this.name + ' barks.'); &#125;&#125;console.dir(Dog);console.dir(Animal);console.log(Dog.__proto__ === Animal);//fasle 1234567891011121314151617181920212223class Animal &#123; constructor(name) &#123; this.name = name; &#125; speak() &#123; console.log(this.name + ' makes a noise.'); &#125;&#125;class Dog extends Animal&#123; //extends的作用 是将子类 的__proto__属性指向父类，由此可以实现继承父类所有的属性和方法 speak1() &#123; console.log(this.name + ' barks.'); &#125;&#125;console.dir(Dog);console.dir(Animal);console.log(Dog.__proto__ === Animal);//true 这个是extends关键字的作用核心var dog = new Dog();console.log(dog);console.log(dog.__proto__ === Dog.prototype);//true 实例化的对象的原型属性指向的是构造函数的原型,而构造函数的原型属性指向的是父类构造函数 2.5 constructor 方法，以及super关键字 2.5.1 The constructor method is a special method for creating and initializing an object created with a class； There can only be one special method with the name “constructor” in a class. A SyntaxError will be thrown if the class contains more than one occurrence of a constructor method. A constructor can use the super keyword to call the constructor of a parent class. constructor方法是类的默认方法，通过new命令生成对象实例时，自动调用该方法。一个类必须有constructor方法，如果没有显式定义，一个空的constructor方法会被默认添加。 2.5.2 super有三种作用， 第一是作为构造函数直接调用，第二种是作为父类实例， 第三种是在子类中的静态方法中调用父类的静态方法；super关键字，它指代父类的实例（即父类的this对象）。子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类没有自己的this对象，而是继承父类的this对象，然后对其进行加工。如果不调用super方法，子类就得不到this对象 也可以理解为super指向父类的 prototype属性 123456789101112131415161718192021class Cat &#123; constructor(name,color) &#123; this.name = name; this.color = color; &#125; speak() &#123; console.log(this.name + ' makes a noise.'); &#125;&#125;class Lion extends Cat &#123; constructor(name,color,age)&#123; super(name,color);//第一个作用，作为构造函数直接调用，必须先调用，用来确定子类实例对象的this指向 this.age = age ; &#125; speak() &#123; super.speak();//第二个作用，super 作为父类实例调用父类的方法 console.log(this.name + ' roars.'); &#125;&#125;var lion = new Lion("JErry","white",12);lion.speak(); 2.6 classs类中的 get 和 set 对某个属性设置存值函数和取值函数， 拦截该属性的存取行为 下面这个栗子是对name属性的设置值以及获取值 12345678910111213141516171819class People &#123; constructor(name) &#123; //构造函数 this.name = name; &#125; get name() &#123; return this._name.toUpperCase(); &#125; set name(value) &#123; this._name = value; &#125; sayName() &#123; console.log(this.name); &#125; &#125; var p = new People("tom"); console.log(p); console.log(p.name); //TOM console.log(p._name); //tom p.sayName(); //TOM]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ES6 object 对象新词法]]></title>
      <url>%2F2016%2F12%2F13%2F133ES6Object%E6%96%B0%E8%AF%8D%E6%B3%95%2F</url>
      <content type="text"><![CDATA[ES6 Object 1 对象新词法:允许在声明对象字面量时使用简写语法，来初始化属性变量和函数的定义方法，直接写变量，这时，属性名为变量名, 属性值为变量的值。 1234567891011121314151617181920212223242526 function getPerson(name,age,gender)&#123; return &#123; name, age, gender, sayHello()&#123; console.log('my name is'+this.name); &#125; &#125;; &#125;//等价于 function getPerson(name,age,gender)&#123; return &#123; name: name , age :age , gender: gender, sayHello:function()&#123; console.log('my name is'+this.name); &#125; &#125;; &#125; let p = getPerson("Jhon",18,'man'); console.log(p); p.sayHello();//当然了混合这新词法和以前的定义方式定义对象也是可以的 1234var foo = 'bar';var obj = &#123;foo&#125;;//等价于var obj = &#123;foo:foo&#125;;//变量名:变量值 1.1 ES6 允许在声明对象的时候，对象的属性名可以是表达式，同时方法名也可以是表达式; 123456//javascript语言中定义对象的属性时候有以下两种方式var obj = &#123; &#125; ;//方式一obj.foo = 'bar';//方式二obj['na'+'me'] = "Jhon"; 123456//在ES5中声明对象字面量时，只允许用第一种方式声明属性名，在ES6中允许使用第二种表达式的方式声明属性名//ES5中var obj = &#123;foo:true,abc:123,sayHello:function()&#123;console.log('hello you')&#125;&#125;;//ES6中,对象的属性名可以是表达式var property = 'foo';var obj = &#123;[property]:true,['a'+'ba']:123,['say'+'Hello']()&#123;console.log('hello you')&#125;&#125; 1.2 注意一点，对象的属性名可以是表达式，但是不能和简写语法一起用 12var property = 'foo';var obj = &#123;[property]&#125; ;//会报错 1.3 属性名表达式如果是一个对象的话，默认情况下会转化为对象的字符串表示，属性名会覆盖 1234567const keyA = &#123;a: 1&#125;;const keyB = &#123;b: 2&#125;;const myObject = &#123; [keyA]: 'valueA', [keyB]: 'valueB'&#125;;myObject // Object &#123;[object Object]: "valueB"&#125; 2 对象超类 super,当类继承或者设置了一个对象的原型 proto 的时候，该对象的内使用super的时候，super可以理解为指向该对象的 proto 属性； 12345678910111213141516171819var parent = &#123; foo()&#123; console.log("this is parent"); &#125;&#125;var child = &#123; foo()&#123; super.foo(); console.log("this is child"); &#125;&#125;console.log(parent);console.log(child);Object.setPrototypeOf(child,parent);//改变child对象的 __proto__指向parentchild.foo();//this is parent this is childchild.__proto__.foo();//this is parent]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[PHP base]]></title>
      <url>%2F2016%2F12%2F11%2F64PHP%20%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%EF%BC%9A%2F</url>
      <content type="text"><![CDATA[PHP 基础语法(运行在服务器端的脚本语言) 1 定义变量 $str = “strings” \$num = 4 ; \$Bool = true ; \$float = 4.5;数据类型包括字符串，数值，布尔类型，浮点类型 2 定义数组 $arr = array( ) ,php提供了 array这个函数帮助我们去定义一个数组； $arr = array (2,”hello world”,4) 这是索引数组，可以通过下标进行访问，注意array函数是关键 $arr =array (“name”=&gt;”Jhon”,”age”=&gt;23,”address”=&gt;”china”) 这是关联数组，类似于js的键值对； 4 echo 只能输出简单数据类型; print_r( ):可以输出复杂数据类型,比如数组;var_dump( )可以输出详细的信息，比如数组和对象 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;?phpheader("Content-Type:text/html;charset=utf-8"); $arr = array("name"=&gt;"jhon","age"=&gt;5); /*echo: 可以输出简单数据类型*/// echo array["name"];// echo array["age"]; echo $arr["name"]; echo "&lt;br/&gt;"; echo $arr["age"]; echo "&lt;br/&gt;"; echo $arr; echo "&lt;br/&gt;"; echo "next print";echo "&lt;br/&gt;"; /*print_r()可以输出复杂数据类型*/ print_r($arr["name"]); echo "&lt;br/&gt;"; print_r($arr["age"]); echo "&lt;br/&gt;"; print_r($arr); echo "&lt;br/&gt;"; echo "next dump";echo "&lt;br/&gt;"; /*var_dump()输出详细信息*/ var_dump($arr["name"]); echo "&lt;br/&gt;"; var_dump($arr["age"]); echo "&lt;br/&gt;"; var_dump($arr); echo "&lt;br/&gt;"; ?&gt; //输出结果如下: /*jhon 5 Array next print jhon 5 Array ( [name] =&gt; jhon [age] =&gt; 5 ) next dump string 'jhon' (length=4) int 5 array 'name' =&gt; string 'jhon' (length=4) 'age' =&gt; int 5*/ (对于布尔类型，echo print_r( ) 输出true为1，对于false 则不会输出内容 )123456789101112131415161718&lt;?phpheader("Content-Type:text/html;charset=utf-8"); $flag1 = false ; echo $flag1;//什么都不会输出 print_r( $flag1);//什么都不输出 var_dump($flag1);//boolean false $flag2 = true ; echo $flag2;//1 print_r($flag2);//1 var_dump($flag2);//boolean true $flag3 = 4 ; echo $flag3 ;//4 $flag4 = "hello"; echo $flag4;//hello $arr = array("name","Jhon"); echo $arr;//Array echo &#123;"name":"Jim","age":12&#125;;//直接报错?&gt; 5 php文件和HTML文件的关系，php文件中可以直接写HTML代码，会被解析成相应的标签，但是HTML文件却不能识别php代码,同样如果想在php代码中向页面输出标签，需要用 echo 或者print_r( ) 向页面输出标签; 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; div&#123; width:100px; height:100px; background-color:red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;欢迎&lt;/div&gt; &lt;?php header("Content-Type:text/html;charset=utf-8"); //这个代码是在服务端运行的， //我就可以在这里 从数据库取数据. 输出到页面上面 echo "Jhon"; echo "&lt;P&gt;你好&lt;/p&gt;"; ?&gt;&lt;/body&gt;&lt;/html&gt; 123456 &lt;?php// &lt;div&gt;这个div在php里面&lt;/div&gt; 如果HTMl代码出现在php代码块里面会直接报错 //这个代码是在服务端运行的， //我就可以在这里 从数据库取数据. 输出到页面上面 echo "Jhon"; ?&gt; 6 PHP header()函数 1header(string,replace,http_response_code) 参数 描述 string 必需。规定要发送的报头字符串。 replace 可选。指示该报头是否替换之前的报头，或添加第二个报头。默认是 true（替换）。false（允许相同类型的多个报头）。 http_response_code 可选。把 HTTP 响应代码强制为指定的值。即返回给客户端的数据格式 PHP文件中header的作用，给客户端一个响应头：1)规定文件以什么格式解析；2)charset规定客户端浏览器以什么方式解析编码 对文件编码解析 方式; 3)charset需要设置编码方式 的和文件的自身编码 方式一致，否则浏览器解析将出现乱码；4)Refresh可以服务器给客户端的相应;5)解决乱码问题 服务器到客户端，通过header头进行规定， 123header("Content-Type:text/javascript;charset=utf-8");//php文件将text解析成javascript,返回给浏览器,然后浏览器进行解析；浏览器文件编码解析方式是utf-8 header("Content-Type:text/html;charset=GBK");//php文件将text解析成HTML，返回给浏览器，浏览器以html格式将其解析；浏览器文件编码解析方式是GBK；header("Refresh:5;url=http://m.youyuanwang") 7 数组的方法，在php中没有length属性来获取数组的长度，那么如何获取数组的长度呢？count 方法 123count($arr1) : 求数组arr1的长度 返回整形数值in_array("value",$arr2) : arr2首先得是一个普通数组，可以判断在数组arr2中是否存在value，返回布尔类型值;array_key_exists("vale",$arr3):arr3首先得是一个关联数组，可以判断数组arr3中是否存在value，返回布尔类型值 1234567891011121314151617&lt;?phpheader("Content-Type:text/html;charset=utf-8"); $arr1 = array("name",2,"hello");//定义普通数组 $arr2 = array("name"=&gt;"jhon","age"=&gt;17,"gender"=&gt;"male");//定义关联数组 //求数组的长度，返回数值类型echo "getArrLength";var_dump ( count($arr1) );//int 3var_dump ( count($arr2) );//int 3//求数组中是否存在某一个，返回布尔类型的值,只能用于普通数组echo "getin-array";var_dump (in_array("name",$arr1));// boolean truevar_dump (in_array("name",$arr2) );//boolean false//判断数组中是否存在某个key，返回布尔类型数值,只适用于关联数组echo "array_key_exists";var_dump ( array_key_exists("name",$arr1));//boolean falsevar_dump( array_key_exists("name",$arr2));//boolean true?&gt; 7 表单处理 注释：form 元素是块级元素，其前后会产生折行。 ​ 1)HTML代码 1234表单name属性的是用来提供给服务端接收所传递数据而设置的；表单action属性设置接受数据的处理程序,比如action="progress_form.php"，表示用progress_form.php程序处理form；表单method属性设置发送数据的方式,method="get" method="post",设置数据的上传到后台的的方式；超链接和地址栏默认 method="get" 数据提交方式，如果想要上传文件，必须：form表单设置enctype="multipart/form-data",method="post" ​ 2)PHP代码获取用户上传数据 123$_GET 接受HTML代码部分以get方式的传值，比如超链接，地址栏,form表单设置method="get";$_GET是一个关联数组$_POST 接受HTML代码部分以post方式的传值，比如form表单设置method="post";$_POST 是一个关联数组$_FILES 接受文件上传 ​ 3) \$_POST 客户端向服务器发送请求的时候，发送的信息不会在地址栏显示；变量是一个数组，内容是由 HTTP POST 方法发送的变量名称和值。并且对发送信息的量也没有限制。 例子地址栏 scheme://host.domain:post/pash/filename 123456789101112131415 &lt;form action=&quot;login.php&quot; method=&quot;post&quot;&gt; 昵称: &lt;input type=&quot;text&quot; name=&quot;username&quot;&gt; &lt;br&gt;&lt;br&gt; //假设输入 Jhon 密码：&lt;input type=&quot;password&quot; name=&quot;psw&quot;&gt;&lt;br&gt;&lt;br&gt; //假设输入 123456 &lt;input type=&quot;submit&quot; value=&quot;post提交&quot;&gt; &lt;/form&gt; &lt;?php header(&quot;Content-Type:text/html;charset=utf-8&quot;); //接收数据 var_dump($_POST); //输出$_POST，查看$_POST的详细内容； $username=$_POST[&apos;username&apos;]; $password=$_POST[&apos;password&apos;];?&gt;//$_POST = array(&quot;username&quot;=&gt;&quot;John&quot;,&quot;psw&quot;=&gt;&quot;12345&quot;)，$_POST是一个关联数组，该数组内存放着用户上传的数据//地址栏显示:http://127.0.0.1/02-php/02-get-post/03-loginphp.php//127.0.0.1 这是我的域名 02-php/02-get-post/03-loginphp.php 这是我的电脑服务器处理程序的存储路径 ​ $_GET 客户端向服务器发送请求的时候，发送的数据在地址栏的后面显示出来，\$_GET 变量用于收集来自 method=”get” 的表单中的值。该变量是一个数组，内容是由 HTTP GET 方法发送的变量名称和值。对发送信息量有限制（最多 100 个字符）。 12 &lt;a href="01get.php?username=zhangsan&amp;age=11"&gt;get 方式提交&lt;/a&gt;地址栏显示:http://127.0.0.1/02-php/02-get-post/01-getphp.php?username=zhangsan&amp;age=11 123456789101112131415&lt;form action=&quot;login.php&quot; method=&quot;get&quot;&gt; 昵称: &lt;input type=&quot;text&quot; name=&quot;username&quot;&gt; &lt;br&gt;&lt;br&gt; //假设输入 Jhon 密码：&lt;input type=&quot;password&quot; name=&quot;psw&quot;&gt;&lt;br&gt;&lt;br&gt; //假设输入 123456 &lt;input type=&quot;submit&quot; value=&quot;get提交&quot;&gt; &lt;/form&gt; &lt;?php header(&quot;Content-Type:text/html;charset=utf-8&quot;); //接收数据 var_dump($_GET); //输出$_GET ,查看$_GET的详细内容 $username=$_GET[&apos;username&apos;]; $password=$_GET[&apos;psw&apos;];?&gt;//$_GET = array(&quot;username&quot;=&gt;&quot;John&quot;,&quot;psw&quot;=&gt;&quot;12345&quot;)，$_POST是一个关联数组，该数组内存放着用户上传的数据//地址栏显示:http://127.0.0.1/02-php/02-get-post/03-loginphp.php?username=lupan&amp;psw=123456 ?username=lupan&amp;psw=123456 这是用户上传的数据,get方式上传数据可以直接在地址栏看到 ​ $_FILES input type=”file” \$FILES 将会包含标签的相关信息； 标签的 enctype 属性规定了在提交表单时要使用哪种内容类型。在表单需要二进制数据时，比如文件内容，必须使用“multipart/form-data”。 文件上传form必须 用method=”post”方法，get方法无法上传file数据 form必须 有 enctype=”multipart/form-data 属性，如果没有设置该属性，无法上传数据； input type 类型必须 file; 这三者同时满足了才能 $_FILES才存在 。否则 var_dump(\$_FILES) 结果为 empty; 123456789101112131415161718192021222324&lt;form action=&quot;01-filesupload.php&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot; &gt; &lt;input type=&quot;file&quot; name=&quot;lifephoto&quot;/&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;/&gt;&lt;/form&gt;&lt;?php header(&quot;Content-Type:text/html;charset=utf-8&quot;); var_dump($_FILES); //$_FILES是一个关联数组，(二维数组)/*输出结果如下:array &apos;lifephoto&apos; =&gt; array &apos;name&apos; =&gt; string &apos;DSC_0002.JPG&apos; (length=12) //文件名 &apos;type&apos; =&gt; string &apos;image/jpeg&apos; (length=10) //文件类型 &apos;tmp_name&apos; =&gt; string &apos;D:\wamp\tmp\php3971.tmp&apos; (length=23) //临时存储地址 &apos;error&apos; =&gt; int 0 &apos;size&apos; =&gt; int 1672087*/ $tmp_name = $_FILES[&apos;lifephoto&apos;][&apos;tmp_name&apos;]; $fileName =$_FILES[&apos;lifephoto&apos;][&apos;name&apos;]; $newFile = &apos;./&apos;.time().&apos;.jpg&apos; move_uploaded_file($tmp_name,$newFile);?&gt;//地址栏显示:http://127.0.0.1/02-php/03-files/01-filesupload.php 1move_uploaded_file($tmp_name,"images/".$fileName); 该方法可以用来改变用户上传的文件存储的地址。 8 file_get_contents() 函数把整个文件读入一个字符串 中。 和 file() 一样，不同的是 file_get_contents() 把文件读入一个字符串。 file_get_contents() 函数是用于将文件的内容读入到一个字符串中的首选方法。如果操作系统支持，还会使用内存映射技术来增强性能。 1file_get_contents(path,include_path,context,start,max_length) 参数 描述 path 必需。规定要读取的文件。 include_path 可选。如果也想在 include_path 中搜寻文件的话，可以将该参数设为 “1”。 context 可选。规定文件句柄的环境。context 是一套可以修改流的行为的选项。若使用 null，则忽略。 start 可选。规定在文件中开始读取的位置。该参数是 PHP 5.1 新加的。 max_length 可选。规定读取的字节数。该参数是 PHP 5.1 新加的。 该方法是服务器读取数据的常用方法，然后可以返回数据给到客户端。 注意: php每一行代码的最后必须有分号 “ ; ” ,必须在每一行作为结束; 单引号里面的变量不会被执行，会被当做字符串运行，双引号里面的变量会被执行，可以解析成变量代表的值； echo print_r()可以向页面中输出HTMl代码，但是var_dump()向页面输出的是标签 php里面的字符串拼接用的是 “ . ” 等价于js中的 “ + ”,会将结果转化为字符串； php代码块里面不能出现HTML代码，会报错；]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ES6新特性 箭头函数]]></title>
      <url>%2F2016%2F12%2F07%2F117-ES6%E6%96%B0%E7%89%B9%E6%80%A7%20%20%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%2F</url>
      <content type="text"><![CDATA[ES6新特性 箭头函数12345678910(param1, param2, …, paramN) =&gt; &#123; statements &#125; (param1, param2, …, paramN) =&gt; expression // equivalent to: =&gt; &#123; return expression; &#125; // 如果只有一个参数，圆括号是可选的: (singleParam) =&gt; &#123; statements &#125; singleParam =&gt; &#123; statements &#125; // 无参数的函数需要使用圆括号: () =&gt; &#123; statements &#125; 函数简写: 如果函数值计算一个表达式并返回它的值，那么return和花括号都可以省略，并将待计算的额表达式紧跟在参数列表之后 1 语法:如果没有用{ } 将函数体括起来，那么返回值就是函数体执行的结果； 12345678910111213141516 var fn = () =&gt; 1+2 ; console.log(fn); console.log(fn());//3//------------------------------------------------------------------ var fn1 = (value) =&gt; value ;//等价于// var fn1 = value =&gt; value ; 如果只传递一个参数，那么括号是可以不写的 console.log(fn1); console.log(fn1(2));//2//等价于 var fn1 = function(value)&#123; return value ; &#125;//---------------------------------------------------------------------- var fn2 = (a,b) =&gt; a+b ; console.log(fn2 ); console.log(fn2(2,3));//5 2 如果使用{ }将函数体括起来，默认返回值undefined; 12345678 var fn1 = (value) =&gt; &#123;value&#125; ; console.log(fn1); console.log(fn1(2));//undefined//等价于 var fn1 = function(value)&#123; value ; &#125; //函数执行完毕默认返回值是undefined ; 1234567891011 var fn = () =&gt; &#123;return 1+2&#125; ; console.log(fn); console.log(fn());//3//---------------------------------------------------------- var fn1 = (value) =&gt; &#123;return value&#125; ; console.log(fn1); console.log(fn1(2));//2//---------------------------------------------------------- var fn2 = (a,b) =&gt; &#123;return a+b&#125; ; console.log(fn2 ); console.log(fn2(2,3));//5 3 如何用箭头函数自定义对象 需要用小括号将花括号包起来； 12345var obj = (name,age) =&gt; (&#123; name : name , age:age &#125;);console.log( obj("jhon",13)); 等价于 123456var obj = function(name,age)&#123; return &#123; name:name, age:age &#125; &#125; 4 箭头函数的优势 4.1 更简短的函数书写方法 12345678910111213141516 var arr=["name",13,"Jim"]; var newArr = arr.map(function(item)&#123; //注意map函数没有返回值，默认返回值是undefined return item.length ; &#125;);//等价于 //var newArr = arr.map(item =&gt; item.length ) console.log(newArr);//----------------------------------------------------------------------- var Flatten = [[1,2],[4,6],[7,9]]// var newFaltten = Flatten.reduce(function(a,b)&#123;// return a.concat(b);// &#125;,[]) var newFaltten = Flatten.reduce( (a,b) =&gt; a.concat(b), [] ); 4.2 不绑定this 1234567891011//看下这个demo setInterval中的函数this默认指向是 window ,所以this.age获取不到值,等价于undefined++,结果是NaN;function Person ()&#123; this.age = 0 ; setInterval(function()&#123; console.log(this); this.age++ ; //点操作优先级最高，相当于先给window对象添加了一个age属性，但是未赋值，默认值是undefined console.log(this.age); &#125;,1000) &#125; var person = new Person(); 1234567891011//正常我们解决这个问题的办法如下function Person ()&#123; this.age = 0 ; var _this = this setInterval(function()&#123; console.log(_this); _this.age++ ; console.log(_this.age); &#125;,1000)&#125;var person = new Person(); 如果我们使用箭头函数 箭头函数则会捕获其所在上下文的 this值，作为自己的 this 值 12345678910function Person ()&#123; this.age = 0 ; setInterval(() =&gt; &#123; console.log(this); this.age ++ ; console.log(this.age); &#125;,1000);&#125;var person = new Person(); 5 箭头函数没有自己的 arguments对象 12var fn = () =&gt; arguments ; //arguments在箭头函数里面没有任何意义 console.log(fn());// arguments is not defined 123//原先的函数声明都是有个arguements对象的var fn = function()&#123;return arguments&#125; console.log(fn()); 6 箭头函数可以用作对象的方法(箭头函数内部没有定义this指向，其会根据函数运行确定this指向) 1234567'use strict' var name = "Jim"; var obj= &#123; name : 'Jhon', fn :() =&gt; this.name &#125; console.log(obj.fn()); 对比理解下:箭头函数的this指向其运行环境外围的作用域； 1234567var person = &#123; name: "Nicholas", sayName() &#123; console.log(this.name); &#125;&#125;;personn.sayName() ;//Nicholas 123456var person = &#123; name: "Nicholas", sayName:()=&gt; &#123; console.log(this.name); &#125; personn.sayName() ;//undefined]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[AngularJs自定义指令中的controller link和compile]]></title>
      <url>%2F2016%2F12%2F03%2F179AngularJs%E4%B8%AD%E7%9A%84link%E5%92%8Ccompile%2F</url>
      <content type="text"><![CDATA[1 compile、postlink、 link、 controller1.1 compile function compile函数:当一个angular应用程序初始化的时候被执行一次,并且只执行一次 compile函数中不包括作用域的操作以及数据绑定，以及监听器的绑定 Do: Manipulate markup so it serves as a template to instances (clones). Do not Attach event handlers. Inspect child elements. Set up observations on attributes. Set up watches on the scope. 1.2 Post-link function When the post-link function is called, all previous steps have taken place - binding, transclusion, etc. This is typically a place to further manipulate the rendered DOM. Do: Manipulate DOM (rendered, and thus instantiated) elements. Attach event handlers. Inspect child elements. Set up observations on attributes. Set up watches on the scope. 1.3 Controller function Each directive’s controller function is called whenever a new related element is instantiated. Officially, the controller function is where one: Defines controller logic (methods) that may be shared between controllers. Initiates scope variables. Again, it is important to remember that if the directive involves an isolated scope, any properties within it that inherit from the parent scope are not yet available. Do: Define controller logic Initiate scope variables Do not: Inspect child elements (they may not be rendered yet, bound to scope, etc.).1.4 Pre-link function Each directive’s pre-link function is called whenever a new related element is instantiated. As seen previously in the compilation order section, pre-link functions are called parent-then-child, whereas post-link functions are called child-then-parent. The pre-link function is rarely used, but can be useful in special scenarios; for example, when a child controller registers itself with the parent controller, but the registration has to be in a parent-then-child fashion (ngModelController does things this way). Do not: Inspect child elements (they may not be rendered yet, bound to scope, etc.). 2 各个作用搬运完毕，看下angularjs的生命周期2.1 编译阶段 在编译阶段，AngularJS会遍历整个HTML文档并根据JavaScript中的指令定义来处理页面上声明的指令。每一个指令的模板中都可能含有另外一个指令，另外一个指令也可能会有自己的模板。当AngularJS调用HTML文档根部的指令时，会遍历其中所有的模板，模板中也可能包含带有模板的指令.一旦对指令和其中的子模板进行遍历或编译，编译后的模板会返回一个叫做模板函数的函数。我们有机会在指令的模板函数被返回前，对编译后的DOM树进行修改。 2.2 第二个阶段是链接阶段:链接函数来将模板与作用域链接起来;负责设置事件监听器，监视数据变化和实时的操作DOM.链接函数是可选的。如果定义了编译函数，它会返回链接函数，因此当两个函数都定义了时，编译函数会重载链接函数. 2.3 走一个demo看下效果 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang="en"&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body ng-app = 'myApp'&gt;&lt;my-directive&gt;&lt;/my-directive&gt;&lt;script src="../libs/angular.js"&gt;&lt;/script&gt;&lt;script&gt; var myApp = angular.module('myApp',[]); myApp.directive('myDirective',function()&#123; return &#123; restrict : "EA", controller:function()&#123;// controller:function($scope, $element, $attrs, $transclude)&#123; //controller函数可以传入参数 console.log(arguments); console.log('this is controller'); &#125;, compile:function()&#123; console.log(arguments); console.log("this is compile"); return &#123; pre : function()&#123; console.log(arguments); console.log("this is pre"); &#125;, post : function()&#123; console.log(arguments); console.log("this is post"); &#125;, &#125; &#125;, link : function()&#123; console.log(arguments); console.log("this is link"); &#125; &#125; &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 控制台输出如下(关于每个函数的arguments这里不再写了，主要是为了看下每个函数要求传入的参数为何) 1234this is compile this is controllerthis is pre this is post 我们发现link并没有被执行，因为link被compile函数覆盖了 简化directive 1234567891011121314myApp.directive('myDirective',function()&#123; return &#123; restrict : "EA", controller:function()&#123;// controller:function($scope, $element, $attrs, $transclude)&#123; console.log(arguments); console.log('this is controller'); &#125;, link : function()&#123; console.log(arguments); console.log("this is link"); &#125; &#125; &#125;) 12this is controller this is link 这个时候我们发现controller和link都可以执行了，那么我们在实际应用中应该使用哪个？ 指令的控制器和link函数可以进行互换。控制器主要是用来提供可在指令间复用的行为，但链接函数只能在当前内部指令中定义行为，且无法在指令间复用.link函数可以将指令互相隔离开来，而controller则定义可复用的行为。 如果我们希望将当前指令的API暴露给其他指令使用，可以使用controller参数，否则可以使用link来构造当前指令元素的功能性。如果我们使用了scope.$watch()或者想要与DOM元素做实时的交互，使用链接会是更好的选择。 2.4 子级指令的所有 link function ：包括 pre 和 post 两个link都会在父级的post link之前被执行,我们用的link function 其实是post link的快捷方式罢了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107&lt;body ng-app = 'myApp'&gt;&lt;div parent&gt; &lt;div child&gt;&lt;/div&gt;&lt;/div&gt;&lt;div parent1&gt; &lt;div child1&gt;&lt;/div&gt;&lt;/div&gt;&lt;script src="../libs/angular.js"&gt;&lt;/script&gt;&lt;script&gt; var myApp = angular.module('myApp',[]); myApp.directive('parent',function()&#123; return &#123; restrict : "EA", controller:function()&#123;// controller:function($scope, $element, $attrs, $transclude)&#123; console.log('parent controller'); &#125;, compile:function()&#123; console.log("parent compile"); return &#123; pre : function()&#123; console.log("parent pre"); &#125;, post : function()&#123; console.log("parent post"); &#125;, &#125; &#125;, &#125; &#125;) myApp.directive('child',function()&#123; return &#123; restrict : "EA", controller:function()&#123;// controller:function($scope, $element, $attrs, $transclude)&#123; console.log('child controller'); &#125;, compile:function()&#123; console.log("child compile"); return &#123; pre : function()&#123; console.log("child pre"); &#125;, post : function()&#123; console.log("child post"); &#125;, &#125; &#125;, &#125; &#125;) myApp.directive('parent1',function()&#123; return &#123; restrict : "EA", controller:function()&#123;// controller:function($scope, $element, $attrs, $transclude)&#123; console.log('parent1 controller'); &#125;, compile:function()&#123; console.log("parent1 compile"); return &#123; pre : function()&#123; console.log("parent1 pre"); &#125;, post : function()&#123; console.log("parent1 post"); &#125;, &#125; &#125;, &#125; &#125;) myApp.directive('child1',function()&#123; return &#123; restrict : "EA", controller:function()&#123;// controller:function($scope, $element, $attrs, $transclude)&#123; console.log('child1 controller'); &#125;, compile:function()&#123; console.log("child1 compile"); return &#123; pre : function()&#123; console.log("child1 pre"); &#125;, post : function()&#123; console.log("child1 post"); &#125;, &#125; &#125;, &#125; &#125;)&lt;/script&gt;&lt;/body&gt; 12345678910111213141516parent compilechild compileparent1 compilechild1 compileparent controllerparent prechild controllerchild prechild postparent postparent1 controllerparent1 prechild1 controllerchild1 prechild1 postparent1 post 友情链接一个so]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ES6 let const]]></title>
      <url>%2F2016%2F12%2F01%2F120-ES6%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E%20let%20const%2F</url>
      <content type="text"><![CDATA[ES6变量声明 let const1 let声明1.1 let声明的变量和var声明变量一样，都可以从父级作用域获取变量 12345678let x = 9 ;//全局声明 let x ; ~function fn()&#123; console.log(x);//9 可以访问父作用域内let声明的变量 &#125;(); &#123; x = x + 3 ; // console.log(x);//12 &#125; 1.2 let 声明的变量必须 先声明 在 使用 , 所有在声明之前的使用都会报错; 在同一个作用域内用let声明的变量不允许重复(暂时性死区) var却可以在同一作用域内重复声明同名变量 ; 12345&#123; var b = 8 ; var b = 999; console.log(b);//999 var声明变量可以重复声明名称相同的变量 &#125; 123456let x = 9 ;&#123; let x = x + 3 ; //Uncaught ReferenceError: x is not defined //对于let在一个作用域内，必须先声明在使用,这里需要注意,赋值运算是从右向左进行的, console.log(x);&#125; 2 const声明 12345678910111213141516 /* 1 const声明，可以声明一个常量，该常量在声明的同时必须初始化，如果不初始化会报错， 2 const声明可以声明一个复杂数据类型，同时该复杂数据类型也必须初始化 3 const声明本质上其实是保证所声明的变量指向的内存地址是不能变化的，比如声明基本数据类型，声明之后不可改变 如果声明一个复杂数据类型，同样不能重新赋值 * * */// -----------------------------// 基本数据类型,声明之后不能重新赋值， const p = 9 ; p = 8 ; //Uncaught TypeError: Assignment to constant variable.// --------------------------------// 复杂数据类型，声明后该变量指向内存中的指针不能再修改，但是复杂数据类型内部的数据结构还是可变的 const o = &#123;&#125;;//指向一个地址，改地址存放一个空的对象 o.name = "Jhon";//内部数据结构是可变的 console.log(o); o = &#123;&#125;;//Uncaught TypeError: Assignment to constant variable.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Nodejs Express]]></title>
      <url>%2F2016%2F11%2F30%2F173Nodejs-Express%2F</url>
      <content type="text"><![CDATA[1 Express 是一个基于 Node.js 平台的极简、灵活的 web 应用开发框架，它提供一系列强大的特性，帮助你创建各种 Web 和移动设备应用。[express作者jk]]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[利用defineProperty获取闭包内部数据]]></title>
      <url>%2F2016%2F11%2F30%2F113-%E5%88%A9%E7%94%A8defineProperty%E8%8E%B7%E5%8F%96%E9%97%AD%E5%8C%85%E5%86%85%E9%83%A8%E6%95%B0%E6%8D%AE%2F</url>
      <content type="text"><![CDATA[利用defineProperty获取闭包内部数据1 defineProperty的使用方法: 123456789101112Object.defineProperty(obj,property,&#123; value:"属性值", writable:false,//控制属性是否可以重新赋值 configurable:false,//控制属性是否可以被删除 enumerable:false,//是否可枚举 get:function()&#123; return this.propertyValue; &#125;, set:function(value)&#123; this.propertyValue = value; &#125; &#125;) 2 利用给定接口获取闭包内部数据 123456789101112131415161718192021var o = (function() &#123; var person = &#123; name: 'Vincent', age: 24, &#125;; return &#123; run: function(k) &#123; return person[k]; &#125;, &#125;&#125;());//在不改变上面的代码情况下， 怎么得到原有的 person 对象？//解决：Object.defineProperty(Object.prototype, 'self', &#123; get: function() &#123; return this; &#125;, configurable: true &#125;);o.run('self'); // 输出 person]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[the difference between null and undefined]]></title>
      <url>%2F2016%2F11%2F29%2F72-typeof%20instance%20%E4%BB%A5%E5%8F%8Anull%20undefined%E5%8C%BA%E5%88%AB%2F</url>
      <content type="text"><![CDATA[1 typeof的使用;这是一个运算符，不是方法1.1检测数据类型，返回的结果是一个字符串类型。有六种可能：number boolean string object function undefined 注意typeof(null) 返回的是 : object typeof 运算符来判断一个值是否在某种类型的范围内。可以用这种运算符判断一个值是否表示一种原始类型：如果它是原始类型，还可以判断它表示哪种原始类型。ECMAScript 有 5 种原始类型（primitive type），即 Undefined、Null、Boolean、Number 和 String 1.1.1 在ES6 之前，typeof可以随心所欲的时候，基本上不会报错 1console.log(typeof a);//undefined 即使 a 在之前为进行任何的声明 1console.log( a);//a is not defined 报错 1.1.2 但是在ES6 之后引入了let和const之后 typeof 就需要掂量一下自己咯,let声明的变量，在所声明的作用域中，必须在使用之前进行声明 ，其实这是一个好的趋势，可以形成严谨良好的编程习惯； 12console.log(typeof a);//Uncaught ReferenceError: a is not defined let a; 12let a; console.log(typeof a);//undefined 1.2 typeof 可以用于被声明 或者未被声明 的变量；但是未被声明 的变量不能用其他运算符运算，之外的其他运算符的话，会引起错误，因为其他运算符只能用于已声明的变量上。 123456789&lt;script&gt; var exp1 ; console.log(typeof exp1);//undefined console.log(typeof exp2);//undefined console.log(exp1 == undefined);//true console.log(exp2 == undefined);//报错 console.log(typeof exp1 == 'undefined');//true console.log(typeof exp2 == 'undefined');//true typeof运算符可以用于未被声明的变量&lt;/script&gt; 1.3 对于基本数据类型(Number Boolean String null undefined) 以及引用类型 object的typeof值 1.3.1类 : Object Function Array String Boolean Number Date ；这些未初始化为实例的类的typeof类型为function 1234567891011function test ()&#123; &#125;console.log(Object);//function Object() &#123; [native code] &#125;console.log(typeof Object);//functionconsole.log(Array);//function Array() &#123; [native code] &#125;console.log(typeof Array);//functionconsole.log(Function);//function Function() &#123; [native code] &#125;console.log(typeof Function);//functionconsole.log(String);//function String() &#123; [native code] &#125;console.log(typeof String);//functionconsole.log(test);//function test()&#123; &#125;console.log(typeof test);//function 1.3.2 对象的创建方式是用关键字 new 后面跟上实例化的类的名字，当将一个函数通过new实例化之后，那么就创建了一个对象 123456789101112131415161718192021222324252627282930function test ()&#123; &#125; var obj = new test(); console.log(obj.constructor);//function test()&#123;&#125; console.log(obj);//test｛｝ console.log(typeof obj);//Object var obj1 = new Array(); console.log(obj1.constructor);//function Array() &#123; [native code] &#125; console.log(obj1);//[] console.log(typeof obj1);//Object var obj2 = new Function(); console.log(obj2.constructor);//function Function() &#123; [native code] &#125; console.log(obj2);//function anonymous() &#123;&#125; console.log(typeof obj2);//function var obj3 = new String(); console.log(obj3.constructor);//function String() &#123; [native code] &#125; console.log(obj3);//String &#123;length: 0, [[PrimitiveValue]]: ""&#125; console.log(typeof obj3);//object var obj4 = new Object(); console.log(obj4.constructor);//function Object() &#123; [native code] &#125; console.log(obj4);//Object &#123;&#125; console.log(typeof obj4);//objectvar obj5 = new Date(); console.log(obj5.constructor);//function Date() &#123; [native code] &#125; console.log(obj5);//Tue Feb 28 2017 21:13:36 GMT+0800 (中国标准时间) //当前的时间 console.log(typeof obj5);//object 1.3.3 基本数据类型的typeof的值 1234567891011121314&lt;script&gt; var func = function()&#123; console.log("你好"); &#125; var obj = &#123;"name":"john"&#125;; console.log(typeof 5); //number console.log(typeof 'name'); //string console.log(typeof false); //boolean console.log(typeof null); // object console.log(typeof undefined); // undefined console.log(typeof func); // object console.log(typeof obj); // object//所有的返回值的类型都会 字符串 类型，注意都是小写字母；但是有一点缺陷就是函数和对象以及DOM对象返回的值都是object,所以typeof用来监测数据类型的时候，如果监测基本数据类型还比较可靠，但是监测对象的时候却无太大作用。&lt;/script&gt; 1.3.5 通过上面分析我们发现typeof可以判断基本数据类型，但是对于复杂数据类型，返回都是object，那么如何检测object的”类”呢？也就是说，如何检测一个对象是由哪个构造函数创建的呢？ 这个时候就要用到 instanceof 了；语法: obj instanceof Type ,会沿着对象的原型链一层层的找，如果找到由Type类型的构造函数,则返回true，否则返回false； 123456789 function test ()&#123; &#125; var obj = new test(); console.log(obj.constructor);//function test()&#123;&#125; console.log(obj);//test｛｝ console.log(typeof obj);//Object console.log(obj instanceof test);//true //表示obj对象是test这个构造函数产生的 obj.__proto__ = test.prototype ;//obj的原型上__proto__ 指向test.prototype console.log(obj instanceof Object);//true 1.3.6 或者可以直接调用Object.prototype.toString.call(obj) 来判断obj到底是哪个类型的内置对象 123456789console.log(Object.prototype.toString.call(true));//[object Boolean]console.log(Object.prototype.toString.call(1,2)); //[object Number]console.log(Object.prototype.toString.call(null));//[object Null]console.log(Object.prototype.toString.call(undefined));//[object Undefined]console.log(Object.prototype.toString.call("str"));//[object String]console.log(Object.prototype.toString.call([1,2,3]));//[object Array]console.log(Object.prototype.toString.call(&#123;name:"Jhon"&#125;));//[object Object]console.log(Object.prototype.toString.call(new Date()));//[object Date] 2 null undefined 这两个原始数据类型没有属性和方法2.1 null是一个表示”无”的对象(null 则用于表示尚未存在的对象)，转化为数值的时候值为0；典型的用法是： 用来初始化一个变量，该变量将来可能会被赋值成一个对象 用来和一个已经初始化的对象进行比较，这个变量可以是一个对象，也可以不是一个对象 当函数的参数期望是对象时，被用作参数传入 当函数返回值期望是对象时，被当做返回值输出(比如调用API 获取页面元素) 调用API获取页面中的元素，获取不到的时候，返回undefined; 删除事件绑定,事件本身是一个 null ,是一个空的对象，可以添加 作为对象原型链的终点 正则exec()方法如果未找到匹配，则返回值为 null。 字符串 str.match(value) 方法匹配字符串，如果匹配不到，返回null 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang="en"&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;input type="button" value="按钮"/&gt;&lt;script&gt; console.log(document.querySelector("input").onclick);//null document.querySelector("input").onclick = function()&#123; console.log("被定义"); &#125;; console.log(document.querySelector("input").onclick);//function()&#123; console.log("被定义"); &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 2.2 undefined 是一个表示”无”的原始值，转化为数值的时候值为0 ；为布尔类型的时候使false ; 典型用法是： 变量被声明了，但是没有赋值，那么该变量的值就是undefined 调用一个函数的时候，如果应该提供的参数没有提供，那么该参数默认是undefined 如果一个对象的属性没有赋值，那么该属性值为undefined 获取某个对象的属性，该对象本身就没有该属性，返回undefined(数组也是对象) 函数没有返回值的时候，默认返回undefined; 函数的实参少于形参个数，未被赋值的形参默认值为undefined 使用shift pop 删除数组中的第一个和最后一个元素的时候，如果数组为空，那么返回值是undefined 12345function foo()&#123; this.age=10; &#125; var p1=foo.call(null); //函数执行结果没有返回值，默认返回undefined, console.log(p1.age);//undefined没有属性和方法，所以会报错 2.3 乱入一个空字符串作为返回值以及NaN作为返回值的情况总结吧 str.chatAt(index) 如果index不再0和str.length那么返回一个空字符； 如果期望转化的结果为数字的时候，转化失败的时候，返回NaN 2.4如何区分二者？ == 运算符只比较值，不进行类型的比较，比较之前会进行隐式转化，null==undefined 返回true. === 区分两者，不仅仅比较内容，还比较数据类型 null===undefined false 如何判断一个变量是null还是undefined? 如何确定一个变量是undefined; 123456789var exp = undefined ;//var exp ;如果不进行赋值的话，结果也是undefined//这种方法是错误的，因为null==undefined 返回true;if(exp == undefined)&#123; console.log("exp变量是undefined");&#125;//这种方法才是正确的，注意undefined加"" ,因为typeof返回的值是一个字符串类型的if(typeof(exp) == 'undefined')&#123; console.log("exp变量是undefined");&#125; 以下附上 == 运算符的W3C解释，方便读者回忆基础 12345678910执行类型转化遵循的规则:如果一个运算数是 Boolean 值，在检查相等性之前，把它转换成数字值。false 转换成 0，true 为 1。 如果一个运算数是字符串，另一个是数字，在检查相等性之前，要尝试把字符串转换成数字。 如果一个运算数是对象，另一个是字符串，在检查相等性之前，要尝试把对象转换成字符串。 如果一个运算数是对象，另一个是数字，在检查相等性之前，要尝试把对象转换成数字。还遵循以下转化规则:值 null 和 undefined 相等。 在检查相等性时，不能把 null 和 undefined 转换成其他值。 如果某个运算数是 NaN，等号将返回 false，非等号将返回 true。 如果两个运算数都是对象，那么比较的是它们的引用值。如果两个运算数指向同一对象，那么等号返回 true，否则两个运算数不等。 我觉得可以进行再简化，来进行解释这个比较过程: 12如果其中一个是布尔类型则先将布尔类型转化 为0 或者 1 ;如果一个是对象，和字符串、 数字 或者 布尔类型 进行比较的时候则将对象转化为原始值，对象通过toString valueOf 查看原始值，然后在与字符串 数字 布尔类型进行比较 如何确定一个变量是null 123456789101112var exp = null;//以下两种是不正确的if(!exp)&#123; //0 或者undefined同样可以进入if语句 console.log("该变量是null");&#125;if(exp == null )&#123; //undefined == null 返回true console.log("该变量是null")&#125;//下面这种才是正确判断null 类型的if(typeof(exp) == 'object' &amp;&amp; exp == null)&#123; //同时进行类型和内容的判断 console.log("该变量是null");&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[web中的path路径浅析]]></title>
      <url>%2F2016%2F11%2F28%2F171web%E4%B8%AD%E7%9A%84path%E8%B7%AF%E5%BE%84%E6%B5%85%E6%9E%90%2F</url>
      <content type="text"><![CDATA[之前写过 NodeJs中的path路径浅析 现在简单看下浏览器是如何解析路径的 1 浏览器端解析路径的时候，总是以所解析的文件作为当前页 看下实例demo的目录结构 123456webPath/ js/ -app.js -index.html -ab.html -abc.html app.js 以下app文件读取的路径和启动服务器所在目录有着直接的关系，NodeJs中的path路径浅析 已经分析过，不再赘述，这里代码不进行封装了。 12345678910111213141516171819202122232425262728293031323334353637383940414243var http = require('http');var fs = require('fs');var template = require('art-template');var server = http.createServer();server.listen(8080,function()&#123; console.log("8080running");&#125;);server.on('request',function(req,res)&#123; var url = req.url ; var method = req.method.toLowerCase(); console.log(url); console.log(method); if(method === 'get' &amp;&amp; url === '/')&#123; fs.readFile('../index.html','utf-8',function(err,data)&#123; if(err)&#123; throw err ; &#125; console.log(data); var htmlStr = template.compile(data)(&#123;info:&#123;flag:'/'&#125;&#125;); res.end(htmlStr) &#125;) &#125;else if(method === 'get' &amp;&amp; url === '/aaa/bbb')&#123; fs.readFile('../ab.html','utf-8',function(err,data) &#123; if (err) &#123; throw err; &#125; var htmlStr = template.compile(data)(&#123;info: &#123;flag: 'ab'&#125;&#125;); console.log(htmlStr); res.end(htmlStr) &#125;) &#125;else if(method === 'get' &amp;&amp; url === '/aaa/bbb/ccc')&#123; fs.readFile('../abc.html','utf-8',function(err,data) &#123; if (err) &#123; throw err; &#125; var htmlStr = template.compile(data)(&#123;info: &#123;flag: 'abc'&#125;&#125;); res.end(htmlStr) &#125;) &#125;&#125;); index.html 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang="en"&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;a href="../aaa/bbb"&gt;地址: ../aaa/bbb&lt;/a&gt;&lt;br/&gt;&lt;a href="./aaa/bbb"&gt;地址: ./aaa/bbb&lt;/a&gt;&lt;br/&gt;&lt;a href="/aaa/bbb"&gt;地址: /aaa/bbb&lt;/a&gt;&lt;br/&gt;&lt;p&gt;以上三个地址对应的资源是一样的，也就是说上面三种路径的写法在浏览器解析的时候是等价的&lt;/p&gt;&lt;a href="/aaa/bbb/ccc"&gt;地址: /aaa/bbb/cc&lt;/a&gt;&lt;br/&gt;&lt;a href="/aaa/bbb/./ccc"&gt;地址: /aaa/bbb/./ccc&lt;/a&gt;&lt;br/&gt;&lt;a href="/aaa/bbb/../bbb"&gt;地址: /aaa/bbb/../bbb&lt;/a&gt;&lt;br/&gt;&lt;p&gt;flag 标记&#123;&#123;info.flag&#125;&#125;&lt;/p&gt;&lt;p&gt;this is / 对应的内容&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; ab.html 123456789101112&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang="en"&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;a href="/"&gt;back to index&lt;/a&gt;&lt;p&gt;flag 标记 &#123;&#123;info.flag&#125;&#125;&lt;/p&gt;&lt;p&gt;this is /aaa/bbb 对应的内容&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; abc.html 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang="en"&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;a href="/"&gt;back to index&lt;/a&gt;&lt;p&gt;flag 标记 &#123;&#123;info.flag&#125;&#125;&lt;/p&gt;&lt;p&gt;this is /aaa/bbb/ccc对应的内容&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 2 我们发现 ../ ./ 如果放在路径的开头，则会被浏览器“忽略”；在路径内则会按照原来的 ./ 代表当前路径 ../ 代表上级目录进行解析; 其实，从客户端返回的路径对于服务器来说，就是一个“标识符”，还记得标识符吗？当我们学习定义一个变量的时候，要用var name = “Jhon”,其中的name就是标识符，通过name可以直接获取到Jhon，这里的客户端请求的路径对于服务器也是一样的，客户端的请求也就是一个“标识符”，客户端请求一个 / 服务端返回index.html，客户端请求 /aaa/bbb 服务端返回对应的ab.html页面，当然也可以是不同的其他的资源文件。 根本还是根据客户端的标识符，服务器进行响应，然后返回响应的数据，所以我们有可能看到的是‘假路径’，一切都是假的，咯咯。 3 实际情况通过demo的演示会很清楚的显示，大家动手多实践吧。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[css3 background]]></title>
      <url>%2F2016%2F11%2F22%2F30-CSS3%20background%20%E8%83%8C%E6%99%AF%2F</url>
      <content type="text"><![CDATA[CSS3 background-origin clip size 背景 1 盒子大小大于背景图的大小，如何避免精灵图周边的其他图片显示出来 一 对于背景色： background-clip : border-box || padding-box || content-box || text 定义元素的背景图像 从何处开始向外 裁剪，默认值是border-box； bakcground-origin : border-box || padding-box || content-box 该属性改变背景图像 的填充开始原点，对背景色 没有影响 定义元素的背景图像 从何处开始填充，即填充开始的原点；默认值是padding-box ； 注意背景图像必须设置为 no-repeat才会有效果，不然将会完全平铺 background-size : auto || length || percentage || cover || container 该属性值设置背景图像的大小， auto是默认值，即背景图像的真实大小， length 可以直接设置背景图像的大小，会将背景图像进行压缩 ， percentage 以百分比设置背景图像的大小，百分比的基准是盛放背景图像的元素的宽高，而不是背景图像本身尺寸的宽高， length和percentage如果只设置一一个值，那么将设置为背景图像的宽度尺寸，第二个值默认auto,根据宽度进行等比缩放； cover 会将背景图像进行等比 缩小或者放大，使其可以完全覆盖容器 ，此时背景图像可能会溢出； container会将背景图像进行等比缩小或者放大到宽度或者高度与容器的宽度或者高度一样，使其可以完全在容器内，此时容器可能会有空余空间； 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang="en"&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; div&#123; border: 10px dashed blue; width: 150px; height: 150px; background-color: red; margin: 50px auto ; padding: 20px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 123456789给div依次设置以下属性:background-clip: border-box; //会将背景从border开始向外剪裁background-clip: padding-box; //会将背景从padding开始向外剪裁background-clip: content-box; //会将背景从content开始向外剪裁注意背景默认是填充border边界的，即以border-box为默认值**对于背景色而言，永远都之直接填充包括border-box为边界内部的区域，background-origin对背景色不起作用;background-origin:border-box; background-origin: padding-box;background-origin: content-box; 将这三个属性依次设置给div ,效果如下： 二 对于背景图像： 12345678910div&#123; border: 10px dashed blue; width: 150px; height: 150px; background-color: red; margin: 50px auto ; padding: 20px; background: url("img/01.jpg") no-repeat; &#125; 12345 /*background-clip: border-box;*/ /*background-clip: padding-box;*/ /*background-clip: content-box;*/和背景色一样，都是向外裁剪，但是需要注意，背景图像填充的时候，默认是以padding-box，即padding左上角为原点进行填充整个div的，也就是说，div的上边框和左边框不会被填充，但是下边框和有边框会被填充，如果想要所有的边框被填充，那么需要设置background-origin:border-box ; 三 background属性连写:新版CSS3支持可以写多个背景连写在一起,中间用逗号隔开，最后以分号结尾 12345678background: url(img/bg1.png) no-repeat left top,url(img/bg2.png) no-repeat right top,url(img/bg4.png) no-repeat left bottom,url(img/bg3.png) no-repeat right bottom,url(img/dog.gif) no-repeat center/400px 270px;background:none [0% 0%] /auto repeat scroll padding-box content-box transparentbackground:image pisition size repeat attachment origin clip color]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[width 百分比取值基准]]></title>
      <url>%2F2016%2F11%2F22%2F31-width%20%20%E7%99%BE%E5%88%86%E6%AF%94%E5%8F%96%E5%80%BC%E7%9B%B8%E5%AF%B9%E5%9F%BA%E5%87%86%E9%97%AE%E9%A2%98%2F</url>
      <content type="text"><![CDATA[width 百分比取值相对基准问题 一 ：标准流下，父元素不定位，不浮动，子元素的100% width相对于哪个元素的width进行取值 二：脱离标准流之后，父元素设置了定位或者浮动之后，子元素的100% width相对于哪个元素的width进行取值 注意理解： 当子元素是标准流的元素的时候，(包括子元素设置position:relative，也是永远相对于父元素的宽高为基准) 无论父元素是否是标准流 的元素，子元素的width和height的百分比取值永远都是相对于父元素的; 此时无论父元素是否设置定位，子元素的width height padding margin 通过百分数取值的时候，都是相对于其直接父元素。 当子元素不是标准流的时候，比如子元素设置了position:absolute； 此时子元素的宽高百分比设置的时候，百分比的宽高基准是顺着DOM元素往上寻找最近的一个设置了定位了父元素的宽高为基准，如果祖先元素都没有定位的话，那么就是相对于body的宽高；注意position除了static的父元素 ； 注意position除了static的父元素 ； 其实绝对定位的子元素的 margin padding 等值的百分比都是相对于顺着DOM节点树向上第一个设置了除了static定位之外的position 的元素的宽度为基准的； % 重点理解：width 是 基于父元素的 width 计算的值height 是基于父元素的 height 计算的值padding 和 margin 的无论上下左右 值 都是基于DOM树节点祖先元素中第一个设置了除了static定位之外的第一个祖先元素的宽度 ​ ​ ​ ​]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[html5 Drag]]></title>
      <url>%2F2016%2F11%2F22%2F32-HTML5Drag%2F</url>
      <content type="text"><![CDATA[1,全屏API:DOM元素支持全屏，HTML5的标准写法是 ele.requestFullScreen( ), 即可使DOM元素全屏；但是由于该方法处于不够完善，所以需要写各个浏览器的兼容代码； 123456789if(this.webkitRequestFullScreen)&#123; this.webkitRequestFullScreen(); &#125;else if(this.mozRequestFullScreen)&#123; this.mozRequestFullScreen(); &#125;else if(this.requestFullScreen)&#123; this.requestFullScreen(); &#125;else if(this.msRequestFullscreen)&#123; this.msRequestFullscreen(); &#125; 2,拖拽API:首先来看有哪些拖放(drag和drop)的事件，如果要是元素可以拖拽， 首先要给该元素设置 draggable = true 属性，保证该元素可以被拖放.(img标签默认支持拖放，div默认不支持拖放) 拖拽元素的事件如下： ondrag 当拖动元素的时候运行脚本 ondragstart 当拖动操作开始时候运行脚本 ondragend 当拖动操作结束的时候运行脚本 目标元素的事件如下： ondragover 当元素被拖动至有效拖放目标上方时执行脚本 ondragenter 当元素被拖动至有效拖动目标时执行脚本 ondragleave 当元素离开至有效拖放目标是运行脚本 ondrop 当被拖动元素正在被放下的时候运行脚本 注意如果想要使目标元素可以被放进来拖放的元素，因为默认地，无法将数据/元素放置到其他元素中。如果需要设置允许放置，我们必须阻止对元素的默认处理方式。此时需要对目标元素进行处理，调用dragover阻止默认事件 的方法： 123目标元素.ondragover = function(event)&#123; event.preventDefault() ;&#125; 3 代码演示 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091&lt;!DOCTYPE html&gt;&lt;html lang="zh-cn"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; html, body &#123; height: 100%; &#125; body &#123; margin: 0; display: flex; justify-content: space-around; align-items: center; &#125; div &#123; width: 400px; height: 400px; border: 1px solid #000; &#125; .left &#123; display: flex; flex-wrap: wrap; justify-content: space-around; align-items: center; &#125; div&gt;img &#123; width: 70px; height: 70px; margin: 10px; background-color: ; &#125; /* 使用css来修改 定义一个 高亮的颜色 */ .right.active &#123; background-color: lightblue; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="left"&gt; &lt;img src="imgs/lofter_1_noval_icon_ (1).jpg" alt=""&gt; &lt;img src="imgs/lofter_1_noval_icon_ (2).jpg" alt=""&gt; &lt;img src="imgs/lofter_1_noval_icon_ (3).jpg" alt=""&gt; &lt;/div&gt; &lt;div class="right"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&lt;script&gt; // .right 盒子 元素移入 颜色高亮 document.querySelector('.right').ondragenter = function () &#123; // this.style.background = 'lightgray'; this.classList.add('active'); // $(this).addClass('active'); &#125; // .right 移出 颜色还原 document.querySelector('.right').ondragleave = function () &#123; // 颜色 就是 直接设置透明 // this.style.background = 'transparent'; // this.style.background = 'rgba(0,0,0,0)'; this.classList.remove('active'); &#125; // 为了能够触发drop 必须设置如下代码,给目标元素设置阻止默认处理方式，允许元素可以被放置 document.querySelector('.right').ondragover = function (event) &#123; event.preventDefault(); &#125; // drop .right盒子绑定 // img 拖拽开始的 时候 保存为 全局变量 var imgs = document.querySelectorAll('.left&gt;img'); // 当前移动的 img var moveImg = undefined; // 循环绑定，给每个拖拽元素设置拖拽事件，每个元素被拖拽时触发该事件 for(var i=0;i&lt;imgs.length;i++)&#123; imgs[i].ondragstart = function()&#123; // 保存为全局变量 moveImg = this; // 打印是否保存 console.log(moveImg); &#125; &#125; document.querySelector('.right').ondrop = function () &#123;// moveImg.ondrop = function () &#123; console.log('进来了'); // 将 丢进来的 元素 设置为 子元素 // 获取丢进来的元素 在拖拽img的时候 将当前拖拽的img 存起来获取保存的img // 通过全局变量 moveImg 添加给自己 document.querySelector('.right').appendChild(moveImg); // 还原 自己的颜色 this.classList.remove('active') &#125;&lt;/script&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JSON operate]]></title>
      <url>%2F2016%2F11%2F21%2F68JSON%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
      <content type="text"><![CDATA[JSON数据处理的方法 1 json数据格式: 以键值对的形式存在 json={“key”:”value”,”key1”:”value1”,”key2”:”value2”}; key对应的值可以使数组或者对象 json={“key” : { } , “key1” : [ ] , “key2” : function(){ } } ; json是一种规范，一种数据格式的规范 json实际上是字符串 2 json数据格式，”存前读后”，也就是说存储json格式的数据之前，要进行将其转化为字符串，读取的时候，要转化为对象 JSON.stringify() 将一个对象解析成字符串 将JavaScript值转换为JSON字符串 JSON.parse() 将一个字符串解析成对象 ，构造由字符串描述的JavaScript值或对象。 1234567891011121314&lt;script&gt; var myJson=&#123;"UserName":"Jim"&#125;; console.log(myJson);//Object &#123;UserName: "Jim"&#125; var strMyJson = JSON.stringify(myJson);//将myJson存进去，记得JSON.stringify转成字符串 console.log(strMyJson);// 字符串 '&#123;UserName: "Jim"&#125;' console.log(typeof strMyJson);//string var objMyJson=JSON.parse(strMyJson);//取出来的是字符串，记得JSON.parse还原为对象 console.log(objMyJson);//Object &#123;UserName: "Jim"&#125; console.log(typeof objMyJson);//object var data = [&#123;"name":"jhon"&#125;,&#123;"age":16&#125;];//数组也可以 var strData = JSON.stringify(data); console.dir(strData); console.dir(typeof strData);&lt;/script&gt; 3 JSON.parse用法在JSON.parse and eval 博文已经总结过 4 JSON.stringify()详解 (参阅MDN) 语法 返回值是一个JSON格式的字符串 1JSON.stringify(value[, replacer [, space]]) value是要序列化为一个JSON字符串的值 replacer可选参数 如果该参数是一个函数，那么在序列化的过程中的被序列化的每个属性都会经过该函数的转换和处理 如果该参数是一个数组，那么只有包含在该数组中的属性名才能被最终序列化为JSON字符串 如果该参数为null或者未提供， 那么对象的所有属性都会被序列化 space 可选参数，用于梅花输出 如果该参数是一个数字，代表有多少个空格，上限为10 ，如果该数字小于1，则没有空格 如果该参数为null或者没有提供将没有空格 注意事项 字符串，数字，布尔类型的数据值会被直接 转化为原始值 undefined 函数 以及symbol值 在数组中出现的时候，会被转化为null 作为对象的属性值出现的时候，整个键值对都会被忽略 不可枚举的属性不会被序列化为字符串 走几个demo便于理解和记忆 123456789101112131415161718var obj = Object.create(&#123; foo: 1 &#125;, &#123; // foo is on obj's prototype chain. bar: &#123; value: 2 // bar is a non-enumerable property.默认值false &#125;, baz: &#123; value: 3, enumerable: true // baz is an own enumerable property. &#125; &#125;); console.log(JSON.stringify(obj));//'&#123;"baz":3&#125;' console.log(JSON.stringify(&#123;&#125;));//'&#123;&#125;' console.log(JSON.stringify(false));//"false" console.log(JSON.stringify(4));//"4" console.log(JSON.stringify('foo'));//"foo" console.log(JSON.stringify(['foo',2,true]));//'["foo",2,true]' console.log(JSON.stringify([undefined,Array,Symbol("")]));//'[null,null,null]' console.log(JSON.stringify(&#123;x:undefined,y:Array,z:Symbol("")&#125;));//'&#123;&#125;' replacer函数 如果返回一个 Number 转换成相应的字符串被添加入JSON字符串。 如果返回一个 String, 该字符串作为属性值被添加入JSON。 如果返回一个 Boolean, “true” 或者 “false”被作为属性值被添加入JSON字符串。 如果返回任何其他对象，该对象递归地序列化成JSON字符串，对每个属性调用replaceer方法。除非该对象是一个函数，这种情况将不会被序列化成JSON字符串。 如果返回undefined，该属性值不会在JSON字符串中输出。 12345678910var obj = &#123;name:'Jhon',age:19,gender:"man"&#125;;function replacer (key,value)&#123; if(typeof value === 'number')&#123; return undefined; &#125; return value ;&#125;var jsonString = JSON.stringify(obj,replacer);console.log(jsonString);//'&#123;"name":"Jhon","gender":"man"&#125;' 123var obj = &#123;name:'Jhon',age:19,gender:"man"&#125;;var jsonString = JSON.stringify(obj,['age','other']);//多余的会被忽略console.log(jsonString);//'&#123;"age":19&#125;' ;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Angular Js directive]]></title>
      <url>%2F2016%2F11%2F21%2F162AngularJsdirective%2F</url>
      <content type="text"><![CDATA[建议大家看angular英文文档，然后实践出真知 1 angular directive的自定义用法 我们在定义一个指令的时候使用驼峰法来命名一个指令，例如 runoobDirective, 但在使用它时需要以 -分割, runoob-directive；先来看下自定义指令的语法结构 首先定义指令前需要首先定义一个模块 1var app = angular.module('app',[]);//定义一个模块 在定义了模块之后，可以在定义指令 123app.directive('directiveName',function()&#123; return config&#125;) return的配置参数有很多，接下来一一进行分析 1.1 限制使用 restrict 值为字符串 可以的值有 ECMA E设置指令可以通过元素的形式进行调用 A 设置指令可以通过属性的形式调用 M设置指令可以通过注释的形式调用 C设置指令可以通过类名进行调用；默认值是EA ，表示我们定义的指令可以通过元素名或者属性的形式进行调用 你可以限制你的指令只能通过特定的方式来调用。 1234567891011121314&lt;!-- E (element) --&gt;&lt;directiveName&gt;&lt;/directiveName&gt;比如&lt;ng-view&gt;&lt;/ng-view&gt;等&lt;!-- A (attribute) --&gt;&lt;div directiveName="expression"&gt;&lt;/div&gt;比如&lt;div ng-init="name= 'Jhon'"&gt;&lt;/div&gt;&lt;div ng-hide="name= 'Jhon'"&gt;&lt;/div&gt; 等&lt;!-- C (class) --&gt;&lt;div class="directiveName"&gt;&lt;/div&gt;&lt;!-- M(comment) --&gt;&lt;!--directive:directiveName expression--&gt; 1.2 priority 默认值为0数字，可选参数，致命指令的优先级，若在单个DOM元素上有多个指令，则优先级高的先执行。 当然，设置指令的优先级不太常用，但是比较特殊的例子是，内置指令ng-repeat的优先级为1000，而ng-init的优先级为 450。 1.3 terminal布尔型，可选参数，可以被设置为true或者false，若设置为true，则优先级低于此指令的其他指令则无效，不会被调用优先级相同任然会执行。 1.4. template字符串或者函数，可选参数。 其中字符串可以是html标签，可以是一个页面，也可以是一个简单的字符串比如 “this is str” 如下栗子我们简单的定义了一个指令，template是字符串的形式 123456app.directive('hello',function()&#123; return &#123; //默认restrict是EA template:'&lt;div&gt;try your best&lt;/div&gt;' &#125;&#125;) 然后可以使用该指令，通过属性或者元素的方式进行指令的使用 12&lt;div hello&gt;&lt;/div&gt;&lt;hello&gt;&lt;/hello&gt; 显示结果如下 12try your besttry your best 如下栗子我们定义的一个指令，template是函数的形式，function函数接受两个参数，第一个是element,表示使用此指令的元素，attrs是 实例的属性，它有一个元素上所有的属性组成集合 123456789app.directive('hello1',function()&#123; return &#123; template:function(ele,attr)&#123; console.log(arguments); //为了便于说明函数传入的参数ele和attr到底代表的是哪些，我们可以打印出来看下具体的结果 return '&lt;div&gt;'+'hello '+attr.info+'&lt;/div&gt;' &#125; &#125;&#125;) 然后可以使用该指令，通过属性或者元素的方式进行指令的调用，可以发现第一个调用输出arguments，ele参数代表hello1元素，attr参数代表hello1上面的属性的集合 ，第二次输出arguments,ele代表div元素，attr参数代表div上面的所有的属性的集合 12&lt;hello1 info = 'Jhon'&gt;&lt;/hello1&gt;&lt;div hello1 info='JiM'&gt;&lt;/div&gt; 显示结果如下： 12hello Jhonhello JiM html的结构如下 123456&lt;hello1 info = 'Jhon'&gt; &lt;div&gt;hello Jhon&lt;/div&gt;&lt;/hello1&gt;&lt;div hello1 info='JiM'&gt; &lt;div&gt;hello JiM&lt;/div&gt;&lt;/div&gt; 1.5 replace 布尔型，默认值为false，设置为true的时候，表示可以用自定义的模板内容的标签替换自定义的元素标签。在上例子的基础上，变化如下，大家可以对比下上述两者html的结构的区别123456789app.directive('hello1',function()&#123; return &#123; replace:true, template:function(ele,attr)&#123; console.log(arguments); return '&lt;div&gt;'+'hello '+attr.info+'&lt;/div&gt;' &#125; &#125;&#125;); html结构 12&lt;div hello1="" info="JiM"&gt;hello JiM&lt;/div&gt;&lt;div info="Jhon"&gt;hello Jhon&lt;/div&gt; 1.6 templateUrl （字符串或者函数），可选参数，可以是（1）一个代表HTML文件路径的字符串 （2）一个函数，可接受两个参数tElement和tAttrs（大致同上） 1.6.1 templateUrl接受一个字符串 index.html页面中有如下代码 1234&lt;script type='text/ng-template' id='courage.html'&gt;//注意，模板文件的type属性必须是 ng-template ,表示以angular的规则进行模板的解析 &lt;p&gt;that is awesome to learn more about IT &lt;/p&gt;&lt;/script&gt; 我们可以定义一个指令 1234567app.directive('courage',function()&#123; return &#123; templateUrl:"courage.html", replace:true, restrict:'E' &#125;&#125;) 调用指令 1&lt;conrage&gt;&lt;/conrage&gt; 页面显示的html结构如下(注意restrict和replace属性的设置对于显示的影响) 1&lt;p&gt;this is awesome to learn more about IT &lt;/p&gt; 1.6.2 templateUrl接受一个函数 index.html 1234567891011121314151617181920212223242526&lt;body ng-app = 'myApp'&gt;&lt;div ng-controller = 'myCtrl'&gt; &lt;p courage type='one'&gt;&lt;/p&gt; &lt;p courage type='two'&gt;&lt;/p&gt;&lt;/div&gt;&lt;script src="../libs/angular.js"&gt;&lt;/script&gt;&lt;script&gt; var app = angular.module('myApp',[]); app.controller('myCtrl',['$scope',function($scope)&#123; $scope.info = &#123; name : 'Jhon', age : '19' &#125; &#125;]) app.directive('courage',function()&#123; return &#123; templateUrl : function(ele,attr)&#123; console.log(arguments); return 'courage'+ attr.type+'.html'; &#125; &#125; &#125;)&lt;/script&gt;&lt;/body&gt; courageone.html 123&lt;body&gt;&lt;p&gt;this is courage1:`&#123;&#123;info.name&#125;&#125;`&lt;/p&gt;&lt;/body&gt; couragetwo.html 123&lt;body&gt;&lt;p&gt;this is courage2:`&#123;&#123;info.age&#125;&#125;`&lt;/p&gt;&lt;/body&gt; 1.7 scope 默认值是falsefalse表示继承父作用域的值，且不进行隔离，子作用域和父作用域的改变都将影响变量的值； true表示继承父作用域的值，但是进行隔离，这种效果和设置两个控制器的效果是一样的； {}：没有继承父亲的值，所以儿子的值为空，改变任何一方的值都不会影响另一方，这就是不继承且隔离; 当想要创建一个可重用的组件时，隔离作用域是一个很好的选择，通过隔离作用域，我们可以确保指令是独立的，并且可以轻松的插入到任何HTML APP中，并且这种做法防止了父作用域被污染。 先来看下作用域，我们知道，每定义一个控制器就会形成一个scope对象，该对象可以表示一个作用域，并且继承了父作用域的数据；我们从下面的例子可以改变输入的名字， 子作用域继承了父作用域的变量 子作用域和父作用域的变量的改变是相互独立的，也就是说子作用域是继承且隔离的 1.7.1 先来看下controller控制器下面的作用的效果，子作用域和父作用域是继承且隔离的效果，子作用域的变量的变化不会污染到父作用域； 1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang="en"&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script src="angular.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body ng-app = 'app'&gt;&lt;div ng-controller = 'parent' &gt; &lt;input type="text" ng-model = 'name' placeholder='please input your name'/&gt; parent:`&#123;&#123;name&#125;&#125;` age:`&#123;&#123;age&#125;&#125;` &lt;div ng-controller = 'child'&gt; &lt;input type="text" ng-model = 'name' placeholder='please input your name'/&gt; child:`&#123;&#123;name&#125;&#125;` age :`&#123;&#123;age&#125;&#125;` &lt;/div&gt;&lt;/div&gt;&lt;script&gt; var app = angular.module('app',[]); app.controller('parent',['$scope',function($scope)&#123; $scope.name = "Jhon"; $scope.age = 19 ; &#125;]); app.controller('child',['$scope',function($scope)&#123; $scope.name = "JiM"; &#125;]); //这种情势下的scope作用域是继承且隔离的，子作用域内的变量的改变不会对父作用域内的变量有任何的影响&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 1.7.2 再来看下我们自定义directive的时候的scope不同的设置情况的效果 false的情况(或者没有设置的时候默认的情况)，子作用域会污染父作用域的变量，继承且不隔离 true的情况，和1.7.1controller的效果一样，继承且隔离，这种情况下也就是一般的原型继承的情况 { } 的情况，表示不继承且隔离 123456789101112131415161718192021222324252627282930&lt;body ng-app = 'app'&gt;&lt;div ng-controller = 'parent' &gt; &lt;input type="text" ng-model = 'name'/&gt; parent:`&#123;&#123;name&#125;&#125;` &lt;child&gt;&lt;/child&gt;&lt;/div&gt;&lt;script&gt; var app = angular.module('app',[]); app.controller('parent',['$scope',function($scope)&#123; $scope.name = "Jhon"; &#125;]); app.directive('child',function()&#123; return &#123; replace:true ,//默认值是false restrict:'EA', scope:false, template:''+ '&lt;div&gt;'+ '&lt;input type="text" ng-model = "name"/&gt;'+ `'child:&#123;&#123;name&#125;&#125;'`+ '&lt;/div&gt;' &#125; &#125;); //这种情势下的scope作用域是继承且隔离的，子作用域内的变量的改变不会对父作用域内的变量有任何的影响&lt;/script&gt;&lt;/body&gt; 1.7.3 当我们将scope设置为{ } 的时候，此时子作用域无法再访问父作用域的变量值，这个时候需要我们做出一些调整，让子作用域可以访问父作用域的变量，但是不会污染父作用域 采用 @ 进行单向绑定，也就是说，改变父作用域的name的值，directive里面的name也会改变，但是改变隔离区directive里面的name,父作用域里面的name是不会发生改变的;也就是达到继承且隔离的效果 1234567891011121314151617181920212223242526272829303132333435&lt;body ng-app = 'app'&gt;&lt;div ng-controller = 'parent' &gt; &lt;input type="text" ng-model = 'name'/&gt; parent:`&#123;&#123;name&#125;&#125;` &lt;!--&lt;child name="&#123;&#123;name&#125;&#125;"&gt;&lt;/child&gt;--&gt; &lt;child your-name=`"&#123;&#123;name&#125;&#125;"`&gt;&lt;/child&gt;&lt;/div&gt;&lt;script&gt; var app = angular.module('app',[]); app.controller('parent',['$scope',function($scope)&#123; $scope.name = "Jhon"; &#125;]); app.directive('child',function()&#123; return &#123; replace:true ,//默认值是false restrict:'EA', scope:&#123; //如果绑定的隔离作用域属性名与元素的属性名相同，则可以采用缺省写法// name:'@' //对应&lt;child name="&#123;&#123;name&#125;&#125;"&gt;&lt;/child&gt; name:"@yourName" &#125;, template:''+ '&lt;div&gt;'+ '&lt;input type="text" ng-model = "name"/&gt;'+ `'child:&#123;&#123;name&#125;&#125;'`+ '&lt;/div&gt;' &#125; &#125;); //这种情势下的scope作用域是继承且隔离的，子作用域内的变量的改变不会对父作用域内的变量有任何的影响&lt;/script&gt;&lt;/body&gt; 此时template生成的html结构如下 123&lt;div your-name="Jhon" class="ng-binding ng-isolate-scope"&gt; &lt;input type="text" ng-model="name" class="ng-valid ng-not-empty ng-dirty ng-touched"&gt;child:Jhon&lt;/div&gt; 123456//我们可以大致的模拟下ng-controller的实现原理app.directive("myController", function()&#123; return &#123; scope: true, //scope设置为true， controller: '@' &#125;&#125;); 采用 = 进行双向绑定，也就是说，改变父作用域的name的值，directive里面的name也会改变，同样改变隔离区directive里面的name,父作用域里面的name是也会发生改变的;此时达到了 继承且不隔离的效果 1234567891011121314151617181920212223242526272829303132333435&lt;body ng-app = 'app'&gt;&lt;div ng-controller = 'parent' &gt; &lt;input type="text" ng-model = 'name'/&gt; parent:`&#123;&#123;name&#125;&#125;` &lt;child name="name"&gt;&lt;/child&gt; &lt;!--需要注意的一点是和&lt;child name="&#123;&#123;name&#125;&#125;"&gt;&lt;/child&gt;的写法不同，不然效果出不来--&gt;&lt;/div&gt;&lt;script&gt; var app = angular.module('app',[]); app.controller('parent',['$scope',function($scope)&#123; $scope.name = "Jhon"; &#125;]); app.directive('child',function()&#123; return &#123; replace:true ,//默认值是false restrict:'EA', scope:&#123;// name:'=' &#125;, template:''+ '&lt;div&gt;'+ '&lt;input type="text" ng-model = "name"/&gt;'+ `'child:&#123;&#123;name&#125;&#125;'`+ '&lt;/div&gt;' &#125; &#125;); //这种情势下的scope作用域是继承且隔离的，子作用域内的变量的改变不会对父作用域内的变量有任何的影响&lt;/script&gt;&lt;/body&gt; 此时template生成的html结构如下 123&lt;div name="name" class="ng-binding ng-isolate-scope"&gt; &lt;input type="text" ng-model="name" class="ng-valid ng-not-empty ng-dirty ng-touched ng-valid-parse"&gt;child:Jhon&lt;/div&gt; 上面这个栗子当时选择的不好，关于name容易混淆，这里在写一个清晰一点的 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang="en"&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body ng-app = 'myApp'&gt;&lt;div ng-controller = 'stuInfoCtrl'&gt; &lt;stu-info info = 'jhon'&gt;&lt;/stu-info&gt; &lt;stu-info info = 'merry'&gt;&lt;/stu-info&gt;&lt;/div&gt;&lt;script src="../libs/angular.js"&gt;&lt;/script&gt;&lt;script&gt; var app = angular.module('myApp',[]); app.controller('stuInfoCtrl',['$scope',function($scope)&#123; $scope.jhon = &#123; name : "Jhon", age : 17 &#125; $scope.merry = &#123; name : "merry", age : 18 &#125; &#125;]); app.directive('stuInfo',function()&#123; return &#123; restrict : 'E', // = 号表示继承父作用域变量，通过这种方式可以将controller中的scope中的属性Jhon merry传递给给info属性,然后可以这里理解: isoleStuInfo = info = $scope.jack scope :&#123; isoleStuInfo : '=info' &#125;, template : '&lt;div&gt;stuName:`&#123;&#123;isoleStuInfo.name&#125;&#125;`&lt;/div&gt;&lt;div&gt;stuAge:`&#123;&#123;isoleStuInfo.age&#125;&#125;`&lt;/div&gt;' &#125; &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 通过以上示例我们这样可以将字符串或者一个对象传入isolate scope中 1.8 transclude属性 表明自定义的指令是否可以被嵌入，配合ng-transclude指令使用 transclude是一个可选的参数。如果设置了,其值必须为true,它的默认值是false。我们可以将整个模板,包括其中的指令通过嵌入全部传入一个指令中。这样做可以将任意内 容和作用域传递给指令。transclude参数就是用来实现这个目的的,指令的内部可以访问外部 指令的作用域,并且模板也可以访问外部的作用域对象。 为了将作用域传递进去,scope参数的值必须通过{}或true设置成隔离作用域。如果没有设 置scope参数,那么指令内部的作用域将被设置为传入模板的作用域 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang="en"&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body ng-app = 'myApp'&gt;&lt;div ng-controller = 'stuInfoCtrl'&gt; &lt;p&gt;this is Jhon&lt;/p&gt; &lt;stu-info ng-transclude&gt; &lt;div&gt;原来的内容jhon&lt;/div&gt; &lt;p&gt;`&#123;&#123;jhon.name&#125;&#125;`&lt;/p&gt; &lt;/stu-info&gt; &lt;p&gt;this is merry&lt;/p&gt; &lt;stu-info ng-transclude&gt; &lt;div&gt;原来的内容merry&lt;/div&gt; &lt;p&gt;`&#123;&#123;merry.name&#125;&#125;`&lt;/p&gt; &lt;/stu-info&gt;&lt;/div&gt;&lt;script src="../libs/angular.js"&gt;&lt;/script&gt;&lt;script&gt; var app = angular.module('myApp',[]); app.controller('stuInfoCtrl',['$scope',function($scope)&#123; $scope.jhon = &#123; name : "Jhon", age : 17 &#125; $scope.merry = &#123; name : "merry", age : 18 &#125; &#125;]); app.directive('stuInfo',function()&#123; return &#123; restrict : 'E', // = 号表示继承父作用域变量，通过这种方式可以将scope中的属性传递给给info属性的方式 transclude : true , scope:&#123;&#125;, template : '&lt;div&gt;模板的内容&lt;/div&gt;' &#125; &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 控制台最终的结果如下: 1234567891011this is Jhon模板的内容原来的内容jhonJhonthis is merry模板的内容原来的内容merrymerry]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[NodeJsFoundation]]></title>
      <url>%2F2016%2F11%2F20%2F126nodeJS%20%2F</url>
      <content type="text"><![CDATA[##1 node.js基础 是建立在Chrome的JavaScript运行时很容易构建快速，可扩展的网络应用程序的平台。 Node.js使用事件驱动，非阻塞I/O模型，使得它重量轻，效率高，完美的跨分布式设备运行数据密集型实时应用。 传统的网络服务技术，是每个新增一个连接（请求）便生成一个新的线程，这个新的线程会占用系统内存，最终会占掉所有的可用内存。而 Node.js 仅仅只运行在一个单线程中，使用非 阻塞的异步 I/O 调用，所有连接都由该线程处理，在 libuv 的加分下，可以允许其支持数万并发连接（全部挂在该线程的事件循环中）。 1Node.js = Runtime Environment + JavaScript Library 1.1 node.js的特性 Node.js库异步和事件驱动 - 所有API异步是非阻塞。 这意味着一个基于Node.js的服务器不会等待API返回数据。 服务器移动到下一个API后调用它，Node.js事件的一个通知机制有助于服务器，以获得从以API调用的响应。 非常快 - 正在构建在谷歌Chrome的V8 JavaScript引擎，Node.js库代码执行是非常快的。 单线程但高度可扩展 - Node.js使用事件循环单线程模型。事件机制有助于服务器在非阻塞的方式作出反应，并使得服务器的高可扩展性，而不是它创建线程限制来处理请求的传统服务器。 Node.js使用单线程的程序和同样的程序处理比传统的服务器要大的多，比如：比Apache HTTP服务器请求服务的数量大得多。 无缓冲 - Node.js的应用从来没有缓冲任何数据。这些应用程序只需输出块中的数据。 许可证 - Node.js是在MIT许可下发布的。 1.2 node.js使用 引入 required 模块：我们可以使用 require 指令来载入 Node.js 模块。 这个是Node.js自带的http模块，然后将其赋值给http变量 1var http = require("http"); 创建服务器：服务器可以监听客户端的请求，类似于 Apache 、Nginx 等 HTTP 服务器。以下代码可以建立一个正常工作的HTTP服务器； 123456789101112131415var http = require('http');//http模块提供的函数:createSever，该函数会返回一个对象，这个对象有一个listen方法，listen方法有一个数值参数，指定 这个HTTP服务器监听的端口号http.createServer(function (request, response) &#123; // 发送 HTTP 头部 // HTTP 状态值: 200 : OK // 内容类型: text/plain response.writeHead(200, &#123;'Content-Type': 'text/plain'&#125;); // 发送响应数据 "Hello World" response.end('Hello World\n');&#125;).listen(8888);// 终端打印如下信息console.log('Server running at http://127.0.0.1:8888/'); 接收请求与响应请求 服务器很容易创建，客户端可以使用浏览器或终端发送 HTTP 请求，服务器接收请求后返回响应数据。 1.3 nodejs组成 核心模块 由node环境提供，比如http fs，url , path等模块 第三方模块，由社区，比如第三方提供，例如gulp browerSync moment等 ##2 npm使用简介 12345678910111213$ npm -v 查看版本号$ npm install &lt;Module name&gt; 安装Node.js的模块的语法格式，比如$ npm install express (本地安装)这个是常用的web框架模块 express$ npm install express -g (全局安装)var express = require("express") ; //安装好之后，express 包就放在了工程目录下的 node_modules 目录中，因此在代码中只需要通过 require('express') 的方式就好，无需指定第三方包路径。$ npm uninstall express //卸载Node.js模块$ npm ls 命令可以查看本地安装的包$ npm ls -g 命令可以查看全局安装的包$ npm search express 可以用来搜索模块$ npm init 可以创建模块，这个模块是你自己的模块，会创建一个package。json文件$ npm publish 可以发布模块，发布以后就可以像其他模块一样使用npm来进行安装比如 创建一个 $ npm init myMoudle 信息填写正确之后$ npm install myModule 可以安装这个模块 Package.json 属性说明 name - 包名。 version - 包的版本号。 description - 包的描述。 homepage - 包的官网 url 。 author - 包的作者姓名。 contributors - 包的其他贡献者姓名。 dependencies - 依赖包列表。如果依赖包没有安装，npm 会自动将依赖包安装在 node_module 目录下。 repository - 包代码存放的地方的类型，可以是 git 或 svn，git 可在 Github 上。 main - main 字段是一个模块ID，它是一个指向你程序的主要项目。就是说，如果你包的名字叫 express，然后用户安装它，然后require(“express”)。 keywords - 关键字 NPM 常用命令除了本章介绍的部分外，NPM还提供了很多功能，package.json里也有很多其它有用的字段。 NPM提供了很多命令，例如install和publish，使用npm help可查看所有命令。 NPM提供了很多命令，例如install和publish，使用npm help可查看所有命令。 使用npm help可查看某条命令的详细帮助，例如npm help install。 在package.json所在目录下使用npm install . -g可先在本地安装当前命令行程序，可用于发布前的本地测试。 使用npm update可以把当前目录下node_modules子目录里边的对应模块更新至最新版本。 使用npm update -g可以把全局安装的对应命令行程序更新至最新版。 使用npm cache clear可以清空NPM本地缓存，用于对付使用相同版本号发布新版本代码的人。 使用npm unpublish @可以撤销发布自己发布过的某个版本代码。 3 Node.js REPL(Read Eval Print Loop) (交互式解释器) 读取 - 读取用户输入，解析输入了Javascript 数据结构并存储在内存中。 执行 - 执行输入的数据结构 打印 - 输出结果 循环 - 循环操作以上步骤直到用户两次按下 ctrl-c 按钮退出。 Node 的交互式解释器可以很好的调试 Javascript 代码。并且可以直接调试node核心模块的代码; 比如下面的一些调试方法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364$ node //可以启动node的终端&gt; url.parse('http://localhost:3000/a/b/c/d?name=Jhon',true)Url &#123; protocol: 'http:', slashes: true, auth: null, host: 'localhost:3000', port: '3000', hostname: 'localhost', hash: null, search: '?name=Jhon', query: &#123; name: 'Jhon' &#125;, pathname: '/a/b/c/d', path: '/a/b/c/d?name=Jhon', href: 'http://localhost:3000/a/b/c/d?name=Jhon' &#125;//使用简单表达式&gt; 3*618//使用变量&gt; var x = 10 undefined //使用var生命的变量可以使用console.log打印出来&gt; console.log(x)&gt; console.log('hello there')&gt; x = 10 10 //没有使用var声明的变量在回车键之后会直接打印出来//多行表达式&gt; var x = 0undefined&gt; do &#123;... x++; //···符号是系统自动生成的，node会自动检测是否是连续的表达式... console.log("x: " + x);... &#125; while ( x &lt; 5 );x: 1x: 2x: 3x: 4x: 5undefined//下划线(_) 变量可以直接获取表达式的运算结果&gt; var x =100undefined //var声明的变量不会直接打印出来&gt; var y = _ // _ 变量可以获取表达式运算的结果undefined //var声明的变量不会直接打印出来&gt; x++ //表达式运算的结果也会直接打印出来100&gt; var y = _ undefined&gt; console.log(y) //打印运算结果100undefined&gt; ++x102&gt; var y = _undefined&gt; console.log(y)102undefined&gt; x+y204&gt; var z = _undefined&gt; console.log(z)204&gt; REPL 命令 ctrl + c - 退出当前终端。 ctrl + c 按下两次 - 退出 Node REPL。 ctrl + d - 退出 Node REPL. 向上/向下 键 - 查看输入的历史命令 tab 键 - 列出当前命令 .help - 列出使用命令 .break - 退出多行表达式 .clear - 退出多行表达式 .save filename - 保存当前的 Node REPL 会话到指定文件 .load filename - 载入当前 Node REPL 会话的文件内容。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Transform]]></title>
      <url>%2F2016%2F11%2F19%2F19-transform(3d)%EF%BC%9A%2F</url>
      <content type="text"><![CDATA[Transform(3d)：x轴向右是正方向，y轴向下是正方向，z轴垂直向外是正方向；注意transform:rotate(angle)，可以使元素发生旋转，发生旋转之后的元素，其对应的 x y z的方向指向会发生变化，本文重点讲解； 在设置transition的前提下，transform变换才会有类似动画的效果 一：首先看一些有关3d的常用属性： transform-origin：参数1 参数2 设置对象的围绕的旋转中心，默认值是50% 50% 参数1 取值：百分比 基准是元素自身宽度，length 值，left center right 分别旋转中心是水平方向的左边界 居中 和右边界 参数2 取值：百分比 基准是元素自身高度，length 值，top center bottom 分别旋转中心是水平方向的左边界 居中 和右边界 如果第二个值没有设置默认是50%； transform-style:flat | preserve-3d 默认是flat 指定某元素的子元素是（看起来）位于三维空间内，还是在该元素所在的平面内被扁平化。只有在设置该属性值为preserve-3d的时候，才会有rotatex rotatey rotatez属性值，因为在2d里面只有rotate 当该属性值为「preserve-3d」时，元素将会创建局部堆叠上下文。决定一个变换元素看起来是处在三维空间还是平面内，需要该元素的父元素上定义 &lt;’ transform-style ‘&gt; 属性。 perspective ：none |length 默认是none 指定某元素距离浏览器窗口的垂直于浏览器窗口的距离，当length&gt;0 的时候，会使得元素看起来比实际要大，length&lt;0 的时候，会使得元素看起来比实际要小。 translate3d(x,y,z )三个参数不允许省略； 二 老司机带带我，不要走错路 transform: rotate(angle) translate(length | percentage)之间的关系。translate的百分比取值元素自身的宽(x)和高(y)来确定移动的距离。 1 明确浏览器的解析过程，从上到下 从左到右 2 明确rotate()会使坐标也跟着旋转 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang="en"&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; img &#123; /*transform: translateX(1000px) translateY(500px) rotateZ(90deg);*/ transform: translateX(1000px) rotateZ(90deg) translateX(500px); &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;img src="img/car.jpg" alt="" /&gt;&lt;/body&gt;&lt;/html&gt; 代码执行过程1： transform: translateX(1000px) translateY(500px) rotateZ(90deg); 对应的图片如下：执行过程是先向x轴正方向移动1000px，在向y轴正方向移动500px,然后图片围绕元素中心旋转90deg。 执行完之后是 代码执行2 transform: translateX(1000px) rotateZ(90deg) translateX(500px); 最初状态是 图xy1 先向x轴正方向移动1000px 然后执行rotateZ(90deg),此时图片变换为 图xy2 所以这一步还是对应translateX(500px)来移动飞车。 注意：一般建议将旋转放在最后。不过还是眼看项目实际需求来 三 撸一段动画大家体验下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang="en"&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; img &#123; width: 200px; &#125; @keyframes autoMove&#123; 20%&#123; /*0~40%的时候的变换过程,初始默认x向右 y向下 z垂直向外*/ transform:translatex(1000px) &#125; 25%&#123; /*40%~50%的时候的变换过程*/ transform: translatex(1000px) rotatez(90deg); &#125; 50%&#123; /*50%~90%时候的变换过程*/ transform: translatex(1000px) translatey(500px) rotatez(90deg) ; &#125; 55%&#123; /*注意每次的变化都是在上一次的基础上进行变化*/ transform:translatex(1000px) translatey(500px) rotatez(180deg); &#125; 75% &#123; transform:translatex(0px) translatey(500px) rotate(180deg); &#125; 80% &#123; transform: translatex(0px) translatey(500px) rotate(270deg); &#125; 95% &#123; transform: translatex(0px) translatey(0px) rotate(270deg); &#125; 100%&#123; transform:translatex(0px) translatey(0px) rotate(360deg); &#125; &#125; .autoMove&#123; animation:autoMove 5s linear ; &#125; /*注意，每次动画都要保持上一步动画的结果，才能继续进行动画，如果不保持上一步动画的结果，那么会导致动画回归到原来的值*/ &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;img src="img/car.jpg" alt="" class="autoMove"/&gt;&lt;/body&gt;&lt;/html&gt; 1 建议将每个阶段的动画注释掉，看下效果。 2 旋转的效果都是放在了最后，避免混乱。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[AngularJsService]]></title>
      <url>%2F2016%2F11%2F17%2F165AngularJsService%2F</url>
      <content type="text"><![CDATA[文墨(末)有彩蛋00哦 1 先来了解以下angular的依赖Module依赖：在声明app模块时，需要给出依赖模块的列表。同时这些模块对应的JS需要在HTML中加以引入。在中可以直接使用依赖模块中声明的Service、Directive、Filter。 Service依赖：在声明Controller、Service、Directive、Filter的工厂方法中，把依赖的Service直接放到参数列表，Angular Injector会为你生成这些Service的实例。 1.1 Services 定义AngularJS services are substitutable objects that are wired together using dependency injection (DI). You can use services to organize and share code across your app. AngularJS services are: Lazily instantiated – AngularJS only instantiates a service when an application component depends on it. Singletons – Each component dependent on a service gets a reference to the single instance generated by the service factory. service通常用来进行不同的controller之间进行通信; 1.2 service声明方式 $provider 下面有五个API factory service value constant provider(这些都是provider的封装) 可以用来声明服务1.2.1 最常见的方式：工厂方式,当someService作为依赖的时候，angular Injector会调用工厂方法，然后将返回值作为Service的实例传入依赖它的工厂方法 factory(name, fn)registers a service factory function that will be wrapped in a service provider object, whose $get property will contain the given factory function. 123456app.factory('someService', function(dependency1, ...)&#123; return &#123; property1: value1, property2: value2 &#125;&#125;); 走个小栗子 12345678910111213141516171819202122232425&lt;body ng-app = 'myApp'&gt;&lt;div ng-controller="myCtrl"&gt; &lt;input type="text" ng-model = 'info.name' placeholder="please input your name"/&gt; name:&lt;p&gt;`&#123;&#123;info.name&#125;&#125;`&lt;/p&gt; &lt;input type="text" ng-model = 'info.age' placeholder="please input your age"/&gt; age:&lt;p&gt;`&#123;&#123;info.age&#125;&#125;`&lt;/p&gt;&lt;/div&gt;&lt;script&gt; var myApp = angular.module('myApp',[]); myApp.factory('myService',function()&#123; return &#123; name : "Jhon", age : 18, &#125; &#125;); myApp.controller('myCtrl',["$scope","myService",function($scope,myService)&#123; console.log(arguments); $scope.info = myService ; &#125;]); &lt;/script&gt;&lt;/body&gt; 1.2.2 最直接的方式：构造函数 当someService作为依赖的时候，angular Injector会以new的方式调用该构造函数，然后将返回值作为Service的实例传入依赖它的工厂方法 service(name, Fn) registers a constructor function that will be wrapped in a service provider object, whose $get property will instantiate a new object using the given constructor function. 我们可以定义私有变量和共有变量 先来看下内部实现机制,angular Injector会以new的方式调用构造函数，然后将返回值传入依赖； 1234567891011121314151617181920&lt;script&gt; function Service ()&#123; this.public = &#123; name : "Jhon", age :18 &#125; var private = &#123; name :"JiM", age : 20 &#125; this.getPri = function()&#123; return private ; &#125; &#125; var service = new Service(); console.log(service); console.log(service.getPri()); &lt;/script&gt; 1234app.service('someService', someService(dependency1, ...)&#123; this.property1 = value1; this.property2 = value2;&#125;); 1234567891011121314151617181920212223242526272829303132&lt;body ng-app = 'myApp'&gt;&lt;div ng-controller="myCtrl"&gt; &lt;input type="text" ng-model = 'info.name' placeholder="please input your name"/&gt; public name:&lt;p&gt;`&#123;&#123;info.name&#125;&#125;`&lt;/p&gt; &lt;input type="text" ng-model = 'info.age' placeholder="please input your age"/&gt; public age:&lt;p&gt;`&#123;&#123;info.age&#125;&#125;`&lt;/p&gt; private name : &lt;p&gt;`&#123;&#123;infoPri.name&#125;&#125;`&lt;/p&gt; private name : &lt;p&gt;`&#123;&#123;infoPri.age&#125;&#125;`&lt;/p&gt;&lt;/div&gt;&lt;script&gt; var myApp = angular.module('myApp',[]); myApp.service('myService',function()&#123; this.public = &#123; name : "Jhon", age :18 &#125; var private = &#123; name :"JiM", age : 20 &#125; this.getPri = function()&#123; return private ; &#125; &#125;); myApp.controller('myCtrl',["$scope","myService",function($scope,myService)&#123; console.log(arguments); $scope.info = myService.public ; $scope.infoPri = myService.getPri(); &#125;]);&lt;/script&gt;&lt;/body&gt; 1.2.3 最简单的方式 value(name, value);Register a value service with the $injector, such as a string, a number, an array, an object or a function. This is short for registering a service where its provider’s $get property is a factory function that takes no arguments and returns the value service. That also means it is not possible to inject other services into a value service. Value services are similar to constant services, except that they cannot be injected into a module configuration function (see angular.Module) but they can be overridden by an AngularJS decorator. constant(name, value);Register a constant service with the $injector, such as a string, a number, an array, an object or a function. Like the value, it is not possible to inject other services into a constant. But unlike value, a constant can be injected into a module configuration function (see angular.Module) and it cannot be overridden by an AngularJS decorator. 两者的相同之处就是不能依赖其他的service, 两者的不同之处就是value不能注册进其他模块，但是constant可以被注册进其他模块 两者的不同之处还有就是value可以被decorator重写，但是constant不能被重写，constant常量的意思 123app.value('someService', &#123; property1: value1, property2: value2&#125;);app.constant('anotherService', 'I am a simple string'); decorator(name, decorator);Register a decorator function with the $injector. A decorator function intercepts the creation of a service, allowing it to override or modify the behavior of the service. The return value of the decorator function may be the original service, or a new service that replaces (or wraps and delegates to) the original service. You can find out more about using decorators in the decorators guide.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Angular Js MVVM 双向数据绑定如何实现]]></title>
      <url>%2F2016%2F11%2F17%2F174Angular-Js-MVVM-%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%2F</url>
      <content type="text"><![CDATA[1 我们先来看一个简单的双向数据绑定的demo1.1点击按钮，数据的变化会实现在页面上显示出来 123456789101112131415161718&lt;body ng-app = "myApp"&gt;&lt;div ng-controller = 'myCtrl' &gt; &lt;p ng-bind = 'count'&gt;&lt;/p&gt; &lt;sapn ng-click =' increase() ' &gt;icrease&lt;/sapn&gt;&lt;/div&gt;&lt;script src="../libs/angular.js"&gt;&lt;/script&gt;&lt;script&gt; var app = angular.module('myApp',[]); app.controller('myCtrl',['$scope',function($scope)&#123; $scope.count = 1 ; $scope.increase = function()&#123; $scope.count++; &#125; &#125;]) &lt;/script&gt;&lt;/body&gt; 1.2 angular底层是如何实现这种数据的双向绑定的呢？(参阅angular沉思录) 铺垫一点基础知识 1234567891011121314&lt;body&gt;&lt;button ng-click = 'inc1' id = 'btn'&gt;increase&lt;/button&gt;&lt;/body&gt;&lt;script&gt; var ret = document.querySelector('#btn').getAttribute('ng-click'); console.log(ret);//inc1 console.log(typeof ret);//string console.log(window[ret]);//function inc1()&#123;&#125;函数 window[ret]();//inc1被执行了 function inc1 ()&#123; //这个相当于给window对象添加一个属性，属性名是 inc1 counter++ ; console.log('inc1倍执行了'); &#125;&lt;/script&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8" /&gt; &lt;title&gt;two-way binding&lt;/title&gt;&lt;/head&gt;&lt;body onload="init()"&gt;&lt;button ng-click="inc"&gt; increase 1&lt;/button&gt;&lt;button ng-click="inc2"&gt; increase 2&lt;/button&gt;&lt;span style="color:red" ng-bind="counter"&gt;&lt;/span&gt;&lt;span style="color:blue" ng-bind="counter"&gt;&lt;/span&gt;&lt;span style="color:green" ng-bind="counter"&gt;&lt;/span&gt;&lt;script type="text/javascript"&gt; /* 数据模型区开始 */ var counter = 0; function inc() &#123; console.log("1"); counter++; &#125; function inc2() &#123; console.log("2"); counter+=2; &#125; /* 数据模型区结束 */ /* 绑定关系区开始 */ function init() &#123; bind(); &#125; function bind() &#123; var list = document.querySelectorAll("[ng-click]"); for (var i=0; i&lt;list.length; i++) &#123; list[i].onclick = (function(index) &#123; return function() &#123; window[ list[index].getAttribute("ng-click") ]();//inc函数会执行 apply(); &#125;; &#125;)(i); &#125; &#125; function apply() &#123; var list = document.querySelectorAll("[ng-bind='counter']"); for (var i=0; i&lt;list.length; i++) &#123; list[i].innerHTML = counter; &#125; &#125; /* 绑定关系区结束 */&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 2 angular中的\$apply \$digest首先我们来看下它们的作用，当我们在angularjs之外的上下文改变了model的时候，如何让angular进行页面的刷新呢？ 1234567891011121314151617181920212223&lt;body ng-app="test"&gt;&lt;div ng-controller="CounterCtrl"&gt; &lt;button myclick&gt;increase&lt;/button&gt; &lt;span ng-bind="counter"&gt;&lt;/span&gt;&lt;/div&gt;&lt;/body&gt;&lt;script src="../libs/angular.js"&gt;&lt;/script&gt;&lt;script&gt; var app = angular.module("test", []); app.directive("myclick", function() &#123; return function (scope, element, attr) &#123; element.on("click", function() &#123; scope.counter++; console.log(scope.counter); &#125;); &#125;; &#125;); app.controller("CounterCtrl", function($scope) &#123; $scope.counter = 0; &#125;);&lt;/script&gt; 这个时候我们是通过javascript处理函数改变了scope的counter值，此时会发现view视图上并不会跟随变化，但是控制打印出来的却是变化了的值。这是因为 angularjs只负责发生在angularjs上下文中的对于models 的更改会做出自动的回应(也就是$apply方法中对于model的更改orangular内置的其他服务) 对于angular上下之外的其他地方修改的model,这个时候就需要手动调用$apply来触发一轮\$digest检测 build-in的一些 ng-event指令以及ng-model $timeout \$interval 等都会自动触发一次\$digest循环 $timeout(fn,delay,optional,pass) 第一个参数是执行函数，第二参数是延迟时间，第三个参数是是否进行脏值检测，默认是true,如果设置为false，则model数据的更新不会在视图上同步，pass是传递到执行函数的参数 1234567891011121314151617181920212223&lt;body ng-app = 'myApp' &gt; &lt;div ng-controller="myController"&gt; &lt;p&gt;&#123;&#123;clock&#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;script src="../libs/angular.js"&gt;&lt;/script&gt; &lt;script&gt; var app = angular.module('myApp',[]); app.controller('myController',['$scope','$timeout',function($scope,$timeout)&#123; var updateClock = function() &#123; $scope.clock = new Date(); $timeout(function() &#123; updateClock(); &#125;, 1000,false);//如果设置为false，发现不会model数据会更新，但是不会反应在view视图上 console.log($scope.clock); &#125;; updateClock(); &#125;]); &lt;/script&gt;&lt;/body&gt; $interval(fn,delay,count,optional,pass) 第一个参数是执行函数，第二个参数是延迟时间，第三个参数是fn执行的次数，第四个参数表示是否进行脏值检测，第五个蚕食表示传递的参数 1234567891011121314151617181920&lt;body ng-app = 'myApp' &gt; &lt;div ng-controller="myController"&gt; &lt;p&gt;&#123;&#123;clock.now&#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;script src="../libs/angular.js"&gt;&lt;/script&gt; &lt;script&gt; var app = angular.module('myApp',[]); app.controller('myController',['$scope','$interval',function($scope,$interval)&#123; $scope.clock = &#123; now : new Date() &#125; $interval(function()&#123; $scope.clock.now = new Date(); &#125;,1000,5);//5表示fn只会循环5次，如果不设置，则会无限循环，后面还可以设置false参数，表示不会进行脏检 &#125;]) &lt;/script&gt;&lt;/body&gt; 以上代码指令自定义可以变成以下三种方式 12345678910app.directive("myclick", function() &#123; return function (scope, element, attr) &#123; element.on("click", function() &#123; scope.counter++; scope.$digest(); // scope.$apply(); //不推荐这种写法 console.log(scope.counter); &#125;); &#125;; &#125;); or 123456789101112app.directive("myclick", function() &#123; return function (scope, element, attr) &#123; element.on("click", function() &#123; scope.counter++; scope.$apply(function() &#123; scope.counter++; &#125;); console.log(scope.counter); &#125;); &#125;; &#125;); 此时会发现view视图会随着model的改变实时更新了 再来个栗子 123456789101112131415161718192021222324&lt;body ng-app = 'myApp'&gt;&lt;div ng-controller = 'myCtrl'&gt; &lt;p ng-modle = 'name'&gt;&#123;&#123;name&#125;&#125;&lt;/p&gt; &lt;input type="text" ng-model = 'name'/&gt; &lt;p&gt;&#123;&#123;name&#125;&#125;&lt;/p&gt; &lt;p&gt;&#123;&#123;age&#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;script src="../libs/angular.js"&gt;&lt;/script&gt;&lt;script&gt; var app = angular.module('myApp',[]);app.controller('myCtrl',['$scope',function($scope)&#123; $scope.setInfo = function()&#123; setTimeout(function()&#123; $scope.$apply(function()&#123; $scope.name = 'Jhon'; $scope.age = 19; &#125;) &#125;,2000) &#125; $scope.setInfo(); &#125;])//两秒后，会显示修改的scope内容&lt;/script&gt;&lt;/body&gt; 1234567891011app.controller('myCtrl',['$scope',function($scope)&#123; $scope.setInfo = function()&#123; setTimeout(function()&#123; $scope.name = 'Jhon'; $scope.age = 19 ; $scope.$apply(); &#125;,2000); &#125; $scope.setInfo(); console.log($scope); &#125;]) 3 angular中的 $ watch在上面的情况中，我们通过$apply \$digest函数的调用就可以将model模型上的数据变化实时反应在view层上，但是我们有没有思考为什么会model层的改变会实时显示在view层呢？这个时候就是watch的主要作用了当我们写下表达式，比如 的时候，angularjs在幕后为我们做了一件事情， 1234$scope.$watch('somevalue',function()&#123; console.log(arguments);//oldValue newValue scope //这里实现更新view的逻辑，model层的数据变化实时更新到view层&#125;) 也就是说，底层原理来讲是$watch回调函数的调用来执行的实时的数据更新，那么angularjs是怎么知道什么时候去调用这个回调函数呢？先抛出这个问题，看下这个demo， 这种情况是scope模型上的数据改变了但是没有触发watch函数的情况，因为我们没有进行脏值检测$digest或者\$apply 1234567891011121314151617181920212223242526&lt;body ng-app = 'myApp'&gt; &lt;div ng-controller = 'myCtrl'&gt; &lt;p&gt;&#123;&#123;age&#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;script src="../libs/angular.js"&gt;&lt;/script&gt; &lt;script&gt; var app = angular.module('myApp',[]); app.controller('myCtrl',['$scope',function($scope)&#123; $scope.age = 19 ; $scope.change = function()&#123; setInterval(function()&#123; $scope.age++; console.log("1"); console.log($scope.age); &#125;,2000) &#125; $scope.change(); $scope.$watch('age',function()&#123; console.log(arguments);//看下回调函数的参数 console.log("age变化触发了我的出现"); &#125;) &#125;]) &lt;/script&gt;&lt;/body&gt; 控制台会循环输出 1 和 age的递增 ； 这个时候我们就需要思考了？通过什么方式触发$watch呢？修改change函数 1234567$scope.change = function()&#123; setInterval(function()&#123; $scope.$apply(function()&#123; $scope.age++ ; &#125;) &#125;,2000)&#125; 这个时候我们会发现控制台会循环执行watch函数]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[get and set]]></title>
      <url>%2F2016%2F11%2F13%2F136GetAndSet%2F</url>
      <content type="text"><![CDATA[1 设置对象的属性，Object.definedProperty(obj.prop,descriptor) 12345678//第一种方式var obj= &#123;&#125;;Object.defineProperty(obj,"name",&#123; configurable:true, enumerable : false, value:"Jhon", writable:true, &#125;); 123456789101112//第二种方式var obj= &#123;&#125;;Object.defineProperty(obj,"name",&#123; configurable:true, enumerable : false, get : function()&#123; return "JiM"; &#125; set:function()&#123; &#125;&#125;); 2 一个属性的descriptor可能由以下组成 value writable configurable emuerable get set , descriptor是一个属性的详细信息描述的对象； 1234567//通过键值对的方式直接设置对象的属性const obj = &#123; foo:'bar', &#125;;var descriptors = Object.getOwnPropertyDescriptors(obj);console.log(descriptors);//foo属性的descriptor对象的详细信息console.log(obj); 1234567891011121314151617181920//通过get set方法可以直接给对象设置属性以及设置属性值，大致了解下get和set的作用，以及对obj对象的属性改变const obj = &#123; get foo() &#123; return 'bar'; &#125;, get foo1() &#123; return 'bar1'; &#125;, get foo2()&#123; return 'bar2' &#125;&#125;;var descriptors = Object.getOwnPropertyDescriptors(obj);console.log(descriptors);console.log(obj);console.log(obj.foo);//barconsole.log(obj.foo1);//bar1console.log(obj.foo2);//bar2obj.foo = 'bar4';//不会修改foo属性的值console.log(obj.foo);//bar 3 set方法可以用来设置属性的值，get可以用来获取属性的值，来个栗子感受下 123456789101112131415161718var test = &#123; _Name : "Lilei", _Age : 20, //_Name的只读 get name() &#123;return this._Name;&#125;, //通过//_Age的读写 set age(age) &#123;this._Age = age;&#125;, get age() &#123;return this._Age;&#125; &#125; console.log(test);//可以查看obj对象的所有属性，加深理解var descriptors = Object.getOwnPropertyDescriptors(obj);console.log(descriptors);//查看obj对象的所有属性的descriptor对象//------------------------------------------------console.log(test.name + " " + test.age);//Lilei 20 test.name = 'Lily'; test.age = 18; console.log(test.name + " " + test.age);//Lilei 18 console.log(test._Name + " " + test._Age);//Lilei 18 _Name 只读，只写了_Age属性]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[transition transform 效果进阶1 body如何渐变色填充]]></title>
      <url>%2F2016%2F11%2F12%2F05transition%20%20transform%20body%E6%B8%90%E5%8F%98%E8%89%B2%E5%A1%AB%E5%85%85%2F</url>
      <content type="text"><![CDATA[transition transform 效果进阶1 body如何渐变色填充 一 transition的拆分写 明确其拥有的四个属性值 transition-property 发生渐变效果的属性 transition-duration 完成过渡效果的时间 transition- timing-function 完成过渡效果的动画效果 linear ease ease-in ease-out step-start= step(1 ,start) step-end=step(1,end) steps( n1,n2),n1代表完成的步数，n2代表start或者end ,指定每一步的值发生变化的时间点。第二个参数是可选的，默认值为end。 transition-deplay 开始进行过渡效果的延迟 transition 属性连写 transition : all 2s ease-in 1s all 代表所有的属性都会有过渡效果，只要设置了，2s代表一个过渡效果的时间，ease-in 代表过渡的方式，1s代表延迟 二 transform属性(2d)(x 正方向水平向右，y正方向垂直向下，z正方向在垂直于窗口向外) translate(x,y ) 指定对象移动，基准是父盒子左上角，移动 x y z是代表距离左上角的距离translatex(length|percentage),translatey(number)指定x y的移动距离。如果第二个参数省略，那么默认为0 ；其中百分比的基准是以元素自身的宽高为基准，然后乘以百分比，得到移动的距离值。 ​ transform：translate(50px,40px)代表向右和向下移动50px 40px； scale(x,y) ,代表指定对象缩放比例，x，y分别对应x y轴的缩放。scalex(number) scaley(number),如果第二个参数省略默认和第一个参数相等。 rotate(angle) 输入角度值，代表元素2d的旋转角度 需要有个transition-origin属性。关于旋转的方向：遵循“左手定则”大拇指指向轴的正方向，四指的方向就是旋转的方向，也是角度值为正的方向;rotate(angle),默认以z轴为基准进行旋转，rotatex(angel)，rotatey(angle),rotatez(angle) 以x和y轴为基准进行旋转(3D)。注意在3d里面才有rotatex(angel)，rotatey(angle),rotatez(angle)，在2d里面只有rotate(angle) skew(x,y) 指定x y的扭曲距离。如果第二个参数省略，那么默认为0 ;skewx(number) skewy(number). 三 : 有关body的渐变色填充问题： ​ body默认是没有高度的，但是却可以直接给body设置背景颜色，这是为什么呢?好多人会问，不是应该元素有了宽高才能有背景色吗？ 这里明确一点，body设置背景色是浏览器自动配置的，如果直接给body设置背景色，默认全部填充整个文档；即使body的高度是默认的高度。 走个小demo理解下这个问题、 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; body &#123; background-color: blue; /* background: linear-gradient(to bottom,rgba(0,0,255,0.1),rgba(0,0,255,0.5),rgb(0,0,255));*/ &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 1234body &#123; background: linear-gradient(tobottom,rgba(0,0,255,0.1),rgba(0,0,255,0.5),rgb(0,0,255)); &#125; 给body一个高度： ​ height:100px ; 我们会发现的问题是：纯色填充body没有问题，那么如何解决渐变填充body这种情况呢？ 很简单， 123html,body &#123; height :100% ;&#125; 四 ，写个demo玩一下： 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; html,body&#123; height: 100%; margin: 0; &#125; body&#123; background: linear-gradient(to bottom,rgba(0,0,255,0.1),rgba(0,0,255,0.5),rgb(0,0,255)); box-sizing:border-box; &#125; .fish &#123; width: 174px; height: 126px; background:url(img/fish.png) no-repeat; /*border: 1px solid #000;*/ transition: all 2s linear; &#125; body:hover .fish&#123; transform:translate(1000px,500px) rotate(45deg) scale(.5,.5); &#125; /*背景图片默认左上角平铺，然后改变背景图片的位置即可*/ .animation &#123; animation: autoMove 1s steps(8) infinite; &#125; /*动画关键字 */ @keyframes autoMove &#123; from &#123;&#125; to &#123; background-position: 0 -1008px; &#125; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="fish animation"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[AngularJsInitialization]]></title>
      <url>%2F2016%2F11%2F10%2F157AngularJS-Initialization%2F</url>
      <content type="text"><![CDATA[1 angularJs初始化应用模块有两种方式 1.1、绑定初始化，自动加载 通过绑定来进行angular的初始化，会把js代码侵入到html中。 ng-app是angular的一个指令，代表一个angular应用（也叫模块）。使用ng-app或ng-app=””来标记一个DOM结点，让框架会自动加载。也就是说，ng-app是可以带属性值的。如果没有ng-app指令将会报错； 自动初始化流程如下 ng-app 指令定义了 AngularJS 应用程序的 根元素 AngularJS 在 HTML DOMContentLoaded 事件后会自动引导（自动初始化）应用程序。如果找到 ng-app 指令 ， AngularJS 载入指令中的模块，然后创建应用的注入器，并将 ng-app 作为应用的根进行编译。同时，启动应用的时候，会在其子元素范围内构成一个$scope; 应用的根可以是整个页面，或者页面的一小部分，如果是一小部分会更快编译和执行。 AngularJS initializes automatically upon DOMContentLoaded event or when the angular.js script is evaluated if at that time document.readyState is set to &#39;complete&#39;. At this point AngularJS looks for the ngApp directive which designates your application root. If the ngApp directive is found then AngularJS will: load the module associated with the directive. create the application injector compile the DOM treating the ngApp directive as the root of the compilation. This allows you to tell it to treat only a portion of the DOM as an AngularJS application. 1234567891011121314通过控制体controller进行数据绑定&lt;body ng-app = 'Demo'&gt; &lt;div ng-controller = 'DemoCtrl'&gt; `&#123;&#123;a&#125;&#125;+&#123;&#123;b&#125;&#125; = &#123;&#123;a+b&#125;&#125;`&lt;/div&gt;&lt;script&gt; //如果要对angular应用添加控制器，那么必须关联Demo到module模块，如果不关联那么则会提示没有 //The controller with the name 'xxx' is not registered. angular.module('Demo',[]).controller('DemoCtrl',['$scope',function($scope)&#123; $scope.a = 1 ; $scope.b = 2 ; &#125;]);&lt;/script&gt;&lt;/body&gt; 1234567891011121314通过run方法进行数据绑定，这个只能提供全局的变量&lt;body ng-app = 'Demo'&gt;&lt;div &gt; `&#123;&#123;a&#125;&#125;+&#123;&#123;b&#125;&#125; = &#123;&#123;a+b&#125;&#125;`&lt;/div&gt;&lt;script&gt; var myapp = angular.module('Demo',[]); console.log(myapp); myapp.run(function($rootScope)&#123; $rootScope.a = 1 ; $rootScope.b = 2 ; &#125;)&lt;/script&gt;&lt;/body&gt; 1234通过ng-init初始化数据&lt;div ng-app ng-init='name = "Jhon"'&gt; &lt;div ng-bind="name"&gt;&lt;/div&gt;&lt;/div&gt; ng-app指令作用如下 There are a few things to keep in mind when using ngApp: only one AngularJS application can be auto-bootstrapped per HTML document. The first ngApp found in the document will be used to define the root element to auto-bootstrap as an application. To run multiple applications in an HTML document you must manually bootstrap them using angular.bootstrap instead. AngularJS applications cannot be nested within each other. Do not use a directive that uses transclusion on the same element as ngApp. This includes directives such as ngIf, ngIncludeand ngView. Doing this misplaces the app $rootElement and the app’s injector, causing animations to stop working and making the injector inaccessible from outside the app. You can specify an AngularJS module to be used as the root module for the application. This module will be loaded into the $injectorwhen the application is bootstrapped. It should contain the application code needed or have dependencies on other modules that will contain the code. See angular.module for more information. 1.2 当同一个页面中包含多个app的时候(不能嵌套)，这个时候angular就不能自动启动应用，需要我们用bootstrp手动启动应用 手动初始化一个angular应用模块,可以使用angular.bootstrap()，该方法可以初始化一个angularjs应用，注意该方法不会创建模块，我们在将模块作为参数传递之前必须先创建了一个模块或者已经先加载了一个模块 1angular.bootstrap(element, [modules], [config]); 其中第一个参数element:是绑定ng-app的dom元素；modules：绑定的模块名字config：附加的配置 123456789101112131415161718&lt;body &gt;&lt;div ng-controller = 'DemoCtrl'&gt; ` &#123;&#123;a&#125;&#125;+&#123;&#123;b&#125;&#125; = &#123;&#123;a+b&#125;&#125; `&lt;/div&gt;&lt;script&gt; angular.module('Demo',[]).controller('DemoCtrl',['$scope',function($scope)&#123; $scope.a = 1 ; $scope.b = 2 ; &#125;]); //页面加载完毕之后在进行初始化模块 angular.element(document).ready(function()&#123; angular.bootstrap(document,['Demo']); //angular.bootstrap(document.body,['Demo']) //上面两行代码绑定同一个模块会报错，只能存在一个 &#125;)&lt;/script&gt;&lt;/body&gt; 1234567891011121314151617181920212223242526&lt;html&gt;&lt;head&gt; &lt;script src="angular.js"&gt;&lt;/script&gt; &lt;script&gt; // 创建moudle1 var rootMoudle = angular.module('moudle1', []); rootMoudle.controller("controller1",function($scope)&#123;$scope.name="aty"&#125;); // 创建moudle2 var m2 = angular.module('moudle2', []); m2.controller("controller2",function($scope)&#123;$scope.name="aty"&#125;); // 页面加载完成后,再加载模块 angular.element(document).ready(function() &#123; angular.bootstrap(document.getElementById("div1"),["moudle1"]); angular.bootstrap(document.getElementById("div2"),["moudle2"]); //绑定不同的模块是可以的 &#125;); &lt;/script&gt;&lt;head&gt;&lt;body&gt;&lt;div id="div1" ng-controller="controller1"&gt;div1:`&#123;&#123;name&#125;&#125;`&lt;/div&gt;&lt;div id="div2" ng-controller="controller2"&gt;div2:`&#123;&#123;name&#125;&#125;`&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 1.3 一个ng-app所在的标签就是一个angular应用，该标签下的所有子标签会被angular编译，不是其子标签的话不会被angular编译 12345678910111213141516171819&lt;body&gt;&lt;div ng-app = 'app' ng-controller = 'myCtrl'&gt; &lt;div&gt;`&#123;&#123;name&#125;&#125;`&lt;/div&gt; &lt;div&gt;`&#123;&#123;age&#125;&#125;`&lt;/div&gt;&lt;/div&gt; &lt;div&gt;`&#123;&#123;age&#125;&#125;`&lt;/div&gt;&lt;!--初始化ng-app，那么ng-app标签下面的子标签就是整个应用，其他的就不是angular应用，然后angular不会编译其余的标签第二个age不会被angular编译，因此不会被显示19，只会显示&#123;&#123;age&#125;&#125;--&gt;&lt;script&gt; var app = angular.module('app',[]); app.controller('myCtrl',['$rootScope','$scope',function($scope,$rootScope)&#123; $rootScope.name = "Jhon"; $scope.age = 19 ; &#125;]);&lt;/script&gt;&lt;/body&gt; 1.4注意 ng-app和angular.bootstrap不能同时使用 ng-app只能出现一次，所以就只能出现一个angularjs应用，但是angular.bootstrap可以出现多次，但是这种做法是不推荐的 二者初始化的一个应用的时候，所在元素的不能有ngIf ngView ngInclude指令 ng-app所在的标签的就是一个angular应用，该标签下面的所有的子标签都会被angular编译，不是该标签的子标签不会被angular编译 初始化angular应用之后可以进行创建模块以及控制器、服务等其他操作 初始化的angular应用里面的表达式会被编译，编译之后的表达式会按照angular的规定进行解析，如果没有ng-app指令或者bootstrap手动初始化angular应用，则表达式不会进行运算，将直接显示出来 HTML5 允许扩展的（自制的）属性，以 data- 开头。AngularJS 属性以 ng- 开头，但是您可以使用 data-ng- 来让网页对 HTML5 有效。 AngularJS 表达式 与 JavaScript 表达式 类似于 JavaScript 表达式，AngularJS 表达式可以包含字母，操作符，变量。 与 JavaScript 表达式不同，AngularJS 表达式可以写在 HTML 中。 与 JavaScript 表达式不同，AngularJS 表达式不支持条件判断，循环及异常。 与 JavaScript 表达式不同，AngularJS 表达式支持过滤器。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Javscript中this详解]]></title>
      <url>%2F2016%2F11%2F04%2F87-Javscript%E4%B8%ADthis%E8%AF%A6%E8%A7%A3%2F</url>
      <content type="text"><![CDATA[Javscript中this详解一 宿主环境和javascript 引擎 宿主环境：一门语言在运行的时候需要一个环境，这个环境就是宿主环境，对于JavaScript来说宿主环境就是我们常说的浏览器，在这个浏览器里面提供了一些借口让javascript引擎可以和宿主环境对接； jacascript引擎才是真正执行代码的地方，常见的javascript引擎包括V8，javascript core,javascript引擎主要做了以下几件事情:一套与宿主环境相互联系的规则，javascript引擎内核，规定了基本javascript语法逻辑和命令，一组内置对象和API javascript不仅可以在浏览器里面运行，还可以在其他宿主环境，比如node.js 二 this详解1 global this1.1在浏览器里面，全局范围内，this等价于window对象(其实window对象也是Window构造函数的实例) 12345console.log(this === window);//true 全等号还是返回true this.name = "jhon"; console.log(window.name);//jhon window.age = 13 ; console.log(this.age);//13 1.2 在浏览器中，在全局范围内，用var声明一个变量和给this window 设置属性是等价的 123var foo = "bar"; console.log(this.foo);//bar console.log(window.foo);//bar 1.2.1 预解析对顶级对象window的属性的添加 1234567console.log(window.exp); //由于预解析 var exp ;会被提升到最上部，声明的对象未被定义的话，默认为undefinedif (exp in window)&#123; // 返回true; //in 操作符，可以用来判断某个对象是否拥有某个属性，可以追溯对象所有的属性，包括原型上的; var exp = "example";//会进行预解析，声明exp属性给到window,解析到这一行代码的时候，会进行赋值 //明确预解析:所谓预解析是浏览器的动作，它会在执行javascript代码之前，全局的检索javascript代码，将变量声明以及函数声明提升到函数的额最顶部，所以，变量声明提升的时候，相当于给window对象添加了一个属性 console.log(window.exp);//example &#125; 1.2.2 用function声明函数和在全局用var 声明变量，或者函数体不用var声明变量，都是在给全局的window添加属性值 123456789&lt;script&gt; var amyName; // window 对象会多一个amyName 属性 a ; function anewBuilder()&#123; //window对象会多一个anerBuilder属性 aaa = 1; //函数执行后 ，window对象又会多一个aaa属性 &#125; anewBuilder() console.log(window);&lt;/script&gt; 1.2.3 如果没有用var 声明，那么则不会进行变量提升，即使该变量也是隐式全局变量 1234if (exp in window)&#123; //报错，程序停止运行 exp = "example";//隐式全局变量，不会进行预解析，声明exp属性给到window console.log(exp); &#125; 1.3 在函数体内 ，(即使是函数体内的函数嵌套函数),没有var或者let声明的变量或者函数，就是在给全局this window添加属性；如果使用了var 或者 let声明变量，则不能被全局的this访问到； 12345678910111213141516171819&lt;script&gt;// var str = "全局的this"; //在函数体，声明变量的时候，如果没有用var var func = function()&#123; var str ="这个不能被全局的this访问到"; console.log(this.str);//undefined this代表全局的window，在全局范围内，并没有str赋值 // 如果不是被new调用函数，那么函数体的this都是指代全局范围的this,代表window对象； func3 = function()&#123; innerV = "这是函数体内的变量"; &#125;;// func3(); &#125; func(); this.func3();//和在函数体内执行效果是一样的，func3也是全局this的属性(方法)//这两个函数必须被执行，才能正确赋值,以下innerV 才能输出； console.log(this.innerV);//"这是函数体内的变量" console.log(this.str);//undefined //在函数体内，不使用var或者let声明变量，也是在给全局的this和window对象设置属性&lt;/script&gt; 2 function this2.0 对于一个函数，有三种角色，普通函数，直接调用执行；构造函数，通过new调用；函数作为对象；2.1 如果不是被new调用函数， 普通函数:直接执行函数体，那么函数体的this都是指代全局范围的this,代表window对象； 1234567891011121314151617181920212223&lt;script&gt; var foo = "bar"; //变量的声明，相当于给window添加了一个 foo 属性，属性值是一个基础数据类型值 function test ()&#123; //函数的声明，相当于给window添加了一个test属性，属性值是复杂数据类型值 this.foo = "bar is changed";//当函数不是被new操作符调用的时候，this还是指向window对象 &#125; console.log(this.foo);//bar test();//直接执行函数，this代表全局的this //等价于window.test() console.log(this.foo);//bar is changed //-------------------------------------------------------------------- var num = 300; function getNum()&#123; var num = 200 ; function getInnerNum()&#123; console.log(this); console.log(this.num);//300 console.log(num);//200 &#125; return getInnerNum; &#125; var res = getNum(); res();&lt;/script&gt; 直接执行函数体的时候，如果使用了apply call 则代表改变了函数运行时的this指向，原先this默认指向的是其执行的上下文环境；语法 fn.apply( thisArg[, argsArray] ) 、 fn.call( thisArg[, arg1[, arg2[, …]]] ) 执行之后，this指向传入的第一个参数 1234567891011&lt;script&gt; var foo = "bar"; var obj = &#123;"foo":"objBar"&#125; function test ()&#123; console.log(this.foo); &#125; test();//bar 函数执行的时候this指向执行的上下文环境 test.apply(obj);// objBar 将test函数执行的时候this的指向指向了obj test.call(obj);// objBar 将test函数执行的时候this的指向指向了obj&lt;/script&gt; 2.2 函数作为构造函数:如果被new操作符调用函数体,那么函数体的this就变成了一个新的值，和global的this没有任何关系 1234567891011121314&lt;script&gt; var foo = "bar"; function test ()&#123; this.foo = "bar is changed"; &#125; console.log(this.foo);//bar //不使用new操作符调用 // test(); // console.log(this.foo);//bar is changed //使用new操作调用 new test();//通过new操作符之后，函数体里面的this不再指向全局window，而是指向其新创建的对象 console.log(this.foo);//bar console.log(new test().foo);//bar is changed&lt;/script&gt; 2.3 接下来解释下new 操作符的作用，看下面的代码 123456789101112131415161718192021&lt;script&gt; function test ()&#123; this.foo = "bar is changed"; this.func = function()&#123; console.log("new的解析"); &#125; &#125; console.log(test); //function test()&#123; // this.foo = "bar is changed"; // this.func = function()&#123; // console.log("new的解析"); // &#125; // &#125; console.log(typeof test);//function console.log(new test);//test &#123;foo: "bar is changed",func:()&#125; console.log(typeof new test());//object&lt;/script&gt; 2.3.1 解释new的作用，当以 new 操作符调用构造函数的时候，函数内部 发生以下变化： 函数内部会创建一个空的对象，将该对象的引用指向this；所以后期只能通过this给实例添加属性和方法； 属性和方法会被添加到this 引用的对象中； 新创建的对象的引用指向了this,最后返回this 2.3.2 new操作符的作用如下: 12345678function test ()&#123; var obj = new Object();//实例化一个对象 obj.foo = "bar"; obj.func = function()&#123; console.log("new的解析"); &#125; return obj; &#125; 2.3.3 从原型的角度理解下 new操作符的作用 123456789101112131415161718 function test ()&#123; this.foo = "bar is changed"; this.func = function()&#123; console.log("new的解析"); &#125; &#125;var //1 方法new的瞬间 得到一个空的对象var obj = &#123; &#125; ;obj.__proto__ = test.prototype;//2 方法的this指向空对象obj//3 执行构造方法&#123; &#125;.foo = "bar is changed";&#123; &#125;.func = function()&#123; console.log("new的解析");&#125;// 返回该对象test.call(obj) 2.3.4 如果使用构造函数显式的返回基本数据类型(number string boolean null undefined)不会影响输出结果 ，返回引用类型 object 则不会再返回构造函数的实例对象的地址，而是返回该引用的地址； 1234567891011121314151617181920212223&lt;script&gt; function anotherTest()&#123; console.log("this is another test"); &#125; function test ()&#123; this.foo = "bar"; this.func = function()&#123; console.log("new的解析"); &#125;// 返回基本数据类型，不会影响最后的结果// return 123;// return "str";// return null;// 如果返回的是引用类型，则会改变返回值// return &#123;'name':'jhon','age':12&#125;;// return [1,2,3] // return anotherTest ; //如果返回this，那么还是返回的实例化对象;new操作符默认返回实例化对象 return this; &#125; var obj = new test(); console.log(obj);//基本数据类型，仍会返回构造函数的实例化对象，返回引用类型的话，就是返回了引用类型的地址，原来构造函数的实例化的对象指向该引用类型&lt;/script&gt; 2.3.5 new操作符每次调用的时候，在堆 (heap)内存中开辟一块内存空间，存储实例化对象的信息;如果有变量接受该对象的地址，那么 定义变量的时候会在栈(stack) 中开辟了一块空间存储变量名和引用地址 ；不同的变量指向不同的堆内存空间 1234567891011function test (name)&#123; this.name = name; &#125; var obj1 = new test('Jhon'); var obj2 = new test("Jhon"); console.log(obj1.name);//Jhon console.log(obj2.name);//Jhon obj1.name = "kobe"; console.log(obj1.name);//kobe console.log(obj2.name);//Jhon 2.4 如果函数体是对象的方法，那么此时的函数体里面的this就是指向的调用 该函数的对象；注意区分下面这两种情况 1234567891011&lt;script&gt; var foo = "bar"; console.log(this.foo);//bar var obj = &#123; foo:"objBar", test:function ()&#123; //函数作为对象的方法，被对象调用 console.log(this.foo);//objBar 此时的this指向调用函数的对象 &#125; &#125; obj.test();//对象的方法的执行的上下文是对象，所以this指向对象&lt;/script&gt; 1234567891011var foo = "bar"; console.log(this.foo);//bar var obj = &#123; foo:"objBar", test:function ()&#123; return function()&#123; console.log(this.foo);//bar &#125; &#125; &#125; obj.test()();//注意区分这两种情况:test()返回的是一个函数，函数直接在Window环境下执行 2.5 如果函数体是数组中的元素，那么函数作为数组的元素被调用的时候，指向数组,对于伪数组来书也是指向伪数组 1234567891011function fn1 ()&#123; console.log("fn1"); console.log(this); &#125; function fn2 ()&#123; console.log("fn2"); console.log(this[2]); &#125; var arr = [fn1,fn2,'things']; arr[0]();//fn1 [function, function, "things"] arr[1]();//fn2 things 12345678910111213function fn ()&#123; console.log(this.length); &#125; var obj = &#123; length : 10 , method : function(f)&#123; console.log(this.length);//10 console.log(arguments); arguments[0]();//1 this.length代表传入参数的个数 arguments[0].call(this);//10 &#125; &#125; obj.method(fn); this指向被调用的直接对象 ，被谁调用指向谁 123456789101112131415161718192021&lt;script&gt; var foo = "winBar"; var out = &#123; foo:"outerBar", outFunc:function()&#123; console.log(this);//this 代表out对象 console.log(this.foo);//执行后输出 outerBar &#125;, inner:&#123; foo:"innerBar", innerFunc:function()&#123; console.log(this);//this代表 inner对象 console.log(this.foo);//执行后输出 innerBar &#125; &#125; &#125; out.outFunc();//outFunc 函数被out这个对象调用，所以其内部的this指向out这个对象 out.inner.innerFunc();//innerFunc函数被inner这个对象调用，所以其内部的this指向inner这个对象//函数体被谁调用指向谁&lt;/script&gt; 总结:函数直接执行相当于被window调用，所以函数中的this指向window2.5 javascript 中经常用的也就是事件的绑定，对应的事件处理函数中如果出现了this,那么这个this代表的所绑定的元素 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang="en"&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;input type="button" value="按钮"/&gt;&lt;script&gt; document.querySelector("input").onclick = function()&#123; console.log(this.value);//按钮 这个this指向input标签 &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 2.6 setInterval(fn,time) setTimeout(fn,time) 中的this指向window;为什么呢？大家还记得 setInterval setTimeont都是window对象的属性吗？setInterval(fn,time) 等价于 window.setInterval(fn,time)其实是window调用了setInterval方法，所以其指向window ; 12345678&lt;script&gt; var foo = "bar"; var setTime = setInterval(function()&#123; var foo = "changedBar"; console.log(this.foo);//bar &#125;,1000) console.log(setTime);//setInterval函数返回以个ID值，代表当前定时器，用于后期可以清除该计时器用&lt;/script&gt; 3 prototype this原型里面的this指向，包括实例化的方法中的this指向:可以这么理解，它指向实例化的那个对象，但是,在找相应的属性的时候，它会顺着原型链一级级向上找，直到找到那个属性，如果没有找到，那么返回undefined; 这个其实也是函数独立调用还是被对象调用的情况 1234567891011121314&lt;script&gt; function Test()&#123; this.foo= "bar"; this.logFoo = function()&#123; console.log(this.foo);//this代表实例化之后的对象 &#125;; &#125; var test1 = new Test(); console.log(test1); //Test&#123;foo: "bar" ,logFoo: (),__proto__: Objectconstructor: Test(),__proto__: Object&#125;//关于new出来的对象可以暂时这么理解，然后该对象的地址赋值给test1; console.log(test1.foo);//bar test1.logFoo();//bar&lt;/script&gt; 通过原型添加属性和方法：this会顺着对象的原型链一直往下找，直到找到该属性为止，如果找不到的话，那么返回undefined;原型里的this也是指向实例化的对象，this.foo就是顺着原型链一直找； 1234567891011121314&lt;script&gt; function Test()&#123; &#125; Test.prototype.foo = "changedBar"; Test.prototype.logFoo = function()&#123; console.log(this.foo); &#125;; var test1 = new Test(); console.log(test1); // Test&#123;__proto__: Object,constructor: Test(),foo: "changedBar",logFoo: (),__proto__: Object console.log(test1.foo);//changedBar test1.logFoo();//changedBar&lt;/script&gt; 4 三 this总结1 this永远指向函数运行的时候所在的对象，而不是被创建的时候所在的对象； 2 匿名函数或不处于任何对象中的函数指向window 3 如果是call apply with 指定的this是谁，就是谁，如果是普通的函数调用，函数被谁调用，this就指向谁 4 如果不是被new调用函数，那么函数体的this都是指代全局范围的this,代表window对象； 5 函数独立运行的时候，那么this指向其所在运行的环境；函数作为对象的方法被调用的时候，this指向调用该函数的对象 6 如果调用者函数，被某一个对象所拥有，那么该函数在调用时，内部的this指向该对象。 如果函数独立调用，那么该函数内部的this，则指向undefined;但是在非严格模式中，当this指向undefined时，它会被自动指向全局对象。 严格模式下this指向 1234567function fn() &#123; 'use strict'; console.log(this); &#125; fn(); //undefined // fn是调用者，独立调用 window.fn(); //window // fn是调用者，被window所拥有 123456'use strict'; var a = 20 ; function fn()&#123; console.log(this.a); &#125; fn();//报错]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Critial Rendering Path]]></title>
      <url>%2F2016%2F11%2F02%2F145CritialRenderingPath%2F</url>
      <content type="text"><![CDATA[1 理解关键渲染路径是提高页面性能的关键所在。总体来说，关键渲染路径分为六步。 创建DOM树(Constructing the DOM Tree) 创建CSSOM树(Constructing the CSSOM Tree) 执行脚本(Running JavaScript) 生成渲染树(Creating the Render Tree) 生成布局(Generating the Layout) 绘制(Painting) 创建 DOM 树 DOM（文档对象模型）树是HTML页面完全解析后的一种表示方式。从根元素开始，页面上每个元素或者文本都会创建一个对应的节点。每个节点都包含了这个元素的所有属性，并且嵌套在元素内的元素会被解析成外层元素对应的节点的子节点。 创建CSSOM 树 CSSOM（CSS对象模型）树是对附在DOM结构上的样式的一种表示方式。它与DOM树的呈现方式相似，只是每个节点都带上样式 ，包括明确定义的和隐式继承的。 CSS是一种渲染阻塞资源(render blocking resource)，它需要完全被解析完毕之后才能进入生成渲染树的环节。CSS并不像HTML那样能执行部分并显示，因为CSS具有继承属性， 后面定义的样式会覆盖或者修改前面的样式。如果我们只使用样式表中部分解析好的样式，我们可能会得到错误的页面效果。所以，我们只能等待CSS完全解析之后，才能进入关键渲染路径的下一环节。 需要注意的是，只有CSS文件适用于当前设备的时候，才能造成渲染阻塞。标签接受media属性，该属性规定了此处的CSS文件适用于哪种设备。如果我们有个设备属性值为orientation: landscape(横向)的样式，当我们竖着浏览页面的时候，这个CSS资源是不会起作用的，也就不会阻塞渲染的过程了。 因为JavaScript脚本的执行必须等到CSSOM生成之后，所以说CSS也会阻塞脚本(script blocking)。 执行JavaScript JavaScript是一种解析阻塞资源(parser blocking resource)，它能阻塞HTML页面的解析。 当页面解析到&lt;script&gt;标签，不管脚本是內联的还是外联，页面解析都会暂停，转而加载JavaScript文件（外联的话）并且执行JavaScript。这也是为什么如果JavaScript文件有引用HTML文档中的元素，JavaScript文件必须放在那个元素的后面。 为了避免JavaScript文件阻塞页面的解析，我们可以在&lt;script&gt;标签上添加async属性，使得JavaScript文件异步加载。 生成渲染树 渲染树是DOM和CSSOM的结合，是最终能渲染到页面的元素的树形结构表示。也就是说，它包含能在页面中最终呈现的元素，而不包含那些用CSS样式隐藏的元素，比如带有display: none;属性的元素。 生成布局 布局决定了视口的大小，为CSS样式提供了依据，比如百分比的换算或者视口的总像素值。视口大小是由meta标签的name属性为viewport的内容设置所决定的，如果缺少这个标签，默认的视口大小为980px。 绘制 最后，页面上可见的内容就会转化为屏幕上的像素点。 2 绘制过程所需要花费的时间取决于DOM的大小以及元素的CSS样式。有些样式比较耗时，比如一个复杂的渐变背景色比起简单的单色背景需要更多的时间来渲染。转化： 浏览器从磁盘或网络读取 HTML 的原始字节，浏览器会将这段原始文件按照相应编码规范进行解码（现在一般为 utf-8）。 符号化：根据 W3C 标准转化为对应的符号（一般在尖括号内）。 DOM 构建：HTML 解析器会解析其中的 tag 标签，生成 token ，遇到 CSS 或JS 会发送相应请求。HTML 解析时阻塞主进程的，CSS 一般也是阻塞主进程的（媒体查询时例外），也就是说它们在解析过程中是无法做出响应的。而 JS 手动添加 async 后达到异步加载，根据 token 生成相应 DOM 树。 CSSDOM 构建，添加 CSS 样式生成 CSSDOM 树。 渲染树构建，从 DOM 树的根节点开始，遍历每个可见的节点，给每个可见节点找到相应匹配的 CSSOM 规则，并应用这些规则，连带其内容及计算的样式。 样式计算，浏览器会将所有的相对位置转换成绝对位置等一系列的样式计算。 布局，浏览器将元素进行定位、布局。 绘制，绘制元素样式，颜色、背景、大小、边框等。 合成，将各层合成到一起、显示在屏幕上。 其他优化： 使用 requestAnimationFrame，将 setTimeout 换成requestAnimationFrame，因为 setTimeout 时间控制可能造成在一帧的中间，目前各浏览器对 requestAnimationFrame 的支持已经比较好了。 使用 Web Workers，将复杂计算的 JS 采用 Web Workers 进行处理。 减少垃圾回收，垃圾回收是一个容易被忽略的问题，因为垃圾回收的时间是不受控制的，它可能在一个动画的中途，阻塞动画的执行，更理想的情况是在循环中复用对象 3 浏览器计算 DOM 元素的几何信息的过程：元素大小和在页面中的位置。每个元素都有一个显式或隐式的大小信息，决定于其 CSS 属性的设置、或是元素本身内容的大小、或者是其父元素的大小。在Blink/WebKit 内核的浏览器和 IE 中，这个过程称为 Layout。在基于 Gecko 的浏览器（比如 Firefox）中，这个过程称为Reflow。3.1 避免触发布局 目前，transform 和 opacity 只会引起合成，不会引起布局和重新绘制。整个流程中比较耗费性能的布局和绘制流程将直接跳过，性能显然是很好的。其他的 CSS 属性改变引起的流程会有所不同，有些属性也会跳过布局，具体可以查看 CSS Triggers。所以，优化的第一步就是尽可能避免触发布局 3.2 为什么 DOM 很慢 谈到这里需要对浏览器利用 HTML/CSS/JavaScript 等资源呈现出精彩的页面的过程进行简单说明。浏览器在收到 HTML 文档之后会对文档进行解析开始构建 DOM (Document Object Model) 树，进而在文档中发现样式表，开始解析 CSS 来构建 CSSOM（CSS Object Model）树，这两者都构建完成后，开始构建渲染树 在每次修改了 DOM 或者其样式之后都要进行 DOM树的构建，CSSOM 的重新计算，进而得到新的渲染树。浏览器会利用新的渲染树对页面进行重排和重绘，以及图层的合并。通常浏览器会批量进行重排和重绘，以提高性能。但当我们试图通过 JavaScript 获取某个节点的尺寸信息的时候，为了获得当前真实的信息，浏览器会立刻进行一次重排。 3.3 避免强制性同步布局 在 JavaScript 中读取到的布局信息都是上一帧的信息，如果在 JavaScript 中修改了页面的布局，比如给某个元素添加了一个类，然后再读取布局信息。这个时候为了获得真实的布局信息，浏览器需要强制性对页面进行布局。因此应该避免这样做。 3.4 批量操作 DOM 在必须要进行频繁的 DOM 操作时，可以使用 fastdom 这样的工具，它的思路是将对页面的读取和改写放进队列，在页面重绘的时候批量执行，先进行读取后改写。因为如果将读取与改写交织在一起可能引起多次页面的重排。而利用 fastdom 就可以避免这样的情况发生。 虽然有了 fastdom 这样的工具，但有的时候还是不能从根本上解决问题，比如我最近遇到的一个情况，与页面简单的一次交互（轻轻滚动页面）就执行了几千次 DOM 操作，这个时候核心要解决的是减少 DOM 操作的次数。这个时候就要从代码层面考虑，看看是否有不必要的读取。 3.5 使用 requestAnimationFrame 来更新页面 我们希望在每一帧刚开始的时候对页面进行更改，目前只有使用 requestAnimationFrame 能够保证这一点。使用setTimeout 或者 setInterval 来触发更新页面的函数，该函数可能在一帧的中间或者结束的时间点上调用，进而导致该帧后面需要进行的事情没有完成，引发丢帧。 3.6 优化 CSS CSS 选择器在匹配的时候是由右至左进行的，因此最后一个选择器常被称为关键选择器，因为最后一个选择越特殊，需要进行匹配的次数越少。要千万避免使用 *（通用选择器）作为关键选择器。因为它能匹配到所有元素，进而倒数第二个选择器还会和所有元素进行一次匹配。这导致效率很低下。 总结 我们可以利用Chrome开发者工具下的Timeline去观察整个关键路径渲染的过程。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ES6 解构赋值]]></title>
      <url>%2F2016%2F11%2F01%2F112-%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC%2F</url>
      <content type="text"><![CDATA[解构赋值先记住一点，无论是数组的解构赋值还是对象的解构赋值，根本是赋值操作； 数组的解构赋值根据变量的位置对应赋值 对象的解构赋值根据匹配的模式进行赋值 解构赋值必须符合语法 12let &#123;a,b&#125;;//报错let [a,b];//报错 解构可以避免在对象赋值时产生中间变量：1 数组的解构赋值(解构赋值的时候，必须符合解构赋值的格式，数据必须是可迭代的结构) 数组的元素是按次序排列的，变量的取值由它的位置决定123let [a,b,c] = [1,2,3] //等价于let a = 1, b = 2 , c = 3 ; 如果左边变量多余右边值，多余的变量将被赋值为undefined 12let [a,b,c] = [1,2] console.log(c) ;//undefined 如果左边变量少于右边值，右边多余的值将会被忽略 1let [a,b,c] = [1,2,3,4] “链式”赋值:其实核心还是 赋值运算符的运算过程: 返回 ＝ 右边的运算数，从右向左进行运算 1234let arr,first,second ;arr = [first,second] = [1,2,3,4];//arr // [1,2,3,4]//first 1 second 2 变量值的”优先级”: 右边undefined &lt; 左边默认值 &lt; 右边除了undefined之外的其他值 1234let [a = 1 ,b=2 ,c] = [undefined,2222,3]; //右侧undefined不会赋值给a,右侧2222会赋值给b console.log(a);//1console.log(b);//2222console.log(c);//3 解构赋值的原理: 12345678910111213141516 let [a = b,b=5,c] = [1]; console.log(a);//1 console.log(b);//5 console.log(c);//undefined//等价于 let a = 1, b = 5 , c = undefined ;//以下情况会报错 let [a = b,b=5,c] = [];//直接报错 console.log(a);// console.log(b);// console.log(c);////等价于 let a = b , b = 5 , c = undefined ;//let声明的变量使用之前必须先被声明 --------------------------------------------// let a = b ;//b is not defined// let b = 5 ;// let c ; //对于let声明变量，变量的使用必须在声明之前才可以使用 看下var声明 1234567891011121314151617var [a = b,b=5,c] = [];//这个不会报错，所以需要理解数据结构赋值的原理 console.log(a);//undefined console.log(b);//5 console.log(c);//undefined//-------------------------------------------------- //左边进行声明// var a = b ;//这个相当于对 b 进行了变量提升，但是没有运行到b=5的时候，a的值被赋予undefined;// var b = 5 ;// var c ;// console.log(a);//undefined //然后右边进行赋值,原来有默认值的不会发生变化// ------------------------------------------------------// var a = b ;//b is not defined//// var c ;// console.log(a);//// ---------------------------------------------------------- 1234567//如果等号的右边不是数组或者严格地说，不是可遍历的结构，那么将会报错。如下let [foo] = 1;let [foo] = false;let [foo] = NaN;let [foo] = undefined;let [foo] = null;let [foo] = &#123;&#125;; 2 对象的解构赋值 对象的属性没有次序，变量必须与属性同名，才能取到正确的值对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者 12345let &#123;foo,bar&#125; = &#123;foo:"aaa",bar:"bbb"&#125;;let &#123;bar,foo&#125; = &#123;foo:"aaa",bar:"bbb"&#125;;//foo aaa//bar bbb//这点和数组的结构赋值不同，数组的结构赋值是按照元素的位置进行解构赋值，而对象的解构赋值是根据无序的属性名进行匹配，然后在进行赋值 如果匹配不到对应的属性名，那么将会被赋值为undefined 12let &#123;baz&#125; = &#123;foo1:'aaa',foo2:'bbb'&#125;console.log(baz);//undefined 12let &#123;baz&#125; = &#123;&#125;console.log(baz);//undefined 对象的解构赋值，根本是给属性的属性值进行的赋值 12let&#123;foo&#125; = &#123;foo:'aaa',bar:'bbb'&#125;;console.log(foo);//aaa 123let&#123;foo:baz&#125; = &#123;foo:'aaa',bar:'bbb'&#125;;//采用这种写法时，变量的声明和赋值是一体的console.log(baz);//aaaconsole.log(foo);//foo is not defined 从上面两段代码可以看出来，其实对象的解构赋值， 根本还是对象的属性的简洁语法表示 解构赋值是先进行变量的声明 12let &#123; foo,bar&#125; = &#123; foo: "aaa", bar: "bbb" &#125;;let &#123; foo: foo, bar: bar &#125; = &#123; foo: "aaa", bar: "bbb" &#125;; 如果是采用以下赋值形式{ } 必须用( ) 括起来，否则浏览器会认为那是一个代码块,会报错 12(&#123;foo:baz&#125; = &#123;foo:'aaa'&#125;);console.log(baz);//aaa 为了说明对象的解构赋值的匹配模式的，看下面的代码 1234let&#123;foo:baz&#125; = &#123;&#125;;console.log(baz);//undefinedconsole.log(foo);//foo is not defined//这个时候，我们应该能理解 let&#123;foo:baz&#125; 声明的变量是baz ,并不是foo,foo是匹配的模式，匹配的根据 体会下下面的两段代码 123456console.log(name);//报错 name is not definedlet &#123;heheh:name&#125; = &#123;heheh:'aaa'&#125;;console.log(name);//这个也证明了 let &#123;heheh:name&#125; 声明的是 : 后面的变量//而let&#123;foo ,bar &#125; 其实是分为两步，第一对象的简洁写法&#123;foo,bar&#125; ==&gt; &#123;foo:foo,bar:bar&#125;//所以let声明的变量还是 : 冒号后面的变量，然后在进行解构赋值操作 123console.log(name);//aaa(&#123;heheh:name&#125; = &#123;heheh:'aaa'&#125;);console.log(name);//aaa 对象的解构赋值是可以嵌套的，同样对于匹配模式(属性名)还是要有深刻的认识 12345(&#123;p:[x,&#123;y:z&#125;]&#125; = &#123;p:['hello',&#123;&#125;]&#125; );console.log(x);//helloconsole.log(z);//undefinedconsole.log(y);//y is not defined// p 和 y 都是匹配模式 undefined再取属性的时候会报错 123let _temp = &#123;bar:"baz"&#125;;console.log(_temp.foo);//undefinedconsole.log(_temp.foo.anything);// Cannot read property 'anything' of undefined 如果解构模式是嵌套的对象，而且子对象所在的父属性不存在，那么将会报错。 12let &#123;foo:&#123;bar:baz&#125;&#125; = &#123;hehe:&#123;bar:'value'&#125;&#125;//上面代码中，等号左边对象的foo属性，对应一个子对象。该子对象的bar属性，解构时会报错。原因很简单，因为foo这时等于undefined，再取子属性就会报错，请看下面的代码]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[eval JSONparse]]></title>
      <url>%2F2016%2F10%2F27%2F69jseval%20%E5%92%8C%20JSON%20parse%2F</url>
      <content type="text"><![CDATA[js 的 eval( ) 和 JSON.parse( ) 的用法和区别:1 eval(string):这个全局函数可以用来接受一个字符串作为javascript代码去执行，也就是说，传入的参数可以作为脚本代码进行执行；比如创建变量，创建对象，执行函数等 如果传入的值 是一个字符串，那么则将字符串作为代码执行，如果有返回值，则返回该值，如果没有返回值，则返回undefined 如果传入的值 不是一个字符串，那么则直接返回传入的值 需要特别注意的是对象的声明语法 { } 如果直接将{ } 声明的对象作为值传入，则直接返回该对象，如果是 ‘{ }’ 作为参数传入eval( )则会直接报错; 12345678910111213141516&lt;script&gt; eval("var a=1");//声明一个变量a并赋值1。传入参数是一个字符串，则将该字符串作为代码执行 console.log( eval("var a=1") );//undefined 因为没有返回值，所以结果是undefined eval("2+3");//执行加运算，并返回运算值。 console.log( eval("2+3") );//5 eval("&#123;b:2&#125;");//声明一个对象。 eval("mytest()");//执行mytest()函数。 console.log( eval( &#123;b:2,"nema":"jhon"&#125;) );//Object &#123;b: 2, nema: "jhon"&#125;，传入参数不是一个字符串，那么直接返回传入的值 console.log( eval('&#123;"b":2,"nema":"jhon"&#125;') );//会直接报错//如果想要将字符串 '&#123;"b":2,"nema":"jhon"&#125;' 转化为常用的对象输出，则需要将其加上小括号，转化为表达式，才能正确输出对象，以下几种写法都是正确的 var code2 = '&#123;"b":2,"nema":"jhon"&#125;';// console.log( eval('&#123;"b":2,"nema":"jhon"&#125;') );//浏览器报错 console.log( eval('('+code2+')') ); //Object &#123;b: 2, nema: "jhon"&#125; console.log( eval('('+'&#123;b:2,"nema":"jhon"&#125;'+')') ); //Object &#123;b: 2, nema: "jhon"&#125; console.log( eval('(&#123;b:2,"nema":"jhon"&#125;)') );//Object &#123;b: 2, nema: "jhon"&#125;&lt;/script&gt; 2 eval(string)函数的作用域:关键记住，val()函数并不会创建一个新的作用域，并且它的作用域就是它所在的作用域。这在所有主流浏览器都是如此，但是有时候需要将eval()函数的作用域设置为全局，当然可以将eval()在全局作用域中使用，但是往往实际应用中，需要在局部作用域使用具有全局作用域的此函数，这个时候可以用window.eval()的方式实现 123456789101112131415&lt;script&gt; function test ()&#123; eval("var num = 4"); console.log(num);//4 &#125; test();// console.log(num);//num is not defined function test1 ()&#123; window.eval("var num = 4"); console.log(num);//4 &#125; test1(); console.log(num);//4&lt;/script&gt; 3 eval()可以将字符串解析为对象，同样JSON.parse()也可以将字符串解析为对象 12345var data = '&#123;"b":2,"nema":"jhon"&#125;'; //这是一个字符串//第一种方法，通过eval()将其解析成对象var objData1 = eval( "("+data+")" ); ////Object &#123;b: 2, nema: "jhon"&#125;//第二种方法var objData2 = JSONparse(data);//Object &#123;b: 2, nema: "jhon"&#125; 它们有什么区别和不同呢? JSON.parse()之可以解析json格式的数据，并且会对要解析的字符串进行格式检查，如果格式不正确则不进行解析，而eval()则可以解析任何字符串，eval是不安全的。 JSON.parse( ‘ {“name”:”Jhon”,”age”:13 } ‘ ) 解析的结果是一个对象 {“name”:”Jhon”,”age”:13 } JSON.parse( ‘ [{“name”:”Jhon”,”age”:13 } , {“name”:”Jhon”,”age”:13 }] ‘ ) 解析的结果是一个数组，里面有两个对象 [{“name”:”Jhon”,”age”:13 } , {“name”:”Jhon”,”age”:13 }] 总结来说:JSON.parse()可以将字符串类型的数组，转化为数组，将字符串类型的对象，转化为对象 eval( )里面可以传入非字符串的数据类型，会直接返回该类型值，比如直接传递数组 [ {“name”:”jhon”} ] 或者对象 {“name”:”jhon”} ,或者基本数据类型和复杂数据类型，但是JSON.parse( )，只能接受字符串类型的 ; 如果传入数组 [ {“name”:”jhon”} ] 或者对象 {“name”:”jhon”} 会报错； 12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang="en"&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script&gt; //从后台返回的数据一般是字符串类型的，需要将其解析成javascirpt对象 var data = '[&#123;"name":"jhon"&#125;,&#123;"age":16&#125;]';// var data = [&#123;"name":"jhon"&#125;,&#123;"age":16&#125;]; var objData1 = eval(data); var objData2 = JSON.parse(data); console.log("this is objData1"+objData1); console.log(objData1); console.log("this is objData2"+objData2); console.log(objData2); var num = 3 ; console.log(eval(num));//3 console.log(eval(true));//true console.log(eval(null));//null console.log(eval(undefined));//undefined console.log(eval(&#123;"name":"jhon"&#125;));//Object &#123;name: "jhon"&#125; 对象 console.log(eval([&#123;"name":"jhon"&#125;]));//[Object] 数组 console.log(JSON.parse(num));//3 console.log(JSON.parse(true));//true console.log(JSON.parse(null));//null// console.log(JSON.parse(undefined));//报错// console.log(JSON.parse(&#123;"name":"jhon"&#125;));//报错 console.log(JSON.parse('&#123;"name":"jhon"&#125;'));Object &#123;name: "jhon"&#125; 对象 //console.log(JSON.parse([&#123;"name":"jhon"&#125;]));//报错 console.log(JSON.parse('[&#123;"name":"jhon"&#125;]'));//[Object] 数组 console.log(JSON.parse('[1,2,3]')); //[1,2,3]&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[NodeJs Module System]]></title>
      <url>%2F2016%2F10%2F27%2F147NodeJsModuleSystem%2F</url>
      <content type="text"><![CDATA[1 Node.js 模块系统模块是Node.js 应用程序的基本组成部分，文件和模块是一一对应的。换言之，一个 Node.js 文件就是一个模块，这个文件可能是JavaScript 代码、JSON 或者编译过的C/C++ 扩展。 模块之间的通信方式 : require引入 module.exports 和 exports 暴露某个模块的对外接口 2 创建一个模块2.1 首先来看下node本身模块是什么 2.1.1 b.js文件 12console.log(module);console.log(module.exports); 执行命令 node b.js 输出如下 123456789101112Module &#123; id: '.', exports: &#123;&#125;, parent: null, // filename: 'F:\\workspace\\01-node\\b.js', //代表文件的路径 loaded: false, children: [], paths: [ 'F:\\workspace\\01-node\\node_modules', 'F:\\workspace\\node_modules', 'F:\\node_modules' ] &#125;&#123;&#125; //这个是module.exports 本身是一个空对象 a.js 文件 require(package) 返回值是module.exports 12var res = require('./b.js');console.log(res); 执行命令 node a.js 输出如下 1234567891011121314151617181920212223242526Module &#123; id: 'F:\\workspace\\01-node\\b.js', exports: &#123;&#125;, parent: Module &#123; id: '.', exports: &#123;&#125;, parent: null, filename: 'F:\\workspace\\01-node\\a.js', loaded: false, children: [ [Circular] ], paths: [ 'F:\\workspace\\01-node\\node_modules', 'F:\\workspace\\node_modules', 'F:\\node_modules' ] &#125;, filename: 'F:\\workspace\\01-node\\b.js', loaded: false, children: [], //被该模块引用的模块对象。 paths: [ 'F:\\workspace\\01-node\\node_modules', 'F:\\workspace\\node_modules', 'F:\\node_modules' ] &#125;&#123;&#125; //以上是b.js输出&#123;&#125; //这个是a.js输出 由此可得知require返回的是所引的package的module.exports； 所以我们可以通过改变exports的值 2.1.2返回一个构造函数 b.js 1234module.exports = function()&#123;&#125;console.log(module.exports); 执行 node b.js 1[Function] 执行 node a.js 12[Function] //这个是b.js的输出 console.log(module.exports);[Function] //这个是a.js的输出 console.log(res); 2.1.3 或者直接给module.exports对象添加属性 b.js 12module.exports.prop = function()&#123;&#125;console.log(module.exports); 执行node b.js 1&#123; prop: [Function] &#125; 此时a.js通过require引用的时候返回的就是这个对象 以下实例便于理解: 2.2 exports.prop 形式创建模块 1234//sayHello.jsexports.sayhi = function()&#123; //exports对象可以定义sayhello.js将该模块的接口 console.log("this is a module we made");&#125; 引入创建的模块 1234//main.jsvar hello = require('./sayHello'); console.log(hello) ;//&#123; sayhi: [Function] &#125;hello.sayhi(); 以上实例中，代码 require(‘./sayhello’) 引入了当前目录下的sayhello.js文件（./ 为当前目录，node.js默认后缀为js）。Node.js 提供了exports 和 require 两个对象，其中 exports 是模块公开的接口，require 用于从外部获取一个模块的接口，即所获取模块的 exports 对象。 2.3 module.exports = function(){ } 如果希望模块根导出为一个函数（比如构造函数）或一次导出一个完整的对象而不是每次都创建一个属性，可以把它赋值给 module.exports 而不是 exports。 123456//square.jsmodule.exports = (width) =&gt; &#123; return&#123; area : () =&gt; width*width &#125;&#125; 123456//main.jsconst square = require('./square'); console.log(square);//[Function]var res = square(2);//&#123; area: [Function: area] &#125;console.log(res);console.log(res.area()); 1234567const square = require('./square');//可以理解为 const square = (width) =&gt; &#123; return&#123; area : () =&gt; width*width &#125;&#125; 返回一个构造函数 123456789//myevents.jsmodule.exports = function myEvents()&#123; this.on = function()&#123; console.log("通过on绑定事件"); &#125;; this.emit = function()&#123; console.log("通过emit触发事件"); &#125;;&#125; 1234567//main.jsconst Event = require('./myevents');console.log(Event);var event = new Event();console.log(event);console.log(event.on);console.log(event.emit); 12345678910const Event = require('./myevents');//可以理解为 const Event = function myEvents()&#123; this.on = function()&#123; console.log("通过on绑定事件"); &#125;; this.emit = function()&#123; console.log("通过emit触发事件"); &#125;;&#125; 2.4 require(module) 的内部实现，就是返回所引用模块的module.exports module.exports 和 exports 的区别 : exports 变量是在模块的文件级别作用域内有效的，它在模块 被执行 前被赋于 module.exports的值。 它有一个快捷方式，以便 module.exports.prop= … 可以被更简洁地写成 exports.prop= …。 注意，就像任何变量，如果一个新的值被赋值给 exports，它就不再绑定到 module.exports； 之所以有这个简洁的写法，根本原因的node做了一个工作 exports在模块执行前被赋值 module.exports 2.4.1 b.js 1234console.log(module);exports.name = "Jhon";//可以被导出到引用的模块console.log(module); 执行 node b.js 终端输出如下 12345678910111213141516171819202122Module &#123; id: '.', exports: &#123;&#125;, parent: null, filename: 'F:\\workspace\\01-node\\10b.js', loaded: false, children: [], paths: [ 'F:\\workspace\\01-node\\node_modules', 'F:\\workspace\\node_modules', 'F:\\node_modules' ] &#125;Module &#123; id: '.', exports: &#123; name: 'Jhon' &#125;, parent: null, filename: 'F:\\workspace\\01-node\\10b.js', loaded: false, children: [], paths: [ 'F:\\workspace\\01-node\\node_modules', 'F:\\workspace\\node_modules', 'F:\\node_modules' ] &#125; a.js 1var res = require('./b.js');//可以得到 b 模块定义的数据 &#123; name: 'Jhon' &#125; 2.4.2 b.js 1234console.log(module);exports = &#123;name:"Jhon"&#125;;//此时exports不再和module.exports指向同一块内存地址，最后导出的module.exports 还是未初始化的时候的一个空对象//不会导出到引用的模块，只在模块内有效console.log(module); 执行 node b.js 注意exports的内容 12345678910111213141516171819202122Module &#123; id: '.', exports: &#123;&#125;, parent: null, filename: 'F:\\workspace\\01-node\\10b.js', loaded: false, children: [], paths: [ 'F:\\workspace\\01-node\\node_modules', 'F:\\workspace\\node_modules', 'F:\\node_modules' ] &#125;Module &#123; id: '.', exports: &#123;&#125;, parent: null, filename: 'F:\\workspace\\01-node\\10b.js', loaded: false, children: [], paths: [ 'F:\\workspace\\01-node\\node_modules', 'F:\\workspace\\node_modules', 'F:\\node_modules' ] &#125; a.js 1var res = require('./b.js');//此时得到 b 模块到处的内容 为 &#123; &#125; 2.4.3 b.js 123console.log(module);module.exports = &#123;name:"Jhon"&#125;;console.log(module); 执行 node b.js 12345678910111213141516171819202122Module &#123; id: '.', exports: &#123;&#125;, parent: null, filename: 'F:\\workspace\\01-node\\10b.js', loaded: false, children: [], paths: [ 'F:\\workspace\\01-node\\node_modules', 'F:\\workspace\\node_modules', 'F:\\node_modules' ] &#125;Module &#123; id: '.', exports: &#123; name: 'Jhon' &#125;, parent: null, filename: 'F:\\workspace\\01-node\\10b.js', loaded: false, children: [], paths: [ 'F:\\workspace\\01-node\\node_modules', 'F:\\workspace\\node_modules', 'F:\\node_modules' ] &#125; a.js 1var res = require('./b.js');//可以得到 b 模块定义的数据 &#123; name: 'Jhon' &#125; 2.4.4 根据以上的实验结果，可以大概得知require函数的内部实现 1234567891011121314//require()实现function require(...) &#123; var module = &#123; exports: &#123;&#125; &#125;; ((module, exports) =&gt; &#123; // 你的模块代码在这。在这个例子中，定义了一个函数。 function some_func() &#123;&#125;; exports = some_func;// exports在文件执行前被赋值为 module.exports,这里在重新赋值其他数据， // 此时，exports 不再是一个 module.exports 的快捷方式， // 且这个模块依然导出一个空的默认对象。 module.exports = some_func; // 此时，该模块导出 some_func，而不是默认对象。 &#125;)(module, module.exports); return module.exports; //require函数导出的是模块的 module.exports,而不是exports&#125; 2.5 require加载模块的查找规则 2.5.1 nodejs模块载入策略 Node.js的模块分为两类，一类为原生（核心）模块，一类为文件模块。原生模块在Node.js源代码编译的时候编译进了二进制执行文件，加载的速度最快。另一类文件模块是动态加载的，加载速度比原生模块慢。但是Node.js对原生模块和文件模块都进行了缓存，于是在第二次require时，是不会有重复开销的。其中原生模块都被定义在lib这个目录下面，文件模块则不定性 文件模块又分为以下三类模块，这三类文件以后缀名来区分，nodejs会根据后缀名来决定如何加载文件模块 .js。通过fs模块同步读取js文件并编译执行。 .node。通过C/C++进行编写的Addon。通过dlopen方法进行加载。 .json。读取文件，调用JSON.parse解析加载。 我们有没有考虑过这样一个情况，为什么一个文件没有声明require module却可以直接使用这些变量值呢？其实nodejs做了以下工作: 假如有一个 circle.js 1234567var PI = Math.PI;exports.area = function (r) &#123; return PI * r * r;&#125;;exports.circumference = function (r) &#123; return 2 * PI * r;&#125;; app.js 12var circle = require('./circle.js');console.log( 'The area of a circle of radius 4 is ' + circle.area(4)); 当我们在终端执行命令 node app.js 的时候，nodejs会对app.js进行编译包装，包装之后其实就是 1234(function (exports, require, module, __filename, __dirname) &#123; var circle = require('./circle.js'); console.log('The area of a circle of radius 4 is ' + circle.area(4));&#125;); 这就是为什么我们直接在终端输入命令 node filename.js的时候，可以直接调用 exports require module等 接下来我们来看下require加载文件的查找策略: 从文件模块缓存中加载尽管原生模块与文件模块的优先级不同，但是都不会优先于从文件模块的缓存中加载已经存在的模块。 从原生模块加载原生模块的优先级仅次于文件模块缓存的优先级。require方法在解析文件名之后，优先检查模块是否在原生模块列表中。以http模块为例，尽管在目录下存在一个http/http.js/http.node/http.json文件，require(“http”)都不会从这些文件中加载，而是从原生模块中加载。 原生模块也有一个缓存区，同样也是优先从缓存区加载。如果缓存区没有被加载过，则调用原生模块的加载方式进行加载和执行。 从文件加载当文件模块缓存中不存在，而且不是原生模块的时候，Node.js会解析require方法传入的参数，并从文件系统中加载实际的文件，加载过程中的包装和编译细节在前一节中已经介绍过，这里我们将详细描述查找文件模块的过程，其中，也有一些细节值得知晓。 require方法接受以下几种参数的传递： http、fs、path等，原生模块。 ./mod或../mod，相对路径的文件模块。 /pathtomodule/mod，绝对路径的文件模块。 mod，非原生模块的文件模块。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[js event compare with jQuery event]]></title>
      <url>%2F2016%2F10%2F22%2F55-js%20%20jQuery%E7%BB%91%E5%AE%9A%E4%B8%8E%E7%A7%BB%E9%99%A4%E4%BA%8B%E4%BB%B6%E7%9A%84%E6%AF%94%E8%BE%83%2F</url>
      <content type="text"><![CDATA[js jQuery绑定事件的比较:一 事件分类1234567891 window 事件:onload onunload onafterprint onbeforeprint onerror onresize 2 From表单 事件(仅在表单元素中有效):onblur onfocus onreset onsubmit onselect onchange oninput3 键盘事件 : onkeydown onkeyup onkeyup4 鼠标事件: onclick onmouseout onmouseleave onmouseenter onmousedown onmouseup onscroll(当元素滚动条被滚动的时候) ondrag ondragstart ondragend ondragenter ondragover ondragleave ondrop //键盘事件和鼠标事件在base, bdo, br, frame, frameset, head, html, iframe, meta, param, script, style, title 元素无效；5 触摸事件 :touchstart touchend touchmove 6 媒介事件 : 7 自定义事件:8 所有的事件都是成元素的一个属性，原始值为null;输出一个DOM元素可以查看其所有的属性; 二 绑定事件 JS绑定事件:(onclick之类的本身就是一属性，通过给属性设置函数，可以使其具有功能，而addEventListener是一个函数，通过函数体的内容给元素绑定事件) 12345ele.on+事件类型 = function()&#123; &#125;; ele.addEventListener("事件类型"，function()&#123; &#125; );ele.onclick = function()&#123; &#125;; ele.addEventListener("click",function()&#123; &#125; );ele.onmouseout = function()&#123; &#125;; ele.attachEvent("onclick",function()&#123; &#125; );(注意有on)window.onlaod = function()&#123; &#125;; window.addEventListener("load",function()&#123; &#125; );ele.ondragstart = function()&#123; &#125;; ele.addEventListener("dragstart",function()&#123; &#125; ); 注意: 触摸事件只能通过addEventListener来绑定,过渡结束事件(自定义事件) 1ele.addEventListener("touchstart",function()&#123; &#125; ); JS移除事件(该事件通过什么方式绑定的就要通过什么方式移除) 123456789101112// 1注册事件 my$("btn1").onclick = fn;//(onclick指向一个函数体)//1移除事件 my$("btn1").onclick = null;//(将指向设置为null,则可以清除事件)// 2 注册事件my$("btn1").addEventListener("click",fn,false);// 2 移除事件my$("btn1").removeEventListener("click",fn,false);// 3 注册事件 谷歌和火狐不支持 my$("btn1").attachEvent("onclick",fn);// 3 移除事件 my$("btn1").detachEvent("onclick",fn); jQuery绑定事件和移除事件 12345678910111213141516--ready(fn):当DOM元素载入就绪就可以执行的一个函数data 是传递给jQuery事件对象参数event.data的数据，fn是绑定在该事件上的处理程序，events和type是要绑定的事件类型--$("selector").on(events,data,fn) 可以一次绑定多个事件 $("selector").off(events,data,fn) 移除on绑定的事件 如果不写任何参数，则移除匹配元素的所有事件 $("selector").bind(type,data,fn) 可以一次绑定多个事件，可以绑定自定义事件; $("selector").unbind(type,data,fn) 移除bind绑定的事件 如果不写任何参数，则移除匹配元素的所有事件--$("selector").mouseover(), $("selector").mouseover(fn) 如果不写参数，将触发选定元素的该事件，如果写 了函数体，则将为选定的元素绑定事件 mouseout mousemove mouseenter mouseleave mouseup mousedown click keyup keydown change blur 都是一样的特性，如果不传函数体，就是触发该事件;如果传了函数体，就是绑定该事件的处理程序.--$("selector").hover(fn(in)/fn(oout) 可以给选中的元素绑定hover事件，鼠标悬浮在上面的时候，执行 fn(in),鼠标离开元素的时候执行fn(out);//事件委派 使用 delegate() 方法的事件处理程序适用于当前或未来的元素（比如由脚本创建的新元素）。--$("selector1").delegate("selector2","type",fn) selector1必须是selector2的父元素，事件的执行程序绑定在selector2(子元素选择器)上 。 三 js 和 jQuery 绑定事件的区别 两者绑定的事件符合事件的传播过程，比如冒泡，捕获 两者的事件对象参数基本一致，不同点在于jQuery绑定的事件，事件对象参数多了两个参数，一个是event.originalEvent 一个是event.data 四 自定义事件底层实现原理1234567891011121314// 绑定事件function addEvent(obj,type,fn)&#123; obj.listener = obj.listener || &#123;&#125;; obj.listener[type] = obj.listener[type] || []; obj.listener[type].push(fn);&#125;// 触发事件function fireEvent(obj,type)&#123; var arr = obj.listener[type]; for (var i = 0; i &lt; arr.length; i++) &#123; arr[i](); &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[drag Event]]></title>
      <url>%2F2016%2F10%2F22%2F23-%E6%8B%96%E6%8B%89%E4%BA%8B%E4%BB%B6%2F</url>
      <content type="text"><![CDATA[拖拉事件拖拉指的是，用户在某个对象上按下鼠标键不放，拖动它到另一个位置，然后释放鼠标键，将该对象放在那里。 拖拉的对象有好几种，包括Element节点、图片、链接、选中的文字等等。在HTML网页中，除了Element节点默认不可以拖拉，其他（图片、链接、选中的文字）都是可以直接拖拉的。为了让Element节点可拖拉，可以将该节点的draggable属性设为true。注意draggable 是元素的属性，并不是元素的样式属性，设置在CSS样式表或者标签中是没有用的 123&lt;div draggable="true"&gt; 此区域可拖拉&lt;/div&gt; draggable属性可用于任何Element节点，但是图片（img元素）和链接（a元素）不加这个属性，就可以拖拉。对于它们，用到这个属性的时候，往往是将其设为false，防止拖拉。 注意，一旦某个Element节点的draggable属性设为true，就无法再用鼠标选中该节点内部的文字或子节点了。 事件种类当Element节点或选中的文本被拖拉时，就会持续触发拖拉事件，包括以下一些事件。 drag事件：拖拉过程中，在被拖拉的节点上持续触发。 dragstart事件：拖拉开始时在被拖拉的节点上触发，该事件的target属性是被拖拉的节点。通常应该在这个事件的监听函数中，指定拖拉的数据。 dragend事件：拖拉结束时（释放鼠标键或按下escape键）在被拖拉的节点上触发，该事件的target属性是被拖拉的节点。它与dragStart事件，在同一个节点上触发。不管拖拉是否跨窗口，或者中途被取消，dragend事件总是会触发的。 dragenter事件：拖拉进入当前节点时，在当前节点上触发，该事件的target属性是当前节点。通常应该在这个事件的监听函数中，指定是否允许在当前节点放下（drop）拖拉的数据。如果当前节点没有该事件的监听函数，或者监听函数不执行任何操作，就意味着不允许在当前节点放下数据。在视觉上显示拖拉进入当前节点，也是在这个事件的监听函数中设置。 dragover事件：拖拉到当前节点上方时，在当前节点上持续触发，该事件的target属性是当前节点。该事件与dragenter事件基本类似，默认会重置当前的拖拉事件的效果（DataTransfer对象的dropEffect属性）为none，即不允许放下被拖拉的节点，所以如果允许在当前节点drop数据，通常会使用preventDefault方法，取消重置拖拉效果为none。 dragleave事件：拖拉离开当前节点范围时，在当前节点上触发，该事件的target属性是当前节点。在视觉上显示拖拉离开当前节点，就在这个事件的监听函数中设置。 drop事件：被拖拉的节点或选中的文本，释放到目标节点时，在目标节点上触发。注意，如果当前节点不允许drop，即使在该节点上方松开鼠标键，也不会触发该事件。如果用户按下Escape键，取消这个操作，也不会触发该事件。该事件的监听函数负责取出拖拉数据，并进行相关处理。 关于拖拉事件，有以下几点注意事项。 拖拉过程只触发以上这些拖拉事件，尽管鼠标在移动，但是鼠标事件不会触发。 将文件从操作系统拖拉进浏览器，不会触发dragStart和dragend事件。 dragenter和dragover事件的监听函数，用来指定可以放下（drop）拖拉的数据。由于网页的大部分区域不适合作为drop的目标节点，所以这两个事件的默认设置为当前节点不允许drop。如果想要在目标节点上drop拖拉的数据，首先必须阻止这两个事件的默认行为，或者取消这两个事件。 12&lt;div ondragover="return false"&gt;&lt;div ondragover="event.preventDefault()"&gt; 上面代码中，如果不取消拖拉事件或者阻止默认行为，就不可能在div节点上drop被拖拉的节点。 拖拉事件用一个DragEvent对象表示，该对象继承MouseEvent对象，因此也就继承了UIEvent和Event对象。DragEvent对象只有一个独有的属性DataTransfer，其他都是继承的属性。DataTransfer属性用来读写拖拉事件中传输的数据，详见下文《DataTransfer对象》的部分。 下面的例子展示，如何动态改变被拖动节点的背景色。 123456div.addEventListener("dragstart", function(e) &#123; this.style.backgroundColor = "red";&#125;, false);div.addEventListener("dragend", function(e) &#123; this.style.backgroundColor = "green";&#125;, false); 上面代码中，div节点被拖动时，背景色会变为红色，拖动结束，又变回绿色。 下面是一个例子，显示如何实现将一个节点从当前父节点，拖拉到另一个父节点中。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// HTML代码为// &lt;div class="dropzone"&gt;// &lt;div id="draggable" draggable="true"&gt;// 该节点可拖拉// &lt;/div&gt;// &lt;/div&gt;// &lt;div class="dropzone"&gt;&lt;/div&gt;// &lt;div class="dropzone"&gt;&lt;/div&gt;// &lt;div class="dropzone"&gt;&lt;/div&gt;// 被拖拉节点var dragged;document.addEventListener("dragstart", function( event ) &#123; // 保存被拖拉节点 dragged = event.target; // 被拖拉节点的背景色变透明 event.target.style.opacity = 0.5; // 兼容Firefox event.dataTransfer.setData('text/plain', 'anything');&#125;, false);document.addEventListener('dragend', function( event ) &#123; // 被拖拉节点的背景色恢复正常 event.target.style.opacity = '';&#125;, false);document.addEventListener('dragover', function( event ) &#123; // 防止拖拉效果被重置，允许被拖拉的节点放入目标节点 event.preventDefault();&#125;, false);document.addEventListener('dragenter', function( event ) &#123; // 目标节点的背景色变紫色 // 由于该事件会冒泡，所以要过滤节点 if ( event.target.className == 'dropzone' ) &#123; event.target.style.background = 'purple'; &#125;&#125;, false);document.addEventListener('dragleave', function( event ) &#123; // 目标节点的背景色恢复原样 if ( event.target.className == 'dropzone' ) &#123; event.target.style.background = ""; &#125;&#125;, false);document.addEventListener('drop', function( event ) &#123; // 防止事件默认行为（比如某些Elment节点上可以打开链接） event.preventDefault(); if ( event.target.className === 'dropzone' ) &#123; // 恢复目标节点背景色 event.target.style.background = ''; // 将被拖拉节点插入目标节点 dragged.parentNode.removeChild( dragged ); event.target.appendChild( dragged ); &#125;&#125;, false); DataTransfer对象概述所有的拖拉事件都有一个dataTransfer属性，用来保存需要传递的数据。这个属性的值是一个DataTransfer对象。 拖拉的数据保存两方面的数据：数据的种类（又称格式）和数据的值。数据的种类是一个MIME字符串，比如 text/plain或者image/jpeg，数据的值是一个字符串。一般来说，如果拖拉一段文本，则数据默认就是那段文本；如果拖拉一个链接，则数据默认就是链接的URL。 当拖拉事件开始的时候，可以提供数据类型和数据值；在拖拉过程中，通过dragenter和dragover事件的监听函数，检查数据类型，以确定是否允许放下（drop）被拖拉的对象。比如，在只允许放下链接的区域，检查拖拉的数据类型是否为text/uri-list。 发生drop事件时，监听函数取出拖拉的数据，对其进行处理。 DataTransfer对象的属性DataTransfer对象有以下属性。 （1）dropEffect dropEffect属性设置放下（drop）被拖拉节点时的效果，可能的值包括copy（复制被拖拉的节点）、move（移动被拖拉的节点）、link（创建指向被拖拉的节点的链接）、none（无法放下被拖拉的节点）。设置除此以外的值，都是无效的。 12345target.addEventListener('dragover', function(e) &#123; e.preventDefault(); e.stopPropagation(); e.dataTransfer.dropEffect = 'copy';&#125;); dropEffect属性一般在dragenter和dragover事件的监听函数中设置，对于dragstart、drag、dragleave这三个事件，该属性不起作用。进入目标节点后，拖拉行为会初始化成用户设定的效果，用户可以通过按下Shift键和Control键，改变初始设置，在copy、move、link三种效果中切换。 鼠标箭头会根据dropEffect属性改变形状，提示目前正处于哪一种效果。这意味着，通过鼠标就能判断是否可以在当前节点drop被拖拉的节点。 （2）effectAllowed effectAllowed属性设置本次拖拉中允许的效果，可能的值包括copy（复制被拖拉的节点）、move（移动被拖拉的节点）、link（创建指向被拖拉节点的链接）、copyLink（允许copy或link）、copyMove（允许copy或move）、linkMove（允许link或move）、all（允许所有效果）、none（无法放下被拖拉的节点）、uninitialized（默认值，等同于all）。如果某种效果是不允许的，用户就无法在目标节点中达成这种效果。 dragstart事件的监听函数，可以设置被拖拉节点允许的效果；dragenter和dragover事件的监听函数，可以设置目标节点允许的效果。 1event.dataTransfer.effectAllowed = "copy"; dropEffect属性和effectAllowed属性，往往配合使用。 12event.dataTransfer.effectAllowed = "copyMove";event.dataTransfer.dropEffect = "copy"; 上面代码中，copy是指定的效果，但是可以通过Shift或Ctrl键（根据平台而定），将效果切换成move。 只要dropEffect属性和effectAllowed属性之中，有一个为none，就无法在目标节点上完成drop操作。 （3）files files属性是一个FileList对象，包含一组本地文件，可以用来在拖拉操作中传送。如果本次拖拉不涉及文件，则属性为空的FileList对象。 下面就是一个接收拖拉文件的例子。 1234567891011121314151617181920212223242526// HTML代码为// &lt;div id="output" style="min-height: 200px;border: 1px solid black;"&gt;// 文件拖拉到这里// &lt;/div&gt;var div = document.getElementById('output');div.addEventListener("dragenter", function( event ) &#123; div.textContent = ''; event.stopPropagation(); event.preventDefault();&#125;, false);div.addEventListener("dragover", function( event ) &#123; event.stopPropagation(); event.preventDefault();&#125;, false);div.addEventListener("drop", function( event ) &#123; event.stopPropagation(); event.preventDefault(); var files = event.dataTransfer.files; for (var i = 0; i &lt; files.length; i++) &#123; div.textContent += files[i].name + ' ' + files[i].size + '字节\n'; &#125;&#125;, false); 上面代码中，通过files属性读取拖拉文件的信息。如果想要读取文件内容，就要使用FileReader对象。 1234567891011121314151617div.addEventListener('drop', function(e) &#123; e.preventDefault(); e.stopPropagation(); var fileList = e.dataTransfer.files; if (fileList.length &gt; 0) &#123; var file = fileList[0]; var reader = new FileReader(); reader.onloadend = function(e) &#123; if (e.target.readyState == FileReader.DONE) &#123; var content = reader.result; contentDiv.innerHTML = "File: " + file.name + "\n\n" + content; &#125; &#125; reader.readAsBinaryString(file); &#125;&#125;); （4）types types属性是一个数组，保存每一次拖拉的数据格式，比如拖拉文件，则格式信息就为File。 下面是一个例子，通过检查dataTransfer属性的类型，决定是否允许在当前节点执行drop操作。 1234567891011function contains(list, value)&#123; for( var i = 0; i &lt; list.length; ++i )&#123; if(list[i] === value) return true; &#125; return false;&#125;function doDragOver(event)&#123; var isLink = contains( event.dataTransfer.types, "text/uri-list"); if (isLink) event.preventDefault();&#125; 上面代码中，只有当被拖拉的节点是一个链接时，才允许在当前节点放下。 DataTransfer对象的方法DataTransfer对象有以下方法。 （1）setData() setData方法用来设置事件所带有的指定类型的数据。它接受两个参数，第一个是数据类型，第二个是具体数据。如果指定的类型在现有数据中不存在，则该类型将写入types属性；如果已经存在，在该类型的现有数据将被替换。 1event.dataTransfer.setData("text/plain", "Text to drag"); 上面代码为事件加入纯文本格式的数据。 如果拖拉文本框或者拖拉选中的文本，会默认将文本数据添加到dataTransfer属性，不用手动指定。 1234&lt;div draggable="true" ondragstart=" event.dataTransfer.setData('text/plain', 'bbb')"&gt; aaa&lt;/div&gt; 上面代码中，拖拉数据实际上是bbb，而不是aaa。 下面是添加其他类型的数据。由于text/plain是最普遍支持的格式，为了保证兼容性，建议最后总是将数据保存一份纯文本的格式。 1234567891011var dt = event.dataTransfer;// 添加链接dt.setData("text/uri-list", "http://www.example.com");dt.setData("text/plain", "http://www.example.com");// 添加HTML代码dt.setData("text/html", "Hello there, &lt;strong&gt;stranger&lt;/strong&gt;");dt.setData("text/plain", "Hello there, &lt;strong&gt;stranger&lt;/strong&gt;");// 添加图像的URLdt.setData("text/uri-list", imageurl);dt.setData("text/plain", imageurl); 可以一次提供多种格式的数据。 1234var dt = event.dataTransfer;dt.setData("application/x-bookmark", bookmarkString);dt.setData("text/uri-list", "http://www.example.com");dt.setData("text/plain", "http://www.example.com"); 上面代码中，通过在同一个事件上面，存放三种类型的数据，使得拖拉事件可以在不同的对象上面，drop不同的值。注意，第一种格式是一个自定义格式，浏览器默认无法读取，这意味着，只有某个部署了特定代码的节点，才可能drop（读取到）这个数据。 （2）getData() getData方法接受一个字符串（表示数据类型）作为参数，返回事件所带的指定类型的数据（通常是用setData方法添加的数据）。如果指定类型的数据不存在，则返回空字符串。通常只有drop事件触发后，才能取出数据。如果取出另一个域名存放的数据，将会报错。 下面是一个drop事件的监听函数，用来取出指定类型的数据。 12345function onDrop(event)&#123; var data = event.dataTransfer.getData("text/plain"); event.target.textContent = data; event.preventDefault();&#125; 上面代码取出拖拉事件的文本数据，将其替换成当前节点的文本内容。注意，这时还必须取消浏览器的默认行为，因为假如用户拖拉的是一个链接，浏览器默认会在当前窗口打开这个链接。 getData方法返回的是一个字符串，如果其中包含多项数据，就必须手动解析。 12345678910function doDrop(event)&#123; var lines = event.dataTransfer.getData("text/uri-list").split("\n"); for (let line of lines) &#123; let link = document.createElement("a"); link.href = line; link.textContent = line; event.target.appendChild(link); &#125; event.preventDefault();&#125; 上面代码中，getData方法返回的是一组链接，就必须自行解析。 类型值指定为URL，可以取出第一个有效链接。 1var link = event.dataTransfer.getData("URL"); 下面是一次性取出多种类型的数据。 12345678function doDrop(event)&#123; var types = event.dataTransfer.types; var supportedTypes = ["text/uri-list", "text/plain"]; types = supportedTypes.filter(function (value) types.includes(value)); if (types.length) var data = event.dataTransfer.getData(types[0]); event.preventDefault();&#125; （3）clearData() clearData方法接受一个字符串（表示数据类型）作为参数，删除事件所带的指定类型的数据。如果没有指定类型，则删除所有数据。如果指定类型不存在，则原数据不受影响。 1event.dataTransfer.clearData("text/uri-list"); 上面代码清除事件所带的URL数据。 （4）setDragImage() 拖动过程中（dragstart事件触发后），浏览器会显示一张图片跟随鼠标一起移动，表示被拖动的节点。这张图片是自动创造的，通常显示为被拖动节点的外观，不需要自己动手设置。setDragImage方法可以用来自定义这张图片，它接受三个参数，第一个是img图片元素或者canvas元素，如果省略或为null则使用被拖动的节点的外观，第二个和第三个参数为鼠标相对于该图片左上角的横坐标和右坐标。 下面是一个例子。 1234567891011// HTML代码为// &lt;div id="drag-with-image" class="dragdemo" draggable="true"&gt; drag me// &lt;/div&gt;var div = document.getElementById("drag-with-image");div.addEventListener("dragstart", function(e) &#123; var img = document.createElement("img"); img.src = "http://path/to/img"; e.dataTransfer.setDragImage(img, 0, 0);&#125;, false);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[URL operation]]></title>
      <url>%2F2016%2F10%2F22%2F149URLoperation%2F</url>
      <content type="text"><![CDATA[如何操作查询字符串，返回一个查询字符串包含信息的对象 12345678910111213var url ='http://www.myvirtual.com?username=Jhon&amp;age=12';//将查询字符串转换为js对象function queryParam(url)&#123; var newUrl = url.slice(url.indexOf('?')+1); var urlArr = newUrl.split('&amp;'); var ret = &#123;&#125; for(var i = 0 ; i &lt; urlArr.length ; i++)&#123; var arr = urlArr[i].split('='); ret[arr[0]] = arr[1]; &#125; return ret ;&#125;queryParam(url);]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[NodeJs Buffer]]></title>
      <url>%2F2016%2F10%2F22%2F146NodeJsBuffer%2F</url>
      <content type="text"><![CDATA[1 Buffer类的定义:本质上是创建了一块专门存放二进制数据的缓存区 JavaScript 语言自身只有字符串数据类型，没有二进制数据类型。 但在处理像TCP流或文件流时，必须使用到二进制数据。因此在 Node.js中，定义了一个 Buffer 类，该类用来创建一个专门存放二进制数据的缓存区。 在 Node.js 中，Buffer 类是随 Node 内核一起发布的核心库。Buffer 库为 Node.js 带来了一种存储原始数据的方法，可以让 Node.js 处理二进制数据，每当需要在 Node.js 中处理I/O操作中移动的数据时，就有可能使用 Buffer 库。原始数据存储在 Buffer 类的实例中。一个 Buffer 类似于一个整数数组，但它对应于 V8 堆内存之外的一块原始内存。 2 如何创建Buffer实例 1var buf = new Buffer(arg) //1 必须传入参数 2 传入的参数类型 string, Buffer, ArrayBuffer, Array, or array-like object. 12345678910111213141516171819202122232425var buf1 = new Buffer(10);//这个是指定Buffer实例的长度，区分 var buf1 = new Buffer('10');console.log(buf1);console.log(buf1.length);console.log(buf1.toString());var buf2 = new Buffer([10, 40, 30]);//数组的长度 作为Buffer实例的长度console.log(buf2);console.log(buf2.length);//buf2.write('hahhahahahhah')console.log(buf2.toString());var buf3 = new Buffer(&#123;length:12&#125;);//类数组对象 的长度作为Buffer的长度console.log(buf3);console.log(buf3.length);console.log(buf3.toString());var buf4 = new Buffer('this is it yeah'); //直接将字符串写入Buffer实例，长度等于字符串的长度console.log(buf4);console.log(buf4.length);console.log(buf4.toString());var buf5 = new Buffer(buf4);//将Buffer实例直接作为参数传入console.log(buf5);console.log(buf5.length);console.log(buf5.toString()); 3 向缓冲区写入数据以及读取数据 12345678buf.write(string[, offset[, length]][, encoding])参数描述如下： string - 写入缓冲区的字符串。 offset - 缓冲区开始写入的索引值，默认为 0 。 length - 写入的字节数，默认为 buffer.length encoding - 使用的编码。默认为 'utf8' 。返回值 返回实际写入的大小。如果 buffer 空间不足， 则只会写入部分字符串。 1234567buf.toString([encoding[, start[, end]]])参数描述如下： encoding - 使用的编码。默认为 'utf8' 。 start - 指定开始读取的索引位置，默认为 0。 end - 结束位置，默认为缓冲区的末尾。返回值 解码缓冲区数据并使用指定的编码返回字符串。 1buf.length; 返回Buffer实例实际所占据的内存的长度 1buf.toJSON();将Buffer实例转化为JSON对象 12buf.slice(start,end);默认start 0 end 为buf.length 返回一个新的缓冲区，它和旧缓冲区指向同一块内存，但是从索引 start 到 end 的位置剪切。 1Buffer.concat(list[, totalLength]) 返回一个多个成员合并的新 Buffer 对象。 12345678910111213141516171819202122232425//console.log(Buffer) 可以尝试着输入下Buffer类，看下其属性和方法var buf = new Buffer('this is it yeah');console.log(buf);console.log(buf.length);//15console.log(buf.toString());var wLen = buf.write('changed?');console.log(buf.toString());//changed?it yeahconsole.log(wLen);//8console.log(buf.toJSON());/*&#123; type: 'Buffer', data: [ 99, 104, 97, 110, 103, 101, 100, 63, 105, 116, 32, 121, 101, 97, 104 ] &#125; */var sliceBuf = buf.slice(2,5);console.log(sliceBuf);console.log(sliceBuf.length);//3console.log(sliceBuf.toString());//angvar con = Buffer.concat ([buf,sliceBuf]);console.log(con);console.log(con.length);//18console.log(con.toString());//changed?it yeahang]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[RegExp Review]]></title>
      <url>%2F2016%2F10%2F22%2F127RegExpReview%2F</url>
      <content type="text"><![CDATA[先来看下正则中的特殊字符 特别字符 说明 $ 匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则 $ 也匹配 ‘\n’ 或 ‘\r’。要匹配 $ 字符本身，请使用 \$。 ( ) 标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用 \( 和 \)。 * 匹配前面的子表达式零次或多次。要匹配 字符，请使用 \。 + 匹配前面的子表达式一次或多次。要匹配 + 字符，请使用 +。 . 匹配除换行符 \n之外的任何单字符。要匹配 .，请使用 \。 [ ] 标记一个中括号表达式的开始。要匹配 [，请使用 [。 ? 匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。要匹配 ? 字符，请使用 \?。 \ 将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， ‘n’ 匹配字符‘n’。’\n’ 匹配换行符。序列 ‘\‘ 匹配 “\”，而 ‘(‘ 则匹配 “(”。 ^ 匹配输入字符串的开始位置，除非在方括号表达式中使用，此时它表示不接受该字符集合。要匹配 ^ 字符本身，请使用 \^。 { } 标记限定符表达式的开始。要匹配 {，请使用 {。 \ 指明两项之间的一个选择。要匹配 \ ，请使用 \ 。 正则中的限定符 字符 描述 * 匹配前面的子表达式零次或多次。例如，zo 能匹配 “z” 以及 “zoo”。 等价于{0,}。 + 匹配前面的子表达式一次或多次。例如，’zo+’ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 {1,}。 ? 匹配前面的子表达式零次或一次。例如，”do(es)?” 可以匹配 “do” 或 “does” 中的”do” 。? 等价于 {0,1}。 {n} n 是一个非负整数。匹配确定的 n 次。例如，’o{2}’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o。 {n,} n 是一个非负整数。至少匹配n 次。例如，’o{2,}’ 不能匹配 “Bob” 中的 ‘o’，但能匹配 “foooood” 中的所有 o。’o{1,}’ 等价于 ‘o+’。’o{0,}’ 则等价于 ‘o*’。 {n,m} m 和 n 均为非负整数，其中n &lt;= m。最少匹配 n 次且最多匹配 m 次。例如，”o{1,3}” 将匹配 “fooooood” 中的前三个 o。’o{0,1}’ 等价于 ‘o?’。请注意在逗号和两个数之间不能有空格。 正则中的操作符优先级 操作符 描述 \ 转义符 (), (?:), (?=), [ ] 圆括号和方括号 *, +, ?, {n}, {n,}, {n,m} 限定符 ^, $, \anymetacharacter 位置和顺序 \ “或”操作 1 单词字符包括 0-9 a-z A-Z _ 下划线 元字符 \w 查找单词字符 \W 查找非单词字符 123456var reg = /\byou/g; // \b可以匹配单词的边界,单词中以you开头的you将会被匹配到var result ;while((result = reg.exec(str)) != null)&#123; console.log(result); console.log(reg.lastIndex);&#125; 2 \b 元字符匹配单词边界 在单词边界匹配的位置，单词字符后面或前面不与另一个单词字符直接相邻 \B 元字符匹配非单词边界 通常用于查找不处在单词的开头或结尾的匹配 123456789var str = 'hello youthereyou yourighthere ';var reg2 = /\Bthere/g ;//用来匹配 不在单词开头的therevar result ;while((result = reg2.exec(str)) != null)&#123; console.log(result); console.log(reg2.lastIndex);&#125;//---------------------------------------------var reg2 = /there\B/g ;//匹配不在单词结尾的there 3 . 元字符用于查找单个字符，除了换行和行结束符。 12345678910//exec() 方法用于检索字符串中的正则表达式的匹配。如果找不到，则返回nullvar str = 'that is hot';var reg = /h.t/g;var ret ;while( (ret = reg.exec(str) ) != null)&#123; console.log(ret);// Array[1][0:"hat"index:1,input:"that is hot",length:1] //Array[1][0:"hot"index:8,input:"that is hot",length:1] console.log(reg.lastIndex);// 4 11 exec()方法 RegExpObject 的 lastIndex 属性设置为匹配文本的最后一个字符的下一个位置&#125; 12345//match() 方法可在字符串内检索指定的值，或找到一个或多个正则表达式的匹配。返回匹配结果的数组，如果找不到返回nullvar str = 'that is hot';var reg = /h.t/g;var ret = str.match(reg);console.log(ret1);//["hat", "hot"] 4 \s]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Angular Js directive]]></title>
      <url>%2F2016%2F10%2F21%2F175Angular-Js-directive%2F</url>
      <content type="text"><![CDATA[1 自定义指令中的scope属性详解]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[几种缓存的总结]]></title>
      <url>%2F2016%2F10%2F19%2F178%E5%87%A0%E7%A7%8D%E7%BC%93%E5%AD%98%E7%9A%84%E6%80%BB%E7%BB%93%2F</url>
      <content type="text"><![CDATA[几种缓存的总结 1 DNS缓存 为了增加访问效率，计算机有域名缓存机制，当访问过某个网站并得到其IP后，会将其域名和IP缓存下来，下一次访问的时候，就不需要再请求域名服务器获取IP，直接使用缓存中的IP，提高了响应的速度。当然缓存是有有效时间的，当过了有效时间后，再次请求网站，还是需要先请求域名解析。 但是域名缓存机制也可能会带来麻烦。例如IP已变化了，仍然使用缓存中的IP来访问，将会访问失败。再如 同一个域名在内网和外网访问时所对应的IP是不同的，如在外网访问时通过外网IP映射到内网的IP。同一台电脑在外网环境下访问了此域名，再换到内网来访问此域名，在DNS缓存的作用下，也会去访问外网的IP，导致访问失败。根据情况，可以手动清除DNS缓存或者禁止DNS缓存机制。 2 CDN缓存 用户在浏览网站的时候，浏览器能够在本地保存网站中的图片或者其他文件的副本，这样用户再次访问该网站的时候，浏览器就不用再下载全部的文件，减少了下载量意味着提高了页面加载的速度。 如果中间加上一层CDN，客户端浏览器先检查是否有本地缓存是否过期，如果过期，则向CDN边缘节点发起请求，CDN边缘节点会检测用户请求数据的缓存是否过期，如果没有过期，则直接响应用户请求，此时一个完成http请求结束；如果数据已经过期，那么CDN还需要向源站发出回源请求（back to the source request）,来拉取最新的数据 3 浏览器端缓存http缓存 localStorage缓存 sessionStorage缓存 cookies缓存 application cache缓存 4 服务器缓存]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[如何解决移动端两栏自适应的问题]]></title>
      <url>%2F2016%2F10%2F18%2F37-%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E7%A7%BB%E5%8A%A8%E7%AB%AF%E4%B8%A4%E6%A0%8F%E8%87%AA%E9%80%82%E5%BA%94%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%9F%2F</url>
      <content type="text"><![CDATA[如何解决移动端两栏自适应的问题？overflow:hidden 要求：第一水平方向不要有滚动条；第二，水平第一个侧栏宽度固定，第二个侧栏宽度自适应 1 明确元素的宽度：块级元素 默认占据整行，如果不设置宽度，则默认和父元素等宽；行内块元素的宽度由内容决定，可以自行设置；行内元素的宽度由内容决定，不可设置宽高； 2 设置了浮动或者定位的层的宽宽由内容决定，发生元素转换，display:inline-block; 3 目的是实现 ：右边栏的宽度 = 屏幕宽度 - 左边栏宽度 ，以此来实现右边栏里面的内容进行百分比设置宽度以自适应屏幕的时候，是以 右边栏的宽度 = 屏幕宽度 - 左边栏宽度 为基准的。 4 注意理解块级元素的流体特性:在默认情况下(非浮动、定位)，块级元素会默认在水平方向自动填满外部的容器(自动填满父元素)。 5 浮动元素left和触发了BFC特性的元素right,right栏自适应，right设置overflow:hdden,触发BFC特性，即可实现right自动填充剩余的空间，而不是那种文字环绕图片的效果。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang="en"&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0"/&gt; &lt;!--设置移动端视觉窗口，宽度和移动终端设备等宽--&gt; &lt;style&gt; body&#123; margin: 0; padding: 0; &#125; .phone &#123; width: 100%; height: 100%; position: absolute; border: 1px solid #000000; &#125; .left&#123; width: 90px; height: 100%; float: left; background: red; overflow: hidden; &#125; /*产出一个绝缘的盒子 别的浮动不影响它 它也不影响其他的浮动， 左边盒子设置浮动，宽度固定*/ /*bfc*/ .right&#123; height: 100%; background-color: skyblue; overflow: hidden; &#125; /*可以点击绿色按钮，看下右边层的宽度，两种情况overflow:hidden 存在与否，overflow:hidden触发了BFC使其不会受浮动元素的影响，同时其也不会影响浮动元素 overflow存在的时候，可使右边的盒子自动填充剩余的宽度，以实现自适应布局*/ input &#123; display:block; height: 40px; width: 30px; background-color: green; &#125; img&#123; width: 50%; /*根据right的宽度为基准进行设置自身的宽度，以此来实现自适应布局*/ &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="phone"&gt; &lt;div class="left"&gt;&lt;/div&gt; &lt;div class="right"&gt; &lt;input type="button"/&gt; &lt;img src="img/01.jpg" alt="" /&gt; &lt;/div&gt;&lt;/div&gt;&lt;script&gt; document.querySelector("input").onclick=function()&#123; console.log("bingo"); var right = document.querySelector(".right") console.log(right.offsetWidth); &#125;;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 6 注意：高潮来了，如何设置left和right之间的间隙呢？ 给right设置margin-right 或者 padding-left 1234.right &#123; margin-left:100px;&#125;结果是left和right还是粘连在一起，不起作用，因为BFC元素设置margin-left和float元素混排是不起作用的 1234.right &#123; padding-left:20px; &#125; 这个会起作用，可以将两栏隔开一定的距离 给left设置margin-right 或者 padding-right 来撑开两栏之间的间隙 12345.left &#123; padding-right:20px ;或者 margin-right:20px ;&#125; 7 BFC自适应布局的组件化代码 1234567.left&#123; float:left; margin-right:20px;&#125;.right &#123; overflow:hidden ;&#125; 8 如果是右边栏宽度固定，左边栏宽度自适应呢？ 解析顺序不同会导致占位不同，所以只需要将右边写在左边前面即可 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang="en"&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0"/&gt; &lt;!--设置移动端视觉窗口，宽度和移动终端设备等宽--&gt; &lt;style&gt; body&#123; margin: 0; padding: 0; &#125; .phone &#123; /*width: 320px;*/ /*height: 480px;*/ width: 100%; height: 100%; position: absolute; border: 1px solid #000000; &#125; .left&#123; height: 100%; background-color: skyblue; overflow: hidden; /*两栏自适应留白*/ &#125; /*产出一个绝缘的盒子 别的浮动不影响它 它也不影响其他的浮动*/ /*bfc*/ .right&#123; width: 90px; height: 100%; float: right ; background: red; &#125; /*右边盒子设置自适应的宽度*/ input &#123; display:block; height: 40px; width: 30px; background-color: green; z-index: 999; &#125; img&#123; width: 50%; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="phone"&gt; &lt;div class="right"&gt; &lt;input type="button"/&gt; &lt;/div&gt; &lt;div class="left"&gt;&lt;/div&gt;&lt;/div&gt;&lt;script&gt; document.querySelector("input").onclick=function()&#123; console.log("bingo"); var right = document.querySelector(".right") console.log("右边盒子宽度:"+right.offsetWidth); &#125;;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Angular Js angularModule]]></title>
      <url>%2F2016%2F10%2F17%2F161AngularJsModule%2F</url>
      <content type="text"><![CDATA[1 模块的定义 module是angular中重要的模块组织方式，它提供了将一组内聚的业务组件（controller、service、filter、directive…）封装在一起的能力。这样做可以将代码按照业务领域问题分module的封装，然后利用module的依赖注入其关联的模块内容，使得我们能够更好的”分离关注点“，达到更好的”高内聚低耦合“。”高内聚低耦合“是来自面向对象设计原则。内聚是指模块或者对象内部的完整性，一组紧密联系的逻辑应该被封装在同一模块、对象等代码单元中，而不是分散在各处；耦合则指模块、对象等代码单元之间的依赖程度，如果一个模块的修改，会影响到另一个模块，则说明这两模块之间是相互依赖紧耦合的。 同时module也是我们angular代码的入口，首先需要声明module，然后才能定义angular中的其他组件元素，如controller、service、filter、directive、config代码块、run代码块等。 关于module的定义为：angular.module(‘com.ngbook.demo’, [])。关于module函数可以传递3个参数，它们分别为： name：模块定义的名称，它应该是一个唯一的必选参数，它会在后边被其他模块注入或者是在ngAPP指令中声明应用程序主模块； requires：字符串的参数列表；模块的依赖，它是声明本模块需要依赖的其他模块的参数。特别注意：如果在这里没有声明模块的依赖，则我们是无法在模块中使用依赖模块的任何组件的；它是个可选参数。 configFn： 模块的启动配置函数，在angular config阶段会调用该函数，对模块中的组件进行实例化对象实例之前的特定配置，如我们常见的对$routeProvider配置应用程序的路由信息。它等同于”module.config“函数，建议用”module.config“函数替换它。这也是个可选参数。 我们可以打印出来angular全局对象和angular.module()这个方法返回的对象来更深入的了解它们之间的关系 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang="en"&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;mudule submit&lt;/title&gt; &lt;script src="./bower_components/angular/angular.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body &gt;&lt;script&gt; console.dir(angular); console.dir(angular.module("myModule",[]));&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 2 声明module之后，其他组件元素，如controller、service、filter、directive、config代码块、run代码块也就可以在对应的模块上使用了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Object对象assign方法]]></title>
      <url>%2F2016%2F10%2F13%2F101JS%E4%B8%AD%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D%2F</url>
      <content type="text"><![CDATA[JS中深拷贝和浅拷贝一 : 先来区分下一个小的细节 点操作符 和 [ ] 操作 对象属性的时候的区别 123456var arr = [12,13,14]; for(key in arr)&#123; console.log(key); //输出数组的索引 0,1,2··· console.log(arr.key); //undefined undefined undefined console.log(arr[key]); // 12 13 14 &#125; 12345678910var obj = &#123; name:"Jhon", age:13, address:"American" &#125; for(key in obj)&#123; console.log(key); // name age address console.log(obj.key); //undefined undefined undefined console.log(obj[key]); // Jhon 13 American &#125; 123456789101112var obj = &#123; name:"Jhon", age:13, address:"American" &#125; console.log(obj.name) //Jhon console.log(obj["name"]) //Jhon var key = "name";console.log(obj[key]) //Jhon console.log(obj.key) //Jhon //[] 可以接受变量，点操作符不可以 二 下面来实现一个浅拷贝的源码: 浅拷贝是指在复制一个对象的时候，仅仅对第一层的键值对进行复制，第二层的对象复制的是一个地址 1234567891011121314151617181920212223242526272829303132 function shadowCopy (target,source)&#123; if(!source || typeof source !== 'object')&#123; //source必须是对象 return; &#125; if(!target || typeof target !== 'object')&#123; return; &#125; for(var key in source)&#123; if(source.hasOwnProperty(key))&#123; target[key] = source[key];//注意必须用[]形式，不能用点操作符 &#125; &#125; &#125; var obj1 = &#123; name:"Jhon", age:13, address:"American", other:&#123; //other是一个对象 gender:"man" &#125; &#125; var obj2 = &#123;&#125;; shadowCopy(obj2,obj1); console.dir(obj2); //浅拷贝有一个问题，就是复制的obj2中的other和obj1中的other指向的是同一个对象 obj1.name = "JiM"; obj1.other.gender = "woman"; //修改obj1中的属性gender console.log(obj2.name);//Jhon // obj2中的name不会跟着改变 console.log(obj2.other.gender);//woman //obj2中的gender也跟着改变//基本数据类型复制传值，复杂数据类型的复制传地址，这个是内因//这是浅拷贝的一个缺陷，虽然说也拷贝了一份，但是对于对象的拷贝不够彻底 三 深拷贝原理如下:用到了递归 123456789101112131415161718function deepCopy (target,source)&#123; if(!source || typeof source !== 'object')&#123; //source必须是对象 return; &#125; if(!target || typeof target !== 'object')&#123; return; &#125; for(var key in source)&#123; if(source.hasOwnProperty(key))&#123; if(source[key] &amp;&amp; typeof source[key] == 'object')&#123; target[key] = &#123;&#125;; deepCopy(source[key],target[key]); &#125;else&#123; target[key] = source[key]; &#125; &#125; &#125; &#125; 注意数组的slice和concat方法其实是一种浅复制 123456789101112131415161718192021&lt;script&gt; var arr = [&#123; id : 1, price : '40', &#125;,&#123; id : 2, price : '30', &#125;,&#123; id : 3, price : '60', &#125;,&#123; id : 4, price : '30', &#125;]; var newArr = arr.slice(0); //复制数组 console.dir(newArr); console.dir(newArr[0].id); //1 arr[0].id = 666; console.dir(newArr[0].id); //666&lt;/script&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Object assign]]></title>
      <url>%2F2016%2F10%2F13%2F138Object-assign%2F</url>
      <content type="text"><![CDATA[1 先来看下字符串，数字和布尔类型转化为对象包装类 123456console.log(Object('abc'));console.log(typeof Object('abc'));console.log(Object(1));console.log(typeof Object(1));console.log(Object(true));console.log(typeof Object(true)); 2 Object.assign(target,source1,source2,······)；该方法会将source1,2对象的 可枚举的属性复制到target对象上，然后返回target对象 2.1 如果只传了一个参数，那么直接返回该参数，(如果传的是基本数据类型null和undefined会报错)，基本数据类型转化为包装对象，复杂数据类型直接返回 12345Object.assign(undefined) // 报错Object.assign(null) // 报错typeof Object.assign(2) // "object"var obj = &#123;a: 1&#125;;Object.assign(obj) === obj // true 2.2 如果传递了多个参数，那么进行赋值拷贝，注意assign方法执行的是浅拷贝，也就是说如果键值的值是复杂数据类型，那么复制的是地址,如果source有包装类型字符串可以进行赋值，null undefined 数字以及布尔类型会跳过 12345var obj1 = &#123;a: &#123;b: 1&#125;&#125;;var obj2 = Object.assign(&#123;&#125;, obj1);obj1.a.b = 2;obj2.a.b // 2 2.3 如果对象target的属性和source的属性名有重复的，那么会进行合并覆盖 1234var target = &#123; a: &#123; b: 'c', d: 'e' &#125; &#125;var source = &#123; a: &#123; b: 'hello' &#125; &#125;Object.assign(target, source)// &#123; a: &#123; b: 'hello' &#125; &#125; 2.4 原型上的属性以及不可枚举的属性不会被复制 123456789101112var obj = Object.create(&#123; foo: 1 &#125;, &#123; // foo is on obj's prototype chain. bar: &#123; value: 2 // bar is a non-enumerable property.默认emunerable属性值是false &#125;, baz: &#123; value: 3, enumerable: true // baz is an own enumerable property. &#125;&#125;);var copy = Object.assign(&#123;&#125;, obj);console.log(copy); // &#123; baz: 3 &#125; 3 assign经常的用法,以下代码都是有联系的 123let x = 'jhon';let y = 'jim'console.log(Object.assign(&#123;&#125;,&#123;x,y&#125;));//ES6对象的属性简写，如果x y未定义会报错 3.1 为对象添加属性 123456//第一用法添加对象的属性 class test &#123; constructor()&#123; Object.assign(this,&#123;x,y&#125;);//这里是对象的简写 &#125; &#125; 3.2 为对象添加方法 123456789101112//第二个用法，添加对象的方法 Object.assign(test.prototype,&#123; method1()&#123; console.log("this is method one"); &#125;, method2()&#123; console.log("this is method two"); &#125; &#125;) var t = new test(); console.log(t); 3.3 克隆对象 123456789101112function clone(origin)&#123; return Object.assign(&#123;&#125;,origin); &#125;; //如果想要克隆原型上的属性 function perfectClone(origin)&#123; let originPrototype = Object.getPrototypeOf(origin); return Object.assign(originPrototype,origin); &#125; var c = clone(t); console.log(c); var pc = perfectClone(t); console.log(pc); 3.4 合并多个对象 123const merge = (target,source1,source2) =&gt; Object.assign(target,source1,source2);var M = merge(t,c,pc);console.log(M); 3.5 为属性指定默认值 12const DEFAULTS = &#123;name:"Jhon",psw:"123456"&#125;;let loginIn = (option) =&gt; &#123;option = Object.assign(&#123;&#125;,DEFAULTS,option)&#125;;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Arrayfrom API ES6]]></title>
      <url>%2F2016%2F10%2F13%2F150Arrayfrom%20API%2F</url>
      <content type="text"><![CDATA[Array.from(arrayLike[, mapFn[, thisArg]]) 该方法从一个类似数组或可迭代对象创建一个新的数组实例 第一个参数是一个类数组对象， 第二个参数作为map函数的callback执行， 第三个参数是执行mapFn时候的this指向 返回值是一个新的数组实例 关于类数组对象只要该对象中有length属性， 即可认为是类数组对象 1 将类数组转化为数组 先抛出一个问题，这个也是在网上看到的 如何不使用loop循环，创建一个长度为100的数组，并且每个元素的值等于它的下标？ 以下测试均在chorm浏览器，火狐有的版本会直接初始化为undefined 123//很多人第一步如下var arr = Array(100);//但是这个是稀疏数组console.log(arr) ;//[] 如果使用Array.from就很简单了 123Array.from(arr);//这就成功创建了一个密集数组，所有的值都被初始化未undefinedArray.from(&#123;length:100&#125;);//这个和上面达成的效果是一致的//[undefined,undefined,undefined···········] 然后通过Object.keys(obj) 该方法返回obj对象的所有可枚举的属性的键值组成的 数组； 12Object.keys(Array.from(&#123;length:100&#125;))//[1,2,3,4······100] 当然了上面这些是ES6的新特性，如何在ES5中达到类似的效果呢？方法其实也很多 方法1 : 1234var arrayLike = &#123;length:100&#125;;var arr1 = [];arr1.push.apply(arr1,arrayLike );console.log(arr1);////[undefined,undefined,undefined···········] 方法2 : 1234var arrayLike = &#123;length:100&#125;;var arr2 = Array.apply(null,arrayLike ); //Array方法也是为了创建一个新的数组//注意必须用apply，apply会将传入的数组或者类数组对象中的属性一一传入调用apply的函数中console.log(arr2);////[undefined,undefined,undefined···········] 然后同样调用Object.keys(obj)方法即可； 2 将类数组转化的数组实例通过mapFn函数加工，返回一个加工后的数组 123var arrayLike = &#123;0:11,1:12,2:13,length:3&#125;;var newArr = Array.from(arrayLike,item =&gt; item*2);console.log(newArr);//[22,24,26]]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Array API ES6]]></title>
      <url>%2F2016%2F10%2F02%2F115-ES5%20%E6%95%B0%E7%BB%84Array%E6%96%B0%E5%A2%9EAPI%2F</url>
      <content type="text"><![CDATA[ES5 数组新增API1 数组的length属性,该属性是可读可写的 1234var arr = ['Jhon',66,"JiM"]；console.log(arr.length);//3 arr.length = 4 ;console.log(arr[4]);//undefined 2 Array.isArray(value) 该方法用来判断传递进来的参数是不是数组，如果是则返回true,否则返回false; Array.from(arrayLike[, mapFn[, thisArg]]) 参数 arrayLike 想要转换成真实数组的类数组对象 (只要该对象有length属性即可)或可遍历对象 mapFn 可选参数，如果指定了该参数，则最后生成的数组会经过该函数的加工处理后再返回。 thisArg 可选参数，执行 mapFn 函数时 this 的值。 返回值一个新的Array实例 123Array.from("foo"); // // ["f", "o", "o"] // 使用 map 函数转换数组元素Array.from([1, 2, 3], x =&gt; x + x); // [2, 4, 6] 3 Array.prototype.map (callback,thisArg ) 数组的map方法将向callback函数中传递三个参数，依次是每个数组元素，当前数组元素的索引，当前数组，callback执行的返回值 会作为数组元素添加到一个新的数组中去； 1Array.prototype.map(callback,thisArg);//thisArg严格模式下指向undefined ，非严格模式指向window 12345 var numberArr = [36,25,9,16]; var newNum = numberArr.map(Math.sqrt); console.log(newNum);//[6,5,3,4] console.log(numberArr);// [36,25,9,16]//map方法返回一个新的数组，不改变原数组 123456789//如何利用map方法获取每一个字符串的编码值 var str = "Learn more for great life"; var map = Array.prototype.map; var strArr = map.call(str,function(s)&#123; // 'use strict' console.log(this) ;//注意函数内部的this指向是window,'use strict'严格模式下是undefined; return s.charCodeAt(0);//注意必须有返回值，如果没有return ,默认返回undefined,生成的是一个undefined组成的数组 &#125;); console.log(strArr); 12345678//如何利用map方法翻转一个字符串,现将字符串转化为数组，然后将数组翻转，在将数组转化为字符串var str = "Learn more for great life";var map = Array.prototype.map;var strArr = map.call(str,function(s)&#123; return s;&#125;);var newStr = strArr.reverse().join("");console.log(newStr); 在网上又看到了一个更好地办法 12var str = '1234567';var revStr = str.split("").reverse().join(''); 123456789//猜一猜这个返回的数组是什么？ var arr = [1,2,3,4]; var newArr = arr.map(parseInt); console.log(newArr);//parseInt函数其实接受的是两个参数 parseInt(s,radix)一个是要转化的字符串，一个是转化的进制基数;//map函数传递给callback的是三个参数，一个数组元素，一个数组元素的索引值，一个是数组本身;//其实执行的是以下过程//parseInt(1,0) parse(2,1) parseInt(3,2) parseInt(4,3) 对于parseInt如果基数为0 ，按照十进制进行转化//所以输出结果是 [1 ,NaN,NaN,NaN] 3.1 callback 函数只会在有值的索引上被调用；那些数组中未初始化的元素或者使用 delete删除的索引则不会被调用 123456var arr1 = new Array(100);console.log(arr1);var arr = arr1.map(function(item,index)&#123; return index; //未被初始化的数组元素并不会调用callback函数&#125;)console.log(arr);//空数组 4 Array.prototype.forEach( callback , thisArg ) 数组的forEach 方法向callback回调函数中传递3 个参数，依次是每个数组元素，当前数组元素的索引，当前数组,forEach API 不像map API ,forEach每次执行callback并没有接受返回值，也不会返回一个数组，而map会将callback的返回值(如果没有显式的返回，则默认undefined)，形成一个新的数组，然后返回这个新的数组； 1Array.prorotype.forEach(callback,thisArg) //thisArg严格模式下指向undefined ，非严格模式指向window 123456789101112131415161718192021//thisArg可以用来改变forEach的callback函数执行时候this指向 function Counter()&#123; this.sum = 0; this.count = 0 ; &#125; Counter.prototype.add = function(array)&#123; array.forEach(function(item)&#123; this.sum += item ; ++this.count; console.log(this);//看下这个时候的this指向 &#125;,this); &#125; var arr = [9,6,2]; var counter = new Counter(); counter.add(arr); console.log(counter.sum); console.log(counter.count); 4.1 forEach 没有办法中止或者跳出 forEach 循环，除了抛出一个异常 1234var arr = [1,2,3,4]arr.forEach(function(item)&#123; console.log(item);//1,2,3,4&#125;) 12345var arr = [1,2,3,4]arr.forEach(function(item)&#123; console.log(item); break;//抛出异常&#125;) 4.2 如果在遍历的过程中，某个元素被删除了，那么会直接跳过该元素 1234567891011var arr = [0,1,2,3,4,5,6,7]arr.forEach(function(item,index,arr)&#123; console.log("item"+item); console.log("index"+index); console.log(arr);//index 会从索引0一直递增，如果期间删除了某一项，会使后面的元素所在索引位置发生变化 if(item === 2)&#123; arr.shift(); console.log(arr); &#125;&#125;) 4.3 forEach函数的返回值是undefined,所以它不能像map或者reduce函数那样，可以链式调用数组的方法，因为map函数会将callback每次的返回值存在一个数组中整体返回 123456var str = "Learn more for great life";var foreach = Array.prototype.forEach;var res = foreach.call(str,function(s)&#123; return s;&#125;);console.log(res);//undefined 4.4 forEach 方法按升序为数组中含有效值的每一项执行一次callback 函数，那些已删除（使用delete方法等情况）或者未初始化的项将被跳过（但不包括那些值为 undefined 的项） 12345var arr1 = new Array(100);//创建一个未被初始化的数组，数组的长度为100 console.log(arr1);arr1.forEach(function(item)&#123; console.log(item);//并不会输出任何值&#125;) 5 Array.prototype.every( callback , thisArg ) 数组的every方法向callback回调函数中传递3 个参数，依次是每个数组元素，当前数组元素的索引，当前数组,返回值是布尔类型；当执行某个元素返回值是false的时候，终止every函数的执行，返回false;只有当每个元素执行结果为true，最终才能返回true; 而 Array.prototype.some(callback ,thisArg) 和every基本上一样，只要有一个数组元素执行callback结果是true，那么就返回true，停止当前循环，不再进行后面的循环遍历操作； 1234567891011121314151617ParameterscallbackFunction to test for each element, taking three arguments:currentValue (required)The current element being processed in the array.index (optional)The index of the current element being processed in the array.array (optional)The array every was called upon.thisArgOptional. Value to use as this when executing callback.Return valuetrue if the callback function returns a truthy value for every array element; otherwise, false.DescriptionThe every method executes the provided callback function once for each element present in the array until it finds one where callback returns a falsy value. If such an element is found, the every method immediately returns false. Otherwise, if callback returns a truthy value for all elements, every returns true. callback is invoked only for indexes of the array which have assigned values; it is not invoked for indexes which have been deleted or which have never been assigned values. 123456function isBigEnough(element, index, array) &#123; return element &gt;= 10; &#125; [12, 5, 8, 130, 44].every(isBigEnough); // false [12, 54, 18, 130, 44].every(isBigEnough); // true 6 Array.prototype.reduce(callback ,[initialValue]) (reduceRight函数和reduce函数类似，只不是从数组的最后反向开始迭代);数组的reduce方法向callback函数传递四个参数，分别是 12345678910111213141516ParameterscallbackFunction to execute on each value in the array, taking four arguments:1 accumulatorThe accumulated value previously returned in the last invocation of the callback, or initialValue, if supplied. (See below.)(如果initialValue提供了，那么第一次运行的时候，accumular值为initialValue，如果没有提供initialValue，那么accumular的值为数组中的第一个元素，currentValue为数组中的第二个元素，跳过第一个索引值)2 currentValueThe current element being processed in the array.3 currentIndexThe index of the current element being processed in the array. Starts at index 0, if an initialValue is provided, and at index 1 otherwise.4 arrayThe array reduce was called upon.5 initialValueOptional. Value to use as the first argument to the first call of the callback.Return valueThe value that results from the reduction. reduce如何工作？ 12345678910[0, 1, 2, 3, 4].reduce( function ( accumulator, currentValue, currentIndex, array ) &#123; return accumulator + currentValue; &#125;); callback accumulator currentValue currentIndex array return value first call 0 1 1 [0, 1, 2, 3, 4] 1 second call 1 2 2 [0, 1, 2, 3, 4] 3 third call 3 3 3 [0, 1, 2, 3, 4] 6 fourth call 6 4 4 [0, 1, 2, 3, 4] 10 123456[0, 1, 2, 3, 4].reduce( (accumulator, currentValue, currentIndex, array) =&gt; &#123; return accumulator + currentValue; &#125;, 10); callback accumulator currentValue currentIndex array return value first call 10 0 0 [0, 1, 2, 3, 4] 10 second call 10 1 1 [0, 1, 2, 3, 4] 11 third call 11 2 2 [0, 1, 2, 3, 4] 13 fourth call 13 3 3 [0, 1, 2, 3, 4] 16 fifth call 16 4 4 [0, 1, 2, 3, 4] 20 reduce将callback函数的返回值作为accumulator传递给callback重复执行； ruduce函数经常用来扁平化数组 1234567var Flatten = [[1,2],[4,6],[7,9]]var newFaltten = Flatten.reduce(function(a,b)&#123; return a.concat(b);&#125;,[])console.log(Flatten);console.log(newFaltten); 7 Array.prototype.filter( callback ,thisArg ) filter向callback传递参数 依次是每个数组元素，当前数组元素的索引，当前数组。该方法返回一个新的数组，不改变原数组; filter函数对每个数组元素进行判断，满足条件的会保存下来，返回到新的数组当中，不满足条件的话进行下一个数组元素的判断(其实本质是如果callback函数返回true,那么保留当前数组元素，如果callback函数返回false,不保留该数组元素，那么进行对下一个数组元素的判断) 123456789101112131415 var arr = [2,3,4,5,6,7,8]; var newArr = arr.filter(function(item)&#123; return item &gt; 4 ; &#125;); console.log(arr); //[2,3,4,5,6,7,8]; console.log(newArr);//[5,6,7,8]//----------------------------------------------- var arr = [2,3,4,5,6,7,8]; var newArr = arr.filter(function(item)&#123; return true ; &#125;); console.log(arr); //[2,3,4,5,6,7,8] console.log(newArr); //[2,3,4,5,6,7,8]//如果是return false ;那么newArr = [] ;如果没有返回值，callback默认返回undefined,filter对undefined转化为false ,最后newArr还是空数组;//如果return 数字 字符串 等等 返回结果都是原来的数组，因为filter会对callback函数的返回值进行转化为布尔类型的值进行判断，如果转化结果为true ,那么则保留当前数组元素，如果转化结果为false,则不保留当前数组元素]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Array Sort]]></title>
      <url>%2F2016%2F10%2F02%2F104-%E6%95%B0%E7%BB%84%E7%9A%84sort%E6%96%B9%E6%B3%95-%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3%EF%BC%81%2F</url>
      <content type="text"><![CDATA[数组的sort方法—-改变原数组简单粗暴直接上代码咯(sort方法的定义请查阅W3C或者搜索) 注意:sort(fn) 方法可以接受一个 方法为参数 ，这个方法有两个参数。分别代表每次排序比较时的两个数组项。sort()排序时每次比较两个数组项都回执行这个参数，并把两个比较的数组项作为参数传递 给这个函数。 当函数返回值为 1 的时候就交换两个数组项的顺序，否则就不交换。 sort方法排序的关键是在于传入函数的返回值;改变原数组，并不产生新的数组；如果fn这个参数被省略，那么元素将按照 ASCII 字符顺序进行升序排列。 一 数字类型数组排序123456789var arr = [21,35,24,12,15,2,3,65,64] arr.sort(function()&#123; console.log(arguments); console.log(this); &#125;) //从控制台结果可以看出sort传递的函数默认有两个参数，这两个参数就是要排序的数组里面的两项 //函数执行的this指向window; //如果调用该方法时没有使用参数，将按字母顺序对数组中的元素进行排序，是按照字符编码的顺序进行排序。 12345678 var arr = [21,35,24,12,15,2,3,65,64] arr.sort(function(a,b)&#123; return a - b ; &#125;) //这种方法可以排序数字数组，却不能排序字符串数组，如下有代码案例 console.log(arr);//注意 - 操作符的运算，对于数字类型的运算数，结果返回数字 //a-b输出从小到大排序，b-a输出从大到小排序。 12345var arr = ['eca','bda','acf','dfe'];arr.sort()console.log(arr);//["acf", "bda", "dfe", "eca"]//如果调用该方法时没有使用参数，将按字母顺序对数组中的元素进行排序，说得更精确点，是按照字符编码的顺序进行排序。要实现这一点，首先应把数组的元素都转换成字符串（如有必要），以便进行比较 12345678var arr = ['eca','bda','acf','dfe']; arr.sort(function(a,b)&#123; return a - b ; &#125;) //这种方法不能排序字符串console.log(arr);//["eca", "bda", "acf", "dfe"]//这个排序功能就没有了，因为 - 运算符操作的运算数如果有一个不是数字，那么就会返回NaN，没有返回1 -1 或者0任意一个; 二 字符串数组排序那么如何才能排序字符串呢？这个之前需要先了解，字符串的比较 &lt; &lt;= &gt; &gt;= 返回一个布尔类型的值 对于字符串，第一个字符串中每个字符的代码都与会第二个字符串中对应位置的字符的代码进行数值比较。完成这种比较操作后，返回一个 Boolean 值。 所以对于字符串的排序，需要进行比较运算的运用，判断字符代码的大小，然后选择返回 1 -1 还是 0 1234567891011121314var arr = ['eca','bda','acf','dfe']; function sortStr (str1,str2)&#123; if(str1 &gt; str2)&#123; //如果str1 &gt; str2 交换二者的位置 return 1 ; &#125;else if (str1 &lt; str2 )&#123; //如果str1 &lt; str2 则不交换 return -1; &#125;else&#123; return 0; &#125; &#125; arr.sort(sortStr); console.log(arr); //["acf", "bda", "dfe", "eca"] 按字母升序排列 1234567891011121314var arr = ['eca','bda','acf','dfe'];function sortStr (str1,str2)&#123; if(str1 &gt; str2)&#123; return -1 ;//1 变为-1 &#125;else if (str1 &lt; str2 )&#123; return 1;// -1 变为1 &#125;else&#123; return 0; &#125;&#125;arr.sort(sortStr);console.log(arr);//["eca", "dfe", "bda", "acf"] 按字母降序排列 此方法通用数字数组 三 如果数组里面存放一组对象呢？如何按照对象的某一个数据进行排序？1234567891011121314 function sortByProperty(sortName)&#123; return function (o1,o2)&#123; if(o1[sortName] &gt; o2[sortName] )&#123; return 1 ; &#125;else if(o1[sortName] &lt; o2[sortName])&#123; return -1 ; &#125;else&#123; return 0 ; &#125; &#125; &#125; arr.sort(sortByProperty("id")) console.log(arr);//同样，可以按照不同的属性进行排序 四 如何打乱一个随机数组1234567function randomsort(a, b) &#123; return Math.random()&gt;.5 ? -1 : 1; //用Math.random()函数生成0~1之间的随机数与0.5比较，返回-1或1&#125;var arr = [1, 2, 3, 4, 5];arr.sort(randomsort);console.log(arr); 或者更简洁 123arr.sort(function()&#123; return Math.random() - 0.5;&#125;)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Git command detail Reset]]></title>
      <url>%2F2016%2F09%2F30%2F132GitCommandDetailReset%2F</url>
      <content type="text"><![CDATA[1 撤销修改 git checkout – index.html 一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态； 一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。 总之，就是让这个文件回到最近一次 git commit 或 git add 时的状态。 git reset HEAD index.html git reset 命令既可以回退版本，也可以把暂存区的修改回退到工作区；也就是说将添加到暂存区的修改退回到工作区；当我们用HEAD时，表示最新的版本。 再用git status查看一下，现在暂存区是干净的，工作区有修改：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Canvas]]></title>
      <url>%2F2016%2F09%2F28%2F114-Canvas%2F</url>
      <content type="text"><![CDATA[Canvas1 Canvas对象的大多数功能都是通过CanvasRenderingContext2D对象获得的，该对象通过canvas对象的getContext(contextID),只支持传递2d123456&lt;canvas id="myCanvas" width="200" height="100"&gt;&lt;/canvas&gt;&lt;script type="text/javascript"&gt;var c=document.getElementById("myCanvas");var cxt=c.getContext("2d");//getContext() 方法返回一个用于在画布上绘图的环境。 //getContext("2d") 对象是内建的 HTML5 对象，拥有多种绘制路径、矩形、圆形、字符以及添加图像的方法。&lt;/script&gt; 2 CanvasRenderingContext2D 对象的属性 fillStyle 用来指定填充路径所围成的区域的当前颜色、模式或者渐变; fill( ) 方法调用后才能生效 strokeStyle 用来指定画笔绘制的路径的颜色、模式或者渐变；stroke( )方法调用后才能生效 lineCap 指定线条末端如何绘制，合法值是 “butt” “round” “square” lineJoin 指定两条线 如何连接，合法值是”round” “bevel” “miter” lineWidth 注意是数值类型的属性值 指定绘制线条的画笔的宽度 cxt.lineWidth = 40;(大于1 即可)，**以所画的路径为基准，宽度向两边扩展增加，就像钢笔写字一个道理； shadowBlur 属性指定羽化阴影的程度。默认值是 0。阴影效果得到 safari 的支持，但是并没有得到 FireFox 1.5 或 Opera 9 的支持。 shadowColor 属性 把阴影的颜色指定为一个 CSS 字符串或 Web 样式字符串，并且可以包含一个 alpha 部分来表示透明度。默认值是 black。阴影效果得到 Safari 的支持，但是并没有得到 FireFox 1.5 或 Opera 9 的支持 shadowOffsetX, shadowOffsetY 属性 指定阴影的水平偏移和垂直偏移。较大的值使得阴影化的对象似乎漂浮在背景的较高位置上。默认值是 0。阴影效果得到 Safari 的支持，但是并没有得到 FireFox 1.5 或 Opera 9 的支持。 3 CanvasRenderingContext2D 对象的方法上述的属性都是作用在绘制的线条或者线条围成的区域中 ，那么生成线条和生成填充的命令(方法也就是核心的实现)；当然咯，最根本的你还得有路径，路径的绘制也是根本，表急； stroke() 方法用来绘制当前路径； strokeRect() 方法用来以strokeStyle 和 lineWidth 属性指定，矩形边角的形状由 lineJoin 属性指定绘制一个矩形 有独立路径，不影响其他路径;好像已经调用了beginPath()一样，**不改变当前位置**； fill( ) 方法用来填充绘制的路径形成的区域(即使该区域没有闭合) 使用 fillStyle 属性所指定的颜色、渐变和模式来填充**当前路径** 。这一路径的每一条**子路径** 都单独填充。任何未闭合的子路径都被填充，就好像已经对他么调用了 [closePath() 方法](met_canvasrenderingcontext2d_closepath.asp)一样 fillRect( ) 方法用 fillStyle 属性所指定的颜色、渐变和模式来填充指定的矩形。 有独立路径，不影响其他路径;好像已经调用了beginPath()一样，**不改变当前位置**； clearRect( ) 方法清除所定义的矩形区域； 12345cxt.fill();//只要路径可以形成闭合空间，就会被填充//填充一条路径并不会清除该路径。你可以在调用 fill() 之后再次调用 stroke()，而不需要重新定义该路径。cxt.stroke();cxt.fillRect(x,y,width,height);cxt.strokeRect(x,y,width,height); 4 用CanvasRenderingContext2D 对象的方法绘制路径4.1 当前位置的概念的理解，每次线条绘制完毕，包括绘制直线，圆形，矩形等，当前位置 都会发生变化 4.2 如何理解路径，就是没有调用beginPath()之前进行绘制路线的方法，所绘制的路线都是当前路径，当前路径内的包括直线，圆形，矩形以及曲线都会被stroke()方法和fill()绘制成框或者添加填充；调用beginPath()之后绘制的路径，然后在stroke()和fill()渲染了路径不会将之前的路径重新渲染; 4.3 绘制一条子路径: 绘制直线确定起始位置: cxt.moveTo(x,y) 将当前位置设置移动到该位置(x,y)，并且不产生线条， moveTo() 方法设置当前位置并开始一条新的子路径; 绘制直线，进行直线延伸: cxt.lineTo(x,y) 绘制直线完成之后，设置(x,y)为当前位置； 绘制矩形cxt . rect(x,y,width,height); x,y 矩形的左上角的坐标。为当前路径(画布)添加一条矩形子路径。绘制完成之后当前位置 是矩形左上角；？当前位置是 (0,0)。 绘制圆形 cxt . arc(x,y,radius,startAngle,endAngle,counterclockwise) 为一个画布的当前子路径 添加一条弧。 x,y 代表圆心坐标， angle的取值问题:90deg = 100grad = 0.25turn ≈ 1.570796326794897rad， 沿着圆指定弧的开始点和结束点的一个角度。这个角度用弧度 来衡量。沿着 X 轴正半轴的方向的角度为 0，角度 沿着逆时针 方向而增加。 counterclockwise true false 逆时针 ture 顺时针 false 绘制过程: 1 这个方法的前 5 个参数指定了圆周的一个起始点和结束点 。 2 调用这个方法会在当前点和弧的起点 之间添加一条直线。 3 接下来，沿着弧的起始点和结束点 之间添加弧(根据true或者false判断逆时针还是顺时针画弧) 4 最后将 弧的终点 设置为 当前位置 在绘制圆形的时候，为了避免一些莫名其妙的填充效果，尽量将当前点移到圆心处； 4.4 如果想要对一个新的路径渲染不同于上一条子路径的边框和填充，那么可以新建一条子路径，并且重新渲染和填充就可以获取不一样子路径样式 当前路径 : 画布的一项强大功能是，它能够从基本的绘图操作来构建图形，然后，绘制这些图形的框架（勾勒它们）或者给这些图形的内容涂色（填充它们）。累计起来的操作统一叫做当前路径。一个画布只保持一条当前路径。 子路径: 每次使用beginPath()方法之后，就开辟了一条新的子路径； beginPath() 方法在一个画布中开始子路径的一个新的集合。 重新渲染为不同的样式；丢弃任何当前定义的路径并且开始一条新的路径。它把当前的点设置为 (0,0)。 当一个画布的环境第一次创建，beginPath() 方法会被显式地调用； 每次stroke对应一个beginPath; closePath( ) 将当前子路径闭合；如果画布的子路径是打开的，closePath() 通过添加一条线条连接当前点和子路径起始点 来关闭它。 如果子路径已经闭合了，这个方法不做任何事情。 一旦子路径闭合，就不能再为其添加更多的直线或曲线了。要继续向该路径添加，需要通过调用 moveTo() 开始一条新的子路径。 4.5 路径绘制完毕之后 ，必须调用cxt.stroke() 或者cxt.fill()进行渲染才能显示； 12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang="en"&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;canvas id="myCanvas" height="400px" width="400px" style="border:solid red 1px"&gt;&lt;/canvas&gt;&lt;script&gt;//以下在chorm开发者工具设置断点查看下变化过程 var myCanvas = document.getElementById("myCanvas"); var cxt = myCanvas.getContext('2d'); //console.log(cxt); cxt.beginPath(); cxt.lineWidth = 5; cxt.fillStyle = "red"; cxt.rect(200,200,50,50);//将当前位置设置为（0,0） cxt.stroke(); cxt.fill(); cxt.beginPath();//看下没有这行代码和有这行代码的区别，分析beginPath()的作用 cxt.lineWidth = 10; cxt.fillStyle = "green"; cxt.rect(100,100,50,50); cxt.stroke(); cxt.fill(); //lineWidth宽度向两边扩展，fill颜色填充以路径为基准，所以会出现边框变细的错觉&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 5 用CanvasRenderingContext2D 对象的方法填充文本5.1 绘制文本的方法: cxt.fillText(text,x,y,maxWidth) cxt.strokeText(text,x,y,maxWidth) 绘制文本 ; 不改变当前位置； cxt.measureText(txt) 该方法可以测试文本的大小，返回一个对象 TextMetrics{width : } x y 是开始绘制文本的坐标 cxt.measureText(txt).width ;可以获取文本的大小 5.2 改变文本的属性: cxt.textBaseline = “alphabetic|top|hanging|middle|ideographic|bottom”; 以绘制的文本的y坐标为基准;默认。文本基线是普通的字母基线。 cxt.textAlign = =”center|end|left|right|start”; 以绘制文本坐标x为基准 默认start fillText()或 strokeText() 方法在画布上定位文本时，将使用指定的 textBaseline和textAlign 值。 6 用CanvasRenderingContext2D 对象的方法绘制图像7 用CanvasRenderingContext2D 对象的方法，改变坐标系统 cxt.translate(dx,dy) 该方法可以改变画布原始的原点坐标，后期所绘制的路径都是以这个改变后的坐标为原点，坐标轴的执行不变；x轴向右为正方向，y轴向下为正方向 cxt.rotate(angle) rotate() 方法通过指定一个角度，使得任意后续绘图在画布中都显示为旋转的。它并没有旋转 元素本身。注意，这个角度是用弧度指定的。如需把角度转换为弧度，请乘以 Math.PI 并除以 180。 旋转的量，用弧度表示。正值表示顺时针方向旋转，负值表示逆时针方向旋转; 每次牵涉到旋转，要考虑两点，第一旋转的中心，第二旋转的角度，这里旋转的角度通过angle赋值，旋转的中心是当前坐标系统的坐标原点，也就是说，如果通过translate(dx,dy)改变了坐标原点，那么旋转的中心就是改变后的坐标原点; 旋转之后在画 的路径都是以旋转后的为基准，对于旋转之前的路径没有影响； cxt.scale(sx,sy) scale() 方法为画布的当前变换矩阵添加一个缩放变换。缩放通过独立的水平和垂直缩放因子来完成。例如，传递一个值 2.0 和 0.5 将会导致绘图路径宽度变为原来的两倍，而高度变为原来的 1/2。指定一个负的 sx 值，会导致 X 坐标沿 Y 轴对折，而指定一个负的 sy 会导致 Y 坐标沿着 X 轴对折。 8 save( ) 和 restore( ) 方法 save( ) 一个画布的图形状态包含了 CanvasRenderingContext2D 对象的所有属性（除了只读的画布属性以外）。它还包含了一个变换矩阵，该矩阵是调用 rotate( )、scale( ) 和 translate( ) 的结果。另外，它包含了剪切路径，该路径通过 clip( ) 方法指定。可是要注意，当前路径和当前位置并非图形状态的一部分，并且不会由这个方法保存。 restore( ) 回复上一个save( )状态时候的画布所保存的属性，包括变换的矩阵结果;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Git Cmd Command Enhence Memory]]></title>
      <url>%2F2016%2F09%2F27%2F10GitandCMDcommand%2F</url>
      <content type="text"><![CDATA[Bash 命令 $ cd ../ 可以进入上层目录 $ cd ./目录名 可以进入下层目录 $ cd mkdir 创建一个目录 $ touch + 文件名 可以创建某个文件 \$ touch index / index.js / index.html etc $ cat + 文件名可以查看文件内容,工作区的文件内容；\$ cat index / index.js /index.html etc $ echo + content + &gt; 文件 $ echo hello you &gt; index.html //会清空之前的内容 $ echo good bye &gt;&gt; index.html //新添加内容，不会 $ cat index.html 可以查看文件 $ less index.html 全屏查看文件 $ tail -f 可以实时监看文件后面几行的内容变化 q 全屏查看之后可以通过q退出 $ rm index.html (remove)可以删除文件 $ vi index.html 可以打开文件，直接进行编辑 tab键可以自动补全 | 管道操作符 ​ VI 命令模式 $ vi index.html 进入命令模式 之后 a A i I o O s可以进入编辑模式,可以直接编辑文件，esc可以退出编辑模式 退出(ESC)编辑模式之后进入命令模式，以下操作都在命令模式 ZZ 可以直接保存并退出当前文件 dd 可以直接删除当前行，还在命令模式 大写S 可以直接删除当前光标所在行，并直接进入编辑模式 大写C 可以直接删除当前光标后面的所有的字符，然后直接进入编辑模式 x 可以直接删除当前光标的后面一个字符串 gg 将光标移动到文件首部 p 直接复制一整行 u 后退上次编辑 h j k l 左下上右移动 : 0 定位光标至行首 : $ 定位光标至行尾 : q ! 可以直接退出命令模式 : wq 可以直接退出命令模式 Git 命令 工作区 ——&gt;git add 将工作区的文件添加到 暂存区—— &gt; git commit 将暂存区的文件添加到 分支 git 版本库(工作区有一个.git文件夹)管理的是所在目录的文件的修改， 而不是文件，也就是说， 当 文件修改 1 —— git add 将文件修改1提交到暂存区——再接着 文件修改2 —— git commit 提交到分支，这个时候提交的只有修改1 ，修改2 并未被提交到分支； git add 命令实际上做的工作是提交的文件的修改到暂存区，不是提交的文件本身，这个对于git版本库管理工具理解至关重要； git status 可以随时查看 工作区 暂存区 以及分支的状态 工作区文件的状态:未跟踪 untracked 已暂存staged 已提交 committed 已修改 modefied $ git 用于检测是否安装了了git\ $ mkdir learngit (Make Directory) //创建一个新的目录 \$ cd learngit (Change Directory) //进入一个目录 $ pwd(Print Working Directory) //打印当前工作目录 $ git init 命令可以将该目录变成git可以管理的仓库，初始化git仓库(initial:初始化) 创建一个文件 比如 “readme.txt” 创建文件之后，如果没有add命令，那么文件属于为被跟踪状态 $ git add readme.txt 将创建的文件添加到仓库,或者将文件的修改提交到暂存区 $ git commit -m “ 文件说明” 将添加的文件的修改提交到仓库(commit:提交) $ git status 命令可以让我们时刻掌握仓库当前的状态，上面的命令告诉我们，readme.txt被修改过了，但还没有准备提交的修改。但是我们无法知道什么内容被修改了 $ git diff 可以查看那些内容被修改了，被修改的一列最前面会有 + 号(difference:不同) $ git add readme.txt 再次添加给仓库，不要commit提交 $ git add -A 表示将文件全部提交到仓库暂存区 $ git add * 表示将工作区全部文件提交到暂存区 $ git rm –cached readme.txt 将提交到缓存区的文件移除 $ git status 查看下状态 $ git commit -m “文档说明” commit之后会在git仓库object文件夹下新建一个文件夹，保存了commit的信息 版本退回 $ git log 可以获取文档被修改的过程 $ git log –pretty=oneline 可以让显示更加优雅 $ git reset –hard HEAD^ 其中 ^ 代表回退到上一个版本，^^ 代表回退到倒数第二个版本，HEAD~100 回退到地一百个版本。工作区 暂存区 本地仓库都会改变 $ git reset hard 4444 如果我们退回以后后悔了，又想回去怎么办？可以回到某个特定的版本，只需要知道某个版本号即可，部分内容，系统会自动去匹配 $ git reset soft 只会改变历史HEAD指向 $ git reflog 可以查看历史命令 $ git ls (list) 查看当前目录下的内容和 \$ ll 命令功能类似 $ git branch 可以查看当前分支 branch List, create, or delete branches $ git branch myMaster 可以添加一个myMaster分支 $ git branch 可以查看分支，有了新增的分支 $ git checkout myMaster 可以切换到该分支 checkout Switch branches or restore working tree files $ git checkout -b myMaster 等价于 \$ git branch myMaster \$git checkout myMaster $ git branch -d 删除分支 $ git branch -d myMaster ; $ git clone + 地址 可以直接从github上下载文件 $ git push 可以将本地文件推送到服务器 $ git stash 可以保存当前的工作内容 创建共享仓库 $ git init –bare 创建共享仓库 $ git push 远程仓库的地址 本地分支:远程分支 $ git push 远程仓库的地址 本地分支 $ git pull 远程仓库的地址 远程分支 : 本地分支 $ git pull 远程仓库的地址 远程分支 $ git clone 远程仓库的地址 文件名称 $ git fecth 从远程仓库获取分支内容，但是不会合并分支 $ git merge 然后可以通过git merge进行合并 分支操作 git branch myMaster 新建分支 git branch -r 查看远程分支 git branch -a 查看所有分支 git branch -d 删除本地分支 git push origin : 分支名称 删除远程仓库分支 ​]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[AngularModule]]></title>
      <url>%2F2016%2F09%2F27%2F159AngularJsModule%2F</url>
      <content type="text"><![CDATA[1 定义:A module is a collection of configuration and run blocks which get applied to the application during the bootstrap process. In its simplest form the module consists of a collection of two kinds of blocks angular.module(‘myApp’,[ ]) 用来创建一个模块 angular.module(‘myApp’) 用来引用一个模块(该模块必须已经声明) 123456789&lt;body ng-app = 'myApp'&gt;&lt;script&gt; var myApp = angular.module("myApp",[]); var myApp2 = angular.module("myApp"); console.log(myApp); console.log(myApp2); console.log(myApp === myApp2);//true&lt;/script&gt;&lt;/body&gt; 2 AngularJS分两个阶段运行你的应用 – config阶段和run阶段。config阶段是你设置任何的provider的阶段。它也是你设置任何的指令，控制器，过滤器以及其它东西的阶段。在run阶段，AngularJS会编译你的DOM并启动你的应用 2.1 Configuration Blocks 12345678910111213141516171819202122//语法糖，这个是我们平常的写法，很简洁，其实是下一段代码的语法糖angular.module('myModule', []). value('a', 123). factory('a', function() &#123; return 123; &#125;). directive('directiveName', ...). filter('filterName', ...). controller('MainController',function($scope)&#123; &#125;);// is same asangular.module('myModule', []). config(function($provide, $compileProvider, $filterProvider) &#123; $provide.value('a', 123); $provide.factory('a', function() &#123; return 123; &#125;); $compileProvider.directive('directiveName', ...); $filterProvider.register('filterName', ...); $controllerProvider.register('MainController', function($scope) &#123; &#125;); &#125;); &#125;); 需要注意的一点是:在config阶段，只有provider能被注入（只有两个例外是\$provide和$injector)。 3 Run Blocks Run blocks are the closest thing in AngularJS to the main method. A run block is the code which needs to run to kickstart the application. It is executed after all of the services have been configured and the injector has been created. Run blocks typically contain code which is hard to unit-test, and for this reason should be declared in isolated modules, so that they can be ignored in the unit-tests.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[template]]></title>
      <url>%2F2016%2F09%2F27%2F103-template%E6%A8%A1%E6%9D%BF%2F</url>
      <content type="text"><![CDATA[table 表格操作,如何将这些后台传过来的数据动态的添加到table表格里1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang="en"&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;table border = 1&gt;&lt;/table&gt; &lt;script&gt; var data = [&#123; id : 1, name : '西游记', author : '吴承恩', price : '40', desc : '佛教与道教的斗争' &#125;,&#123; id : 2, name : '水浒传', author : '施耐庵', price : '30', desc : '草寇与政府的斗争' &#125;,&#123; id : 3, name : '红楼梦', author : '曹雪芹', price : '60', desc : '封建社会的缩影' &#125;,&#123; id : 4, name : '三国演义', author : '罗贯中', price : '30', desc : '一个杀伐纷争的年代' &#125;];&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;//一般传过来的是JSON数据，然后需要进行转化，JSON.stringify(data)方法转化为对象 1 动态创建表格 1.1 innerHTML 数组和字符串 1234567891011121314151617181920212223242526272829303132333435363738&lt;script&gt; //-------------------------------------------------- //通过字符串，这种方法有一个很大的弊端，就是字符串的不可变性，导致每次都会重新给字符串分配内存空间，特别耗费内存 var table = document.querySelector("table"); var str = ""; for(var i = 0 ; i &lt; data.length ; i++)&#123; var item = data[i]; console.dir(item); str += '&lt;tr&gt;' + '&lt;td&gt;'+item['id']+'&lt;/td&gt;' + '&lt;td&gt;'+item['name']+'&lt;/td&gt;' + '&lt;td&gt;'+item['author']+'&lt;/td&gt;' + '&lt;td&gt;'+item['price']+'&lt;/td&gt;' + '&lt;td&gt;'+item['desc']+'&lt;/td&gt;' + '&lt;/tr&gt;' &#125; table.innerHTML = str ;//----------------------------------------------------- var table = document.querySelector("table"); var arr = []; for(var i = 0 ; i &lt; data.length ; i++)&#123; var item = data[i]; console.dir(item); arr.push( '&lt;tr&gt;' + '&lt;td&gt;'+item['id']+'&lt;/td&gt;' + '&lt;td&gt;'+item['name']+'&lt;/td&gt;' + '&lt;td&gt;'+item['author']+'&lt;/td&gt;' + '&lt;td&gt;'+item['price']+'&lt;/td&gt;' + '&lt;td&gt;'+item['desc']+'&lt;/td&gt;' + '&lt;/tr&gt;' ) &#125; var html = arr.join(""); table.innerHTML = html ;//---------------------------------------------------------------&lt;/script&gt; 1.2 模板引擎创建，传入数据 1234567891011121314151617181920212223242526&lt;script src="template-native.js"&gt;&lt;/script&gt;&lt;script&gt;// 模板引擎的使用，第一步，改变script标签的type属性 = text/html 或者text/template，编写模板// 第二步，调用模板，传入数据和模板的id&lt;/script&gt;&lt;script type="text/template" id="tempalteId"&gt; &lt;% for(var i = 0 ;i &lt; list.length; i++)&#123; %&gt; &lt;tr&gt; &lt;td&gt; `&lt;%=list[i].id%&gt;` &lt;/td&gt; &lt;td&gt; `&lt;%=list[i].name%&gt;` &lt;/td&gt; &lt;td&gt; `&lt;%=list[i].author%&gt; `&lt;/td&gt; &lt;td&gt; `&lt;%=list[i].price%&gt; `&lt;/td&gt; &lt;td&gt;`&lt;%=list[i].desc%&gt;`&lt;/td&gt; &lt;/tr&gt; &lt;% &#125; %&gt;&lt;/script&gt;&lt;script&gt; var tepData = &#123; list: data &#125; //这个位置要传入对象形式的数据 var html = template("tempalteId",tepData); //注意第一个参数传入的是id ,引号勿忘 var table = document.querySelector("table") table.innerHTML = html;&lt;/script&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[jQuery核心]]></title>
      <url>%2F2016%2F09%2F24%2F16-jquery%E4%B8%AD%20get()%20%20%E5%92%8C%20index()%2F</url>
      <content type="text"><![CDATA[1 核心 $(“selector”):这个函数接收一个包含 CSS 选择器的字符串，然后用这个字符串去匹配一组元素。注意：如果选择器字符串含有变量 的话需要进行字符串拼接。 123456789101112&lt;div class=&quot;bd&quot;&gt; &lt;ul&gt; &lt;li class=&quot;current&quot;&gt;我是体育模块&lt;/li&gt; &lt;li&gt;我是娱乐模块&lt;/li&gt; &lt;li&gt;我是新闻模块&lt;/li&gt; &lt;li&gt;我是综合模块&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;如果index是以变量的形式存在的话，那么，第一行代码获取对应索引位置的li元素是无法获取的，第二行字符串的拼接才是正确的写法。var index = 2 ； $(&quot;.bd li:eq(index)&quot;).prop(&quot;class&quot;,&quot;current&quot;);//错误写法 $(&quot;.bd li:eq(&quot;+index+&quot;)&quot;).prop(&quot;class&quot;,&quot;current&quot;); 2 jquery中 get() 和 index() 如何区分DOM对象和jquery对象的区分 get()方法：这能够让你选择一个实际的DOM 元素并且对他直接操作，而不是通过 jQuery 函数,也就是说此时将jquery对象转化成了DOM对象； jqueryObj.get():如果不传参数index，那么将返回匹配到的所有对象组成的DOM元素集合； jqueryObj.get(index):如果传入index参数，那么将返回匹配到元素集合中的第几个DOM元素，其中index代表索引值； 注意返回值是DOM元素，不能用jquery方法 ；get(index)方法中的index索引值是从0 开始的； index()方法：如果不传参数，那么返回值是当前jquery对象在其同辈元素中的索引值(从0 开始)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Object API submit]]></title>
      <url>%2F2016%2F09%2F22%2F119-Object%E3%80%80API%2F</url>
      <content type="text"><![CDATA[Object内置对象 API1 Object.getPrototypeOf( obj ) ,返回obj对象的构造函数的prototype属性(也就是obj对象的 proto 属性对象)，每个构造函数都有一个prototype属性 12345678 function Test ()&#123;&#125;; var test = new Test(); console.log(Object.getPrototypeOf(test)); console.log(Object.getPrototypeOf(test) === Test.prototype);//true//------------------------------------------------------------------------- var obj = new Object (); console.log(Object.getPrototypeOf(obj)); console.log(Object.getPrototypeOf(obj) == Object.prototype);//true 2 isPrototypeOf( ) 3 设置对象的原型属性 proto 3.1 Object.create( proto , prop ) 用来设置对象的 proto 的属性的指向；返回一个创建的对象;prop和Object.defineProperties(obj ,prop) 里面的prop格式一致,如下栗子 1234567891011121314var obj = Object.create(&#123; foo: 1 &#125;, &#123; // foo is on obj's prototype chain. bar: &#123; value: 2 // bar is a non-enumerable property. &#125;, baz: &#123; value: 3, enumerable: true // baz is an own enumerable property. &#125;&#125;);var copy = Object.assign(&#123;&#125;, obj);console.log(copy); // &#123; baz: 3 &#125;console.log(obj); obj结构如下 12345Object baz: 3 bar: 2 __proto__: Object foo: 1 __proto__: Object 3.2 Object.setPrototypeOf(obj,prototype) prototype参数必须是一个对象或者null,否则会抛出异常，用来设置对象的 proto 的属性的指向,返回obj对象 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263 function Test()&#123; this.age = 18; &#125; var test = new Test();// console.dir(Test);// console.log(Test.prototype); var obj1 = Object.create(Test.prototype,&#123; 'name':&#123; writable:true, value:'JiM' &#125; &#125;); console.log(obj1); console.log(obj1.__proto__ === Test.prototype ); var obj1 = Object.create(Object.prototype,&#123; 'name1':&#123; writable:true, value:'JiM1' &#125; &#125;); console.log(obj1); console.log(obj1.__proto__ === Object.prototype );var obj1 = Object.create(Array.prototype,&#123; 'name2':&#123; writable:true, value:'JiM2' &#125;&#125;);console.log(obj1);console.log(obj1.__proto__ === Array.prototype );var obj1 = Object.create(null,&#123; 'name3':&#123; writable:true, value:'JiM3' &#125;&#125;);console.log(obj1);console.log(obj1.__proto__ === null );//falseconsole.log(obj1.__proto__ == null );//true var o = &#123;foo:"bar"&#125; var obj1 = Object.create(o,&#123; 'name4':&#123; writable:true, value:'JiM4' &#125; &#125;); console.log(obj1); console.log(obj1.__proto__ === o );//truevar obj1 = Object.create(Test,&#123; 'name5':&#123; writable:true, value:'JiM5' &#125; &#125;); console.log(obj1); console.log(obj1.__proto__ === Test);//proto 设置obj1的__proto__ 指向，必须是一个对象或者null否则会抛出异常; prop 设置 obj1 的属性值 12345var obj = &#123;name:"JHOn"&#125;;console.log(obj);// Object.setPrototypeOf(obj,null);Object.setPrototypeOf(obj,Array.prototype); 4 Object.getOwnPropertyNames(obj )该函数可以将对象中可枚举以及不可枚举的key值都列举出来,返回一个key组成的数组 The object whose enumerable and non-enumerable own properties are to be returned. An array of strings that correspond to the properties found directly upon the given object. 5 Object.keys(obj) 该方法返回obj对象的所有可枚举的属性的键值组成的数组，不可枚举的属性键不会返回 12345678910111213 var obj = &#123;name:"Jhon",age:12,gender:"man"&#125;; Object.defineProperty(obj,"email",&#123; value:"Gemail", enumerable:false //设置email为false不可枚举，便于检测 &#125;) for(var key in obj )&#123; //遍历对象自身的和继承(__proto__上的属性)的可枚举的属性 console.log(key); //name age email &#125;//以下两种方法只遍历对象的原生属性,不会遍历对象的原型__proto__上的属性 var arr = Object.getOwnPropertyNames(obj); console.log(arr); //["name", "age", "gender", "email"] var arr1 = Object.keys(obj); console.log(arr1);//["name", "age", "gender"]]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[遍历对象的属性]]></title>
      <url>%2F2016%2F09%2F22%2F139%E9%81%8D%E5%8E%86%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B1%9E%E6%80%A7%2F</url>
      <content type="text"><![CDATA[遍历对象的属性 12345678910var obj = Object.create(&#123;foo:0&#125;,&#123; bar1:&#123; value:1//descriptor默认值 enumerable fasle configurable false writable false &#125;, bar2:&#123; value:2, enumerable:true &#125;&#125;);console.log(obj);//Object &#123;bar2: 2, bar1: 1&#125; for in 可以遍历属性和原型属性 中可以枚举的 ，包括原型上的属性 123for(var key in obj)&#123; console.log(key); // bar2 foo&#125; Object.keys(obj) 返回所有可以枚举的属性组成的数组，不包括原型上的属性 12console.log(Object.keys(obj));//["bar2"] Object.getOwnPropertyNames(obj) 返回可以枚举以及不可枚举的属性组成的数组，不包括原型上的属性 12console.log(Object.getOwnPropertyNames(obj));//["bar1", "bar2"] Object.assign()方法只能复制可以枚举的属性，不能复制不可枚举以及原型上的属性 12console.log(Object.assign(&#123;&#125;,obj));//Object &#123;bar2: 2&#125; JSON.stringify(obj) 只能将对象可枚举的属性转化 12console.log(JSON.stringify(obj));//'&#123;"bar2":2&#125;'console.log(typeof JSON.stringify(obj));//string]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[XMIHttpRequestLevel2FormData]]></title>
      <url>%2F2016%2F09%2F22%2F169XMIHttpRequest-Level2-FormData%2F</url>
      <content type="text"><![CDATA[1 首先来看下声明是FormData (查看MDN官方文档) XMLHttpRequest Level 2添加了一个新的接口FormData.利用FormData对象,我们可以通过JavaScript用一些键值对来模拟一系列表单控件,我们还可以使用XMLHttpRequest的[send()方法来异步的提交这个”表单”.比起普通的ajax,使用FormData的最大优点就是我们可以异步上传一个二进制文件. 2 看下之前上传文件的限制 3 用这个新特性上传文件的优势]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HTML5 Storage]]></title>
      <url>%2F2016%2F09%2F21%2F82-HTML5%20%20Storage%20%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8%2F</url>
      <content type="text"><![CDATA[HTML5 Storage 1 localStorage 存储数据没有时间限制，一周，一个月之后都可以使用 2 sessionStorage 存储数据只是针对一个session进行，当用户关闭当前网页的时候，数据随即也被清除； 3 当点击开发者工具里面的 clear storage的时候，localStorage会被删除，但是，sessionStorage不会被删除，只要浏览器窗口不被关闭，那么sessionStorage本地存储就不会被删除； 如何判断浏览器是否支持HTML5这个新的API，如果window.loaclStorage window.sessinoStorage 存在，那么证明浏览器支持该对象 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang="en"&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;input type="button" value="按钮"/&gt;&lt;script src="jquery-1.12.2.js"&gt;&lt;/script&gt;&lt;script&gt; $("input:button").click(function()&#123; if(window.localStorage)&#123; //object转化为布尔为true console.log(typeof window.localStorage);//object console.log(window.localStorage); &#125; if(window.sessionStorage)&#123; console.log(typeof window.sessionStorage);//object console.log(window.sessionStorage); &#125; &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 3 本地存储 localStorage sessionStorage 对象常用方法如下 1234563.1 获取localStorage对象或者sessionStorage对象里面的key值 getItem(key) localStorage.key sessionStorage.key3.2 增加localStorage对象或者sessionStorage对象里面的key值 setItem(key,value) localStorage.key = "value" sessionStorage.key = "value"3.3 removeItem(key) 删除localStorage对象或者sessionStorage对象里面的key值3.4 clear() 清空localStorage对象或者sessionStorage对象里面的所有存储值 12345 localStorage.name = "jim";//设置localStorage 对象 name 值 sessionStorage.name2='wmg';//设置sessionStorage对象 name值 localStorage.setItem("age",12);//设置 localStorage 对象age值loaclStorage.getItem("age");//获取localStorage 对象里面的 age值 localStorage.clear();//清除localStorage 对象里面所有的值 4 详说二者的不同 loaclStorage 本地存储数据不会被销毁，除非用户主动删除,存储容量大 5M，对于基本的字符串的存储足够了； sessionStorage 本地存储数据很特别，引入了一个”浏览器窗口”的概念，sessionStorage是在一个同源 的同窗口 中始终存在的数据， 浏览器窗口没有被关闭，那么就一直存在，即使刷新了页面 或者 进入同源另外一个页面，仍然存在 浏览器窗口被关闭 或者 再次独立的打开同样的这个页面，两个窗口的sessionStorage并不通用 简单解释来说就是:sessionStorage是仅仅存在于当前”浏览器窗口的”本地存储对象，”当前浏览器窗口”不关闭，则一直存在，关闭则自动销毁； 大家可以看下这个栗子 综合考虑下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta name="viewport" content="width=device-width" /&gt; &lt;title&gt;LocalStorage&lt;/title&gt; &lt;script src="jquery-1.12.2.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; function clickCounter() &#123; if (typeof (Storage) !== "undefined") &#123; if (sessionStorage.clickcount) &#123; sessionStorage.clickcount = Number(sessionStorage.clickcount) + 1; &#125; else &#123; sessionStorage.clickcount = 1; &#125; $('#result').html(''); $('#result').append('&lt;p&gt;' + sessionStorage.clickcount + '&lt;/p&gt;'); &#125; else &#123; $('#result').text('抱歉您的浏览器不支持本地存储'); &#125; &#125; function clickCounter2() &#123; if (typeof (Storage) !== "undefined") &#123; if (localStorage.clickcount) &#123; localStorage.clickcount = Number(localStorage.clickcount) + 1; &#125; else &#123; localStorage.clickcount = 1; &#125; $('#result2').html(''); $('#result2').append('&lt;p&gt;' + localStorage.clickcount + '&lt;/p&gt;'); &#125; else &#123; $('#result2').text('抱歉您的浏览器不支持本地存储'); &#125; &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt; &lt;p&gt; &lt;button onclick="clickCounter()" type="button"&gt;sessionStorage查看单击次数&lt;/button&gt; &lt;/p&gt; &lt;div id="result"&gt;&lt;/div&gt; &lt;p&gt;单击按钮查看统计次数&lt;/p&gt;&lt;/div&gt;&lt;div&gt; &lt;p&gt; &lt;button onclick="clickCounter2()" type="button"&gt;localStorage查看单击次数&lt;/button&gt; &lt;/p&gt; &lt;div id="result2"&gt;&lt;/div&gt; &lt;p&gt;单击按钮查看统计次数&lt;/p&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[提高网页性能的方法]]></title>
      <url>%2F2016%2F09%2F19%2F177%E6%8F%90%E9%AB%98%E7%BD%91%E9%A1%B5%E6%80%A7%E8%83%BD%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
      <content type="text"><![CDATA[1 文件合并（减少HTTP请求数量） CSS Sprites 利用css sprites将网站用到的图片合并成一张图片，通过background-position、width、height控制背景图位置来使用某一个图标，这种方式可以将多个图片请求缩减为一次，生成css sprites的工具也很多，grunt和gulp中都有相关的插件，CssGaga也不错。 合并js和css 和精灵图一样，合并css和js文件也是减少HTTP请求很重要的方式，对css文件的合并目前来说没有什么争议，但是对于当前js模块化盛行，将所有js文件合并成一个文件，仿佛是一种倒退。正确的方式是遵守编译型语言的模式，保持js的模块化，在生成过程中只对初始请求用到的js文件生成目标文件。 2 使用内容发布网络（减少HTTP请求时间） HTTP请求时间另一个影响因素是你与网站web服务器所处的距离，显然距离越远，请求所需的时间也越久，通过CDN可以大大改善这一点。 CDN是分布在多个不同地理位置的web服务器，用于更加有效的向用户发布内容。CDN最主要的功能是给终端用户存放静态文件，另外也提供下载、安全服务等功能。 ​ CDN的全称是Content Delivery Network，即内容分发网络。其基本思路是尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定。通过在网络各处放置节点服务器所构成的在现有的互联网基础之上的一层智能虚拟网络，CDN系统能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。其目的是使用户可就近取得所需内容，解决 Internet网络拥挤的状况，提高用户访问网站的响应速度。 3 设置浏览器缓存（避免重复HTTP请求） 使用Expire/Cache-control 浏览器通过使用缓存可以避免每次都进行重复的请求，HTTP 1.0和HTTP1.1分别有不同的缓存实现方式，Expires(1.0)和Cache-control(1.1)。Web服务器通过expires告诉客户端在指定的时间内，都使用该文件的缓存副本，不再向服务端重复发出请求，例如： 1Expires: Thu, 01 Dec 2016 16:00:00 GMT （GMT格式） 这个设置意味着截止到2016年12月1日，都可以使用该缓存副本，无需再发出请求。 Expires这种通过截止日期的方式，存在一个限制：要求客户端和服务端时钟严格同步，而HTTP 1.1引入的Cache-Control通过指定一个以秒为单位的时间指定缓存日期，则不存该限制，例如： 1Cache-Control: max-age=31536000 这个设置意味缓存时间为一年，推荐使用Cache-Control，但是在支持HTTP 1.1的情况下，另外要注意的一点：Cache-Control和Expire同时存在时，Cache-Control具有更高的优先级。 配置或移除ETag 使用Expire/Cache-Control可以避免第二次访问时，使用本地缓存避免重复HTTP请求，提高网站速度。然而，在用户点击了浏览器刷新或者在expire已过期的情况下，仍然会向服务端发出HTTP GET请求，而此时如果该文件并没有发生变化，服务端不会返回整个文件而是会返回304 Not Modified状态码。 服务端判断该文件是否发生变化的依据有两个：Last-Modified（最新修改日期）和ETag（实体标签）; ETag（Entity Tags）是在HTTP 1.1引入的，与Last-Modified同时存在时要有更高的优先级。服务端通过对比客户端发来的ETag（If-None-Match）和当前ETag，若相同返回304 Not Modifed，否则返回整个文件以及200 OK。 ETag存在一个问题：当浏览器向一个服务器发送GET请求原始组件，之后又向另一台服务器请求该组件时，ETag是不匹配的，当然，如果你的网站寄宿在一台服务器上不存在这个问题，而现在很多网站使用多台服务器，ETag的存在就大大降低验证有效性的成功率。 存在这个问题是时的解决办法是对ETag进行配置，移除服务器innode值只保留修改时间戳和大小作为ETag值，或者直接移除ETag，使用Last-Modified来验证文件有效性。 4 压缩组件（减小HTTP请求大小） 通过对HTTP传输的文件进行压缩减小HTTP请求的大小，提高请求速度，GZIP是目前最常用也是最有效的压缩方式。 然而，并非所有的资源文件都需要压缩，压缩的成本包括服务端需要花费CPU周期进行压缩，而客户端也需要对压缩文件进行解压缩，必须结合自己网站进行权衡。现在绝大多数网站都对其HTML文档进行压缩，部分网站选择对js、css进行压缩，几乎没有网站对图片、PDF等文件进行GZIP压缩，原因在于这些文件是已经被压缩过的，采用HTTP压缩已经被过压缩的东西并不能使它更小。事实上，添加标头，压缩字典，并校验响应体实际上使它变得更大，而且还浪费了CPU。 如何对网站开启GZIP，需要在所使用的web服务器（IIS、Nginx、Apache等）中进行设置。 5 CSS文件放在首部 将CSS文件放在首部和放在尾部，并不影响HTTP请求，因此从请求时间上来讲是一致的，然而从用户体验的角度，将CSS文件放在首部，会获得更好的用户体验。 原因在于浏览器是从上到下依次解析html文档，将CSS文件置于头部，页面会首先对CSS文件发出请求，随后加载DOM树并对其进行渲染，页面会逐步呈现在用户面前。 而与之相反，如果将CSS文件放置在尾部，页面加载完整DOM之后请求CSS文件，然后对整个DOM树渲染并呈现给用户，从用户的角度，在css文件没有请求完成之前，整个页面是出于白屏状态的，白屏是浏览器的一种行为，David Hyatt对其的解释是这样的 在样式树没有完全加载之前，渲染dom树就是一种浪费，因为在样式树加载完成之后会再次渲染，出现FOUC(无样式内容闪烁)问题。 另外要注意的一点，使用link而不是@import引入css样式表，使用@import引入的样式即使写在首部，也会在文档最后加载。 6 JS文件放在尾部 HTTP请求是并行的，不同浏览器并行下载的数目也不一样（2、4、或者8个），并行下载提高了HTTP请求的速度。而将JS文件放在首部，不仅会阻塞后面文件的下载而且会阻塞页面的渲染。 为什么会这样呢？原因有两个： JS文件中可能存在document.write修改页面的内容，因此页面会在脚本执行完成之后才可使渲染。 不同JS文件不管大小如何，可能存在依赖关系，因此必须按照顺序进行执行，因此在加载脚本的时候并行下载是禁止的。 所以，最好的方式是讲js文件放置在尾部，等页面所有可视化组件加载完成之后再进行请求，提高用户体验。7 7 图片如果太多的话，使用懒加载的方式:判断图片位置距离页面顶部的距离，先不加载图片，当用户滚动到该位置的时候将图片的src属性赋值为实际值，data-src可以先缓存图片的真实路径，方便取出；]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[underscore template js]]></title>
      <url>%2F2016%2F09%2F19%2F49-underscorejs%20template%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[一 underscore_template.js模板引擎的使用1 语法 12345678910&lt;script type="text/template"&gt; _.template模板函数只能解析3种模板标签（这比Smarty、JSTL要简单得多）：&lt;% %&gt;：用于包含JavaScript代码，这些代码将在渲染数据时被执行。&lt;%= %&gt;：用于输出数据，可以是一个变量、某个对象的属性、或函数调用（将输出函数的返回值）。&lt;%- %&gt;：用于输出数据，同时会将数据中包含的HTML字符转换为实体形式（例如它会将双引号转换为&amp;quot;形式），用于避免XSS攻击。&lt;/script&gt; 2-0 template模板函数基础 123456789101112131415_.template(templateString, [settings]) 将 JavaScript 模板编译为可以用于页面呈现的函数, 对于通过JSON数据源生成复杂的HTML并呈现出来的操作非常有用。 模板函数可以使用 &lt;%= … %&gt;插入变量, 也可以用&lt;% … %&gt;执行任意的 JavaScript 代码。 如果您希望插入一个值, 并让其进行HTML转义,请使用&lt;%- … %&gt;。 当你要给模板函数赋值的时候，可以传递一个含有与模板对应属性的data对象 。 如果您要写一个一次性的, 您可以传对象 data 作为第二个参数给模板 template 来直接呈现, 这样页面会立即呈现而不是返回一个模板函数. 参数 settings 是一个哈希表包含任何可以覆盖的设置 _.templateSettings.var compiled = _.template("hello: &lt;%= name %&gt;");compiled(&#123;name: 'moe'&#125;);=&gt; "hello: moe"var template = _.template("&lt;b&gt;&lt;%- value %&gt;&lt;/b&gt;");template(&#123;value: '&lt;script&gt;'&#125;);=&gt; "&lt;b&gt;&amp;lt;script&amp;gt;&lt;/b&gt;"您也可以在JavaScript代码中使用 print. 有时候这会比使用 &lt;%= ... %&gt; 更方便.var compiled = _.template("&lt;% print('Hello ' + epithet); %&gt;");compiled(&#123;epithet: "stooge"&#125;);=&gt; "Hello stooge" 2 -1模板解析 123456789101112131415161718192021222324252627282930313233343536&lt;!-- 用于显示渲染后的标签 --&gt; &lt;ul id="element"&gt;&lt;/ul&gt; &lt;!-- 定义模板，将模板内容放到一个script标签中 --&gt; &lt;script type="text/template" id="tpl"&gt; //注意type类型 "text/template" &lt;% for(var i = 0; i &lt; list.length; i++) &#123; %&gt; &lt;% var item = list[i] %&gt; &lt;li&gt; &lt;span&gt;&lt;%=item.firstName%&gt; &lt;%=item.lastName%&gt;&lt;/span&gt; &lt;span&gt;&lt;%-item.city%&gt;&lt;/span&gt; &lt;/li&gt; &lt;% &#125; %&gt; &lt;/script&gt; &lt;script type="text/javascript" src="underscore/underscore-min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; // 获取渲染元素和模板内容 var element = $('#element'), tpl = $('#tpl').html(); // 创建数据, 这些数据可能是你从服务器获取的 var data = &#123; list: [ &#123;firstName: '&lt;a href="#"&gt;Zhang&lt;/a&gt;', lastName: 'San', city: 'Shanghai'&#125;, &#123;firstName: 'Li', lastName: 'Si', city: '&lt;a href="#"&gt;Beijing&lt;/a&gt;'&#125;, &#123;firstName: 'Wang', lastName: 'Wu', city: 'Guangzhou'&#125;, &#123;firstName: 'Zhao', lastName: 'Liu', city: 'Shenzhen'&#125; ] &#125; // 解析模板, 返回解析后的内容 var html = _.template(tpl, data); //注意data 必须是javascript对象 // 将解析后的内容填充到渲染元素 element.html(html); &lt;/script&gt; 在本例中，我们将模板内容放到一个标签中，你可能已经注意到标签的type是text/template而不是text/javascript，因为它无法作为JavaScript脚本直接运行。 我也建议你将模板内容放在中，因为如果你将它们写在一个或其它标签中，它们可能会被添加到DOM树中进行解析（即使你隐藏了这个标签也无法避免）。 1231 将模板内容解析为可执行的JavaScript（解析模板标签）2 通过with语句将解析后的JavaScript作用域修改为我们传递的数据对象，这使我们能够直接在模板中通过变量形式访问3 3 数据对象的属性执行解析后的JavaScript（将数据填充到模板）4 返回执行后的结果 2 -2 12345// 解析模板, 返回解析后的内容 var render = _.template(tpl);//用render函数解析数据var html = render(data); element.html(html); 你会发现细微的差别：我们在调用template方法时只传递了模板内容，而没有传递数据，此时template方法会解析模板内容，生成解析后的可执行JavaScript代码，并返回一个函数，而函数体就是解析后的JavaScript，因此当我们调用该函数渲染数据时，就省去了模板解析的动作。 你应该将返回的函数存储起来（就像我将它存储在render变量中一样），再通过调用该函数来渲染数据，特别是在同一个模板可能会被多次渲染的情况下，这样做能提高执行效率（具体提升多少，应该根据你的模板长度和复杂度而定，但无论如何，这都是一个良好的习惯） 2 -3 another栗子 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang="en"&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;style&gt; th,td&#123; padding: 5px; border: 1px solid #ccc; &#125; &lt;/style&gt; &lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;序号&lt;/th&gt; &lt;th&gt;名字&lt;/th&gt; &lt;th&gt;年龄&lt;/th&gt; &lt;th&gt;性别&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;/tbody&gt; &lt;/table&gt;&lt;!--定义模版--&gt;&lt;!-- 执行js代码 获取解析函数传入的数据 --&gt;&lt;!-- 在 &lt;% 写js代码 %&gt; --&gt;&lt;!-- 获取值显示在页面当中 &lt;%=属性名称 %&gt; --&gt;&lt;script type="text/template" id="temp"&gt; &lt;% $.each(list,function(index,item)&#123; %&gt; &lt;!--model是传入的对象列表，第一个参数是索引，第二个参数是dom对象--&gt; &lt;tr&gt; &lt;td&gt;&lt;%=index%&gt;&lt;/td&gt; &lt;td&gt;&lt;%-item.name%&gt;&lt;/td&gt; &lt;td&gt;&lt;%=item.age%&gt;&lt;/td&gt; &lt;td&gt;&lt;%=item.sex%&gt;&lt;/td&gt; &lt;/tr&gt; &lt;% &#125;); %&gt;&lt;/script&gt;&lt;script src="../lib/jquery/jquery.min.js"&gt;&lt;/script&gt;&lt;script src="../lib/underscore/underscore-min.js"&gt;&lt;/script&gt; &lt;script&gt; $(function()&#123; var data = [ &#123; name:'小明1', age:18, sex:'女' &#125;, &#123; name:'小明1', age:18, sex:'女' &#125;, ]; var templateStr = $('#temp').html();//不写内容代表获取对象中的内容，返回是一个字符 // 将获取到的模板字符串转化成模板函数，模板函数可以多次调用 var templateFuc = _.template(templateStr); var htmlStr = templateFuc(&#123;list:data&#125;); //键值对: m 取值是 data ,m 作为 值传入 模板函数，代表data这个数据 // var HTMLStr = _.template(templateStr,&#123;m:data&#125;) /*5.渲染到页面当中*/// 将转化成的字符串渲染到页面中 $('tbody').html(htmlStr); &#125;) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[javascript经典面试题理解this]]></title>
      <url>%2F2016%2F09%2F19%2F105-javascript%20%20%20%20this%20%E5%92%8C%3D%20%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98%20%2F</url>
      <content type="text"><![CDATA[javascript this 经典面试题12345678910function Foo()&#123; getName = function()&#123;console.log("1");&#125;;//这个不属于Foo的属性 return this ; //如果作为构造函数，那么返回的this就是实例化对象， //如果作为函数直接执行，那么返回的this就是全局的window对象 &#125; Foo.getName = function()&#123;console.log("2"); &#125;; Foo.prototype.getName = function()&#123; console.log("3");&#125;; var getName =function()&#123;console.log("4");&#125;; function getName()&#123;console.log("5");&#125;; 预解析之后 12345678910var getName;//只提升变量声明 function getName()&#123;console.log("5");&#125;;//提升函数声明，覆盖变量var声明 function Foo()&#123; getName = function()&#123;console.log("1");&#125;;//这个不属于Foo的属性 return this ;//如果作为构造函数，那么返回的this就是实例化对象，如果作为函数直接执行，那么返回的this就是全局的window对象 &#125; Foo.getName = function()&#123;console.log("2"); &#125;; Foo.prototype.getName = function()&#123; console.log("3");&#125;; getName =function()&#123;console.log("4");&#125;; 可以在控制台输出看下数据结构 123console.dir(Foo);var res = Foo.getName();//注意没有返回值，如果将Foo看成对象，console.log(res); 看下面的求值过程 1234567891011121314 Foo.getName();//2 getName();//4 Foo().getName();//1 先执行了Foo() 函数，Foo函数第一句，getName没有用var声明，改变了输出4的getName,变为输出1//2 第二句 返回了this,代表当前指向环境的window;相当于执行了 window.getName(); getName();//1 直接调用getName ,上面一行代码改变后的结果//运算符的优先级 () &gt; 成员访问 . &gt; new 操作符 new Foo.getName();//2 new一个构造函数的时候，构造函数内部的代码会一行一行执行;// 等价于 new (Foo.getName)(); new Foo().getName();//3 Foo作为构造哦函数，没有给实例化的对象添加任何属性，只能去原型上找// 等价于 (new Foo()).getName(); new new Foo().getName();//3// 等价于 new (new Foo().getName)(); ————————————- = 运算符面试题 12345678910111213141516 /* 面试题 */ // 基本类型和引用类型 // 引用类型变量和对象属性（在内存实际上就是内存地址） var a = &#123;n:1&#125;; var b = a; a.x = a = &#123;n:2&#125;;//运算符的优先级 .的优先级最高 赋值操作是从右向左运算的 console.log(a.x);//undefined console.log(b.x);//&#123;n:2&#125;/*我们可以先尝试交换下连等赋值顺序（a = a.x = &#123;n: 2&#125;;），可以发现输出不变，即顺序不影响结果。那么现在来解释对象连等赋值的问题：按照es5规范，题中连等赋值等价于a.x = (a = &#123;n: 2&#125;);，按优先获取左引用（lref），然后获取右引用（rref）的顺序，a.x和a中的a都指向了&#123;n: 1&#125;。至此，至关重要或者说最迷惑的一步明确。(a = &#123;n: 2&#125;)执行完成后，变量a指向&#123;n: 2&#125;，并返回&#123;n: 2&#125;;接着执行a.x = &#123;n: 2&#125;，这里的a就是b（指向&#123;n: 1&#125;），所以b.x就指向了&#123;n: 2&#125;。*/]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[jQuery选择器]]></title>
      <url>%2F2016%2F09%2F17%2F18-jQuery%E4%B8%AD%E7%AD%9B%E9%80%89%E7%9A%84%E6%80%BB%E7%BB%93%2F</url>
      <content type="text"><![CDATA[jQuery中筛选的总结： 1 查找子代 children( ),如果不加选择器，那么将选择所有的子代元素，可以加一个选择器进行筛选；注意仅仅匹配子代元素，不匹配后代（子代的子代）； 查找所有后代 find( “ selector” ),可以选择所有的后代元素，包括子代的子代； 2 查找同辈元素：next() prev( ) 查找当前匹配到所有的对象的紧邻的后(前)一个元素；nextAll( ) prevAll( ),查找当前匹配对象的所有的对象的后面(前面)的所有元素； 3 查找匹配元素：first( ) last( ) ，查找匹配元素的第一个或者最后一个元素； 123456789101112131415161718&lt;ul id="ulist"&gt; &lt;li&gt;list item 0&lt;/li&gt; &lt;li&gt;list item 1 &lt;ul&gt; &lt;li&gt;最里面的li&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li id="list"&gt;list item 2&lt;/li&gt; &lt;li&gt;list item 3&lt;/li&gt; &lt;li&gt;list item 4&lt;/li&gt; &lt;li&gt;list item 5&lt;/li&gt;&lt;/ul&gt;$("#ulist").children()$("#ulist").children("li");//不包括最里面的li$("#ulist").find("li");//包括最里面的Li$("#list").prev();//获取list item1 $("#list").prevAll();//获取当前对象前面的所有的同辈元素$("li").first();//查找匹配元素的第一个或者最后一个元素,此时匹配的是listitem0]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[the config of require js]]></title>
      <url>%2F2016%2F09%2F16%2F144requirejs%2F</url>
      <content type="text"><![CDATA[1 require源码上可以看出来require.js有三个全局变量 require requirejs 和 define​ define ([ module1,module2····] ,callback) 中的module路径依赖 ​ require([ module1,module2····],callback) 中的module路径依赖 二者的路径依赖如何？ 如果设置了data-main,那么module引入路径就是相对于data-main文件所在目录为基准 如果设置了require.config baseUrl 的路径，那么define和require依赖的mudule引入 路径就是相对于baseUrl的 2 以data-main路径为准，且不设置baseUrl目录如下 1234567pathTest- index.html- js - jquery.js - main.js - require.js - test.js index.html 1&lt;script src="js/require.js" data-main="js/main"&gt;&lt;/script&gt; main.js 123require(['test'],function(w)&#123; //引入test模块的路径 js/test.js console.log(w);&#125;) test.js 1234define(['jquery'],function()&#123; //引入jquery模块的路径 js/jquery.js var w = $(window).width() return w ;&#125;) 3 设置baseUrl,看下路径变化改变下目录结构 12345678pathTest- index.html- js - main.js - require.js - test.js - jq - jquery.js main.js 设置baseUrl 关于date-main的实现原理 1234567891011121314151617181920212223242526272829303132333435//源码实现方式if (isBrowser &amp;&amp; !cfg.skipDataMain) &#123; eachReverse(scripts(), function (script) &#123; if (!head) &#123; head = script.parentNode; &#125; dataMain = script.getAttribute('data-main'); if (dataMain) &#123; mainScript = dataMain; if (!cfg.baseUrl) &#123; src = mainScript.split('/'); mainScript = src.pop(); subPath = src.length ? src.join('/') + '/' : './'; cfg.baseUrl = subPath; &#125; mainScript = mainScript.replace(jsSuffixRegExp, ''); if (req.jsExtRegExp.test(mainScript)) &#123; mainScript = dataMain; &#125; cfg.deps = cfg.deps ? cfg.deps.concat(mainScript) : [mainScript]; return true; &#125; &#125;);&#125; 123456require.config(&#123; baseUrl : 'js/jq'&#125;)require(['../test'],function(w)&#123; //此时如果在想依赖test模块，路径有变化需要向上走一级 console.log(w);&#125;) test.js 依赖模块路径以js/jq为准 1234define(['jquery'],function()&#123; //没有变化 var w = $(window).width() return w ;&#125;) 4 如果直接以 绝对路径 / 引入包，文件名后缀 js 不能再省略了；代表相对于服务器的根目录scheme:host : port / path 即path根目录 myvirtual 是我的一个虚拟主机 12345678myvirtual - test.js - jquery.js - pathTest - index.html - js - main.js - require.js main.js 123require(['/test.js'],function(w)&#123; // 代表域名根路径 myvirtual/test.js console.log(w);&#125;) test.js 1234define(['/jquery.js'],function()&#123; //myvirtual/jquery.js var w = $(window).width() return w ;&#125;) 5 通过require.config直接设置模块的路径，requirejs支持跨域获取文件 require.config1234567891011myvirtual //这是一个虚拟主机 - jquery.js - pathTest - module1.js - test.js - index.html - js - main.js - require.js myvirtual2 //这是另外一个虚拟主机 - innervirtual2.js index.html 1&lt;script src="js/require.js" data-main="js/main"&gt;&lt;/script&gt; main.js 123456789101112require.config(&#123; paths : &#123; mytest : "../test",//index.html设置data-main属性，所以默认根路径是main文件所在目录 myinner: "http://www.myvirtual2.com/innervirtual2" , //跨域设置路径 myabs : "/module1" ,//通过域的根目录设置包路径 myjquery : '/jquery' //通过域的根目录设置包路径 &#125;&#125;)require(['mytest','myinner','myabs'],function(arg1,arg2,arg3)&#123; console.log(arg1,arg2,arg3);&#125;) test.js 1234define(['myjquery'],function()&#123; var w = $(window).width() return 'this is test---'+w ;&#125;) module1.js 12345678define(function()&#123; var add = function(a,b)&#123; return a+b; &#125;; return &#123; add : add &#125;&#125;); myvirtual2 / innervirtual2.js 12345678define(function()&#123; var innerV2 = function()&#123; console.log("this is cross package"); &#125; return &#123; innerV2 : innerV2 &#125;&#125;) 6 submit6.1 如果直接通过路径获取包，如 2,3部分，文件后缀js可以省略 6.2 如果直接通过绝对路径获取包，如4部分，文件后缀js不能省略 6.3 如果设置require.config paths 设置包的路径，文件后缀js可以省略]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Git command detail Branch]]></title>
      <url>%2F2016%2F09%2F15%2F130Git%20command%20detailBranch%2F</url>
      <content type="text"><![CDATA[在不同的分支上的内容是不一样的，切换到不同分支，工作区的文件内容也是不一样的 分支管理 创建与合并分支 git branch 可以查看当前分支状态，分支的个数 此时master一个分支 git checkout -b newBranch 新建一个分支 newBranch git branch 此时分支多了一个newBranch git add index.html 将文件的变动添加到newBranch分支上 git commit -m’newBranch first’ 新建分支第一次commit,新建分支线延长 git checkout master 回到master主分支 在newBranch分支上对文件做的改动并没有在master分支上的文件上显示 git merge newBranch 将新建的分支和主分支合并 此时在新建的分支上做的变动会在之分支上显示出来 解决冲突 echo ‘content’ &gt; index.html 可以向文件中写入内容，会先清空文件中的内容 echo ‘content’ &gt;&gt; index.html 可以向文件中添加内容，原来的内容不会被清空 git checkout -b newBranch2 git add index.html git commit -m’commitNewBranch2’ 以上操作在 newBranch2 将文件内容改动，commit一次 git checkout master git add index.html git commit -m’commitmaster2’ 以上操作在master主分支将文件改动，commit一次 git merge newBranch2 此时合并会发生冲突，根本原因是master分支和newBrach2分支都提交了 注意这个时候必须先手动解决冲突，然后再次提交 在主分支上再次commit git add index.html git commit -m’ conflict fix’ git log –graph –pretty=oneline –abbrev-commit 可以查看分支合并的状况 在分支合并之后可以选择将被合并的分支删除 git branch -d newBranch 可以删除newBranch 分支 分支管理策略通常，合并分支时，如果可能，Git会用Fast forward模式，但这种模式下，删除分支后，会丢掉分支信息。如果要强制禁用Fast forward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。 合并分支时，加上–no-ff参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而fast forward`合并就看不出来曾经做过合并 git merge –on-ff -m’merge with –on-ff’ dev dev是一个新的分支，在这个新的分支上做改动 和远程仓库进行对接 本地master ——&gt;push本地master ——&gt;远程就有了master分支 ——&gt; 本地新建分支teacher——&gt; push本地teacher——&gt; merge之后可以删除分支，不删除也可以 当从远程仓库克隆的时候，仅仅克隆的是master分支，如果想要远程其他分支上的数据，比如master2分支 可以在本地新建一个分支master2，用于存放pull下来的分支 然后切换到本地该分支，进行pull远程仓库那个分支 git pull origin master2]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[src和href的区别]]></title>
      <url>%2F2016%2F09%2F13%2F176src%E5%92%8Chref%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
      <content type="text"><![CDATA[写代码的时候就经常把这两个属性弄混淆，到底是href还是src，href标识超文本引用，用在link和a等元素上，href是引用和页面关联，是在当前元素和引用资源之间建立联系，src表示引用资源，表示替换当前元素，用在img，script，iframe上，src是页面内容不可缺少的一部分。 src是source的缩写，是指向外部资源的位置，指向的内部会迁入到文档中当前标签所在的位置；在请求src资源时会将其指向的资源下载并应用到当前文档中，例如js脚本，img图片和frame等元素。 \\当浏览器解析到这一句的时候会暂停其他资源的下载和处理，直至将该资源加载，编译，执行完毕，图片和框架等元素也是如此，类似于该元素所指向的资源嵌套如当前标签内，这也是为什么要把js饭再底部而不是头部。 \当浏览器解析到这一句的时候会识别该文档为css文件，会下载并且不会停止对当前文档的处理，这也是为什么建议使用link方式来加载css而不是使用@import。 补充：link和@import的区别 两者都是外部引用CSS的方式，但是存在一定的区别： 区别1：link是XHTML标签，除了加载CSS外，还可以定义RSS等其他事务；@import属于CSS范畴，只能加载CSS。 区别2：link引用CSS时，在页面载入时同时加载；@import需要页面网页完全载入以后加载。 区别3：link是XHTML标签，无兼容问题；@import是在CSS2.1提出的，低版本的浏览器不支持。 区别4：ink支持使用Javascript控制DOM去改变样式；而@import不支持。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[apache virtual and Cross Origin]]></title>
      <url>%2F2016%2F09%2F13%2F135apacheVirtual%E4%BB%A5%E5%8F%8AAjax%2F</url>
      <content type="text"><![CDATA[写在前面:有兴趣的还是可以阅读下httpd.conf以及httpd-vhosts.conf 文件里面的注释，方便理解； 1 如何搭建本地apache服务器?下载wamp软件，安装完毕之后，启动apache服务器，在浏览器URL地址栏输入127.0.0.1或者localhost便可以进入apache主页(此时服务器默认的访问路径是(D是我安装在D盘) D/wamp/www/ 文件夹下面的index开头的文件,) 1.1 配置服务器访问路径 找到wamp —&gt;bin —&gt;apache 目录下面的 httpd.conf 修改默认访问路径,将 D/wamp/www/ 比如修改为 F:/mywork/ httpd.conf 中 DocumentRoot 可以修改默认访问的路径 F:/mywork/ httpd.conf 中 Directory 也要修改默认路径F:/web/ 如果该路径F:/mywork/ 里面有index.html index.php 等以index命名的文件,会直接打开该文件，如果没有则进入F:/mywork/该目录 为什么会默认打开index开头的文件呢？在httpd.conf文件中,如下代码设置了默认打开目录下面的文件名字 DirectoryIndex决定打开虚拟主机的时候，默认打开的文件名称 123&lt;IfModule dir_module&gt; DirectoryIndex index.php index.php3 index.html index.htm&lt;/IfModule&gt; 访问自己的服务器的三种方式：本机的IP地址 127.0.0.1 localhost httpd.conf 文件中listen 可以更改端口 此时在通过localhost或者127.0.0.1 再次进入的时候就会进入F:/mywork目录里面来(如果该目录下面有index开头的文件会默认直接打开该文件，如果没有的话则打开该目录) 只有在这里配置了目录之后，在配置虚拟主机的时候，虚拟主机的目录也必须是这个目录，或者这个目录的子目录 12345678&lt;VirtualHost *:80&gt; ServerAdmin webmaster@dummy-host.example.com DocumentRoot &quot; F:/mywork/&quot; //如果在虚拟主机配置的目录和F:/web不一致，则没有权限进入该目录，无论是通过localhost 还是通过127.0.0.1 都无法进入虚拟主机，必须要和服务器设置的访问路径保持一致; ServerName test.com ServerAlias www.test.com ErrorLog &quot;logs/dummy-host.example.com-error.log&quot; CustomLog &quot;logs/dummy-host.example.com-access.log&quot; common&lt;/VirtualHost&gt; 1.2 配置服务器通过域名访问 虚拟主机 先要明确配置虚拟主机的目的，上面第一步所实现的功能是，我们可以通过localhsot或者127.0.0.1以及本机ip地址来访问我们的服务器(也就是后来修改的文件目录 F:/mywork/) httpd.conf 文件中找到 # Virtual hosts 打开这行代码下面一行的 # 号 1Include conf/extra/httpd-vhosts.conf 当我们打开虚拟主机之后，重启apache服务，在通过localhost或者127.0.0.1已经无法进入 F:/mywork/目录，需要重新配置wamp —&gt;bin —&gt;apache—&gt;extra—&gt;httpd-vhosts.conf文件 12345VirtualHost example:# Almost any Apache directive may go into a VirtualHost container.# The first VirtualHost section is used for all requests that do not# match a ServerName or ServerAlias in any &lt;VirtualHost&gt; block.也就是说当我们设置虚拟主机的时候，Apache在所有的VirtualHost container中如果没有找到匹配的serverName或者ServerAlias的时候，会直接进入第一个Virtual Block 如下配置，我设置了三个主机，分别是mainVirtual myVirtual1 myVirtual2 对应不同的路径，但是都是F:/web/或者F:/web/的子目录，然后通过 ServerName ServerAlias设置的对应值，在浏览器的URL地址栏就可以访问了 1.2.1 设置host文件 C:\Windows\System32\drivers\etc 下面的host文件,我们在这里配置的域名，如果在URL地址栏输入该域名，我们就可以访问这个本机虚拟主机； 123127.0.0.1 www.mainVirtual.com127.0.0.1 www.myVirtual1.com127.0.0.1 www.myVirtual2.com 1.2.2 设置wamp —&gt;bin —&gt;apache—&gt;extra—&gt;httpd-vhosts.conf文件 12345678910111213141516171819202122232425262728# operation by JiM&lt;VirtualHost *:80&gt; ServerAdmin webmaster@dummy-host.example.com DocumentRoot &quot;F:/web/&quot; ServerName mainVirtual.com ServerAlias www.mainVirtual.com ErrorLog &quot;logs/dummy-host.example.com-error.log&quot; CustomLog &quot;logs/dummy-host.example.com-access.log&quot; common&lt;/VirtualHost&gt;# this is JiM&apos;s test for the Virtual container for myVirtual1&lt;VirtualHost *:80&gt; ServerAdmin webmaster@dummy-host.example.com DocumentRoot &quot;F:/web/myVirtual1&quot; ServerName myVirtual1.com ServerAlias www.myVirtual1.com ErrorLog &quot;logs/dummy-host.example.com-error.log&quot; CustomLog &quot;logs/dummy-host.example.com-access.log&quot; common&lt;/VirtualHost&gt;# this is JiM&apos;s test the Virtual container for myVirtual2&lt;VirtualHost *:80&gt; ServerAdmin webmaster@dummy-host.example.com DocumentRoot &quot;F:/web/myVirtual2&quot; ServerName myVirtual2.com ServerAlias www.myVirtual2.com DirectoryIndex doc.html //假如文件目录下有一个doc命名的文件，则DirectoryIndex的设置可以默认打开该文件 ErrorLog &quot;logs/dummy-host.example.com-error.log&quot; CustomLog &quot;logs/dummy-host.example.com-access.log&quot; common&lt;/VirtualHost&gt; 1.2.3 这个时候我们通过www.mainVirtual.com www.myVirtual1.com www.myVirtual2.com就可以访问我们对应的主机咯(每个路径对应的目录要事先创建好) 2 在本地搭建的服务器测试跨域的几种方案(同一域名下的不同子域之间也受同源策略的限制)假如 我在之前搭建的www.myVirtual1.com域下，也就是F:/web/myVirtual1文件夹下面有一个文件 test1.php www.myVirtual2.com这个域内的文件想访问www.myVirtual1.com下面的test1.php文件 URL(Uniform Resource Locator) 地址用于描述一个网络上的资源, 基本格式如下 1scheme://host[:port#]/path/.../[?query-string][#anchor] scheme host port三者有一个不一样就发生了跨域，如何解决跨域？ 2.1 Access-Control-Allow-Origin:域名 表示设置允许哪个域名进行访问 header(“Access-Control-Allow-Origin: http://www.myvirtual2.com“) 通过对访问的跨域资源设置响应头，允许某个指定的域名来访问该文件; 123456789101112//F:/web/myVirtual1/test1 .php 这个是我的虚拟主机1 里面的文件&lt;?php header("Access-Control-Allow-Origin: http://www.myvirtual2.com"); $username = $_GET['username']; $array = ["Jhon","Jim","James","Robe"]; $flag = in_array($username,$array); if($flag)&#123; echo '您可以登录'; &#125;else&#123; echo "该用户名已经被注册"; &#125;?&gt; 这个是虚拟主机2 里面的请求文件 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang="en"&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action="test1.php" method="post"&gt; &lt;input type="text" id="username" name="username"/&gt;&lt;span id="message"&gt;&lt;/span&gt;&lt;br&gt; &lt;input type="password" id="psw" name="psw"/&gt;&lt;/form&gt;&lt;script src="jquery-1.12.4.js"&gt;&lt;/script&gt;&lt;script&gt; $(function()&#123; $('#username').blur(function()&#123; var username = $(this).val(); console.log(username); $.ajax(&#123; url:'http://www.myvirtual1.com/test1.php?username=Jhon', type:'get', data:&#123;"username": username&#125; ,//代表发送到服务器的数据 success:function(data)&#123;//如果请求成功了，则可以执行该函数 console.log(data); $("#message").html(data) ; &#125; &#125;) &#125;) &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 2.2 通过script标签 src属性 123456789&lt;?php header("Content-Type:text/script;charset=utf-8");//如果没有这个响应头，在开发者network里面可以查看请求和响应的详细信息,默认返回的是Content-Type:text/html文本格式的数据，不过这个也不影响，script标签还是会将其解析成javascript代码运行 $callback = $_GET['callback']; $username = $_GET['username']; $array = ["Jhon","Jim","James","Robe"]; $flag = in_array($username,$array); $data = "&#123;0:'您可以登录',1:'该用户已经被注册'&#125;"; echo $callback.'('.$data.','.$flag.')';?&gt; 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang="en"&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt;&lt;body&gt;&lt;h1&gt;请注册&lt;/h1&gt;&lt;form action="" method="get"&gt; &lt;input type="text" id="username" name="username"/&gt;&lt;span id="message"&gt;&lt;/span&gt;&lt;br&gt; &lt;input type="password" id="psw" name="psw"/&gt;&lt;/form&gt;&lt;script src="jquery-1.12.4.js"&gt;&lt;/script&gt;&lt;script&gt; function getInfo(arg,flag)&#123; if(flag)&#123; console.log(arg); console.log(typeof arg); $("#message").html(arg[0]); &#125;else&#123; console.log("this count has been rejected"); $("#message").html(arg[1]); &#125; &#125;&lt;/script&gt;&lt;script src='http://www.myvirtual1.com/test1.php?callback=getInfo&amp;username=Jhon'&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 2.3 jQuery.ajax通过jsonp来进行跨域请求,本质上使用script标签发送请求,获取到的数据作为javascript代码直接执行 12345678910//F:/web/myVirtual1/test1 .php&lt;?php header("Content-Type:text/script;charset=utf-8"); $callback = $_GET['callback']; $username = $_GET['username']; $array = ["Jhon","Jim","James","Robe"]; $flag = in_array($username,$array); $data = "&#123;0:'您可以登录',1:'该用户已经被注册'&#125; echo $callback.'('.$data.','.$flag.')';?&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang="en"&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt;&lt;body&gt;&lt;h1&gt;请注册&lt;/h1&gt;&lt;form action="" method="get"&gt; &lt;input type="text" id="username" name="username"/&gt;&lt;span id="message"&gt;&lt;/span&gt;&lt;br&gt; &lt;input type="password" id="psw" name="psw"/&gt;&lt;/form&gt;&lt;script src="jquery-1.12.4.js"&gt;&lt;/script&gt;&lt;script&gt; function getInfo(arg,flag)&#123; console.log(flag); //这个flag一直是undefined,因为echo:flase不会有任何结果，不想改了，主要是理解跨域 if(flag)&#123; console.log(arg); console.log(typeof arg); $("#message").html(arg[0]); &#125;else&#123; console.log("this count has been rejected"); $("#message").html(arg[1]); &#125; &#125; $(function()&#123; $('#username').blur(function()&#123; var username = $(this).val(); $.ajax(&#123; url:'http://www.myvirtual1.com/test1.php', type:'get', dataType:'jsonp', jsonpCallback:'getInfo',//用来替换jQuery自动生成的函数名,以便于直接执行getInfo函数 data:&#123;"username": username&#125; ,//代表发送到服务器的数据 &#125;) &#125;) &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 2.4 通过反向代理进行跨域访问 反向代理作用1：减轻源服务器负载 2：保障源服务器安全 3：对源服务器进行负载均衡(Load Balance)。通过在服务器端设置代理服务，可以进行跨域访问 打开httpd-conf文件,打开以下两行代码中的#号 12LoadModule proxy_module modules/mod_proxy.so LoadModule proxy_http_module modules/mod_proxy_http.so 我们在新建两个虚拟主机 12345678910111213141516&lt;VirtualHost *:80&gt; ServerAdmin webmaster@dummy-host.example.com DocumentRoot &quot;F:/web/4myvirtual4&quot; ServerName myvirtual4.com ServerAlias www.myvirtual4.com ErrorLog &quot;logs/dummy-host.example.com-error.log&quot; CustomLog &quot;logs/dummy-host.example.com-access.log&quot; common&lt;/VirtualHost&gt;&lt;VirtualHost *:80&gt; DocumentRoot &quot;F:/web/5myvirtual5&quot; ServerName myvirtual5.com ServerAlias www.myvirtual5.com ProxyRequests Off ProxyPass /api http://www.myvirtual4.com#这个时候访问http://www.myvirtual5.com/api 其实就是访问 http://www.myvirtual4.com&lt;/VirtualHost&gt; ProxyRequests Off 指令是指采用反向(reverse)代理 ProxyPass 指令允许将一个远端服务器映射到本地服务器的 URL 空间中。 在F:/web/5myvirtual5 下面有一个文件 01proxy.html 12345678910&lt;script src="jquery.js"&gt;&lt;/script&gt;&lt;script&gt; $.ajax(&#123; type:'get', url:'/api/01proxy.php', success:function(data)&#123; console.log(data); &#125; &#125;)&lt;/script&gt; 在F:/web/4myvirtual4 下有一个文件 01proxy.php 123&lt;?php echo 'this is sonme data from virtual4'?&gt; 2.5 通过document.domain 设置同一主域不同子域中的页面相同的主域名，来允许不同子域之间进行访问 2.6 通过HTML5postMessage方法进行跨域操作，参见我的博客HTML5-postMessage 2.7 绕开浏览器，直接通过服务器端发送请求 2.8 关于其他跨域问题，比如其他的服务器会通过请求的referer信息进行访问的限制，可以通过设置 1&lt;meta name=''&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ArrayLikeChangedToArray]]></title>
      <url>%2F2016%2F09%2F13%2F100-%E7%B1%BB%E6%95%B0%E7%BB%84%E8%BD%AC%E5%8C%96%E4%B8%BA%E6%95%B0%E7%BB%84%2F</url>
      <content type="text"><![CDATA[类数组对象转换为数组对象的简单理解一 : 关于类数组对象：只包含使用从零 0 开始，且自然递增的整数做键名，并且定义了length表示元素个数的对象JavaScript中有一些著名的类数组对象，它们看起来很像数组： 拥有length属性 这里强调一下，必须有length属性，且length属性的值必须和元素键值对个数保持一致 如果没有length属性，那么就不是类数组 元素按序保存在对象中，可以通过索引访问 但实际和数组又不是一回事： 没有数组的很多方法 也会有数组没有的方法(e.g. NodeList的item()方法) 有些类数组对象是动态变化的(e.g. NodeList的值是基于DOM结构动态执行查询的结果) 123456789var arrLike = &#123; 0:7, 1:8, 2:9, length:2 //length属性值小于3 最后一个9不会被添加进去 &#125; var arr1 = [1,2,3]; arr1.push.apply(arr1,arrLike); console.dir(arr1); 123456789var arrLike = &#123; 0:7, 1:8, 2:9, length:3 //length属性值等于3 &#125; var arr1 = [1,2,3]; arr1.push.apply(arr1,arrLike) console.dir(arr1); 123456789var arrLike = &#123; 0:7, 1:8, 2:9, length:5 //length属性值大于3 &#125; var arr1 = [1,2,3]; arr1.push.apply(arr1,arrLike) console.dir(arr1); 12345678var arrLike = &#123; 1:8, 2:9, length:5 //缺少索引为0 的键 &#125; var arr1 = [1,2,3]; arr1.push.apply(arr1,arrLike) console.dir(arr1); 通过以上四种情况，大家可以在自己电脑上输出看下结果，类数组对象的定义大家应该会有一种新的认识； 二 : 将 类数组对象 转换为 数组对象 slice 和splice方法都可以，slice不会改变原数组，splice会将改变原数组 123456Array.prototype.slice.call(arraylike, 0);Array.prototype.splice.call(arrLike,0);Array.prototype.slice.apply(arrayLike,[0]) ;//注意咯，这里必须是 数组形式的参数,Array.prototype.splice.apply(arrLike,[0]);//参数会传递给slice或者splice方法 1234567891011 var arrLike = &#123; 0:"name", 1:"age", 2:"address", length:3 &#125;// var ret = Array.prototype.slice.call(arrLike,0);// var ret = Array.prototype.splice.call(arrLike,0);// var ret = Array.prototype.slice.apply(arrLike,[0]);// var ret = Array.prototype.splice.apply(arrLike,[0]); console.dir(ret); push + apply + 空数组(apply会将传入的数组或者类数组拆分开以单个元素的形式传递给push,然后push就可以正常的往数组里面加元素咯) 123456789101112 var arrLike = &#123; 0:"name", 1:"age", 2:"address", length:3 &#125; var ret = []; Array.prototype.push.apply(ret,arrLike); //Array.prototype.push.call(ret,arrLike); //这个会将arrLike作为一个整体直接push进ret数组中//arrLike 必须是一个伪数组，length属性不可少，索引值必须从 0 开始递增，不是 console.dir(ret);//这个方法的关键还是要理解apply方法会对传入的数组进行拆分，这个真的很重要 以上的栗子，大家可以将类数组的length属性去掉试一下看看，就会发现这个属性对于类数组 定义的重要性了]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ClientRenderOrServerRender]]></title>
      <url>%2F2016%2F09%2F12%2F172ClientRenderOrServerRender%2F</url>
      <content type="text"><![CDATA[模板引擎 （Template Engine）是Web开发中将展现层和数据分离的一项技术。模板引擎根据一定的语义，将数据填充到模板中，产生最终的HTML页面。模板引擎渲染的位置可分为客户端和服务器端。 服务器端渲染：模板引擎在服务器端将模板和数据合成，返回最终的HTML页面 客户端渲染通常使用JavaScript脚本，如果某些客户端不支持JavaScript，就需要在服务器端渲染； 搜索引擎通常不执行JavaScript脚本，要做到SEO友好，就必须实现服务器端渲染； SEO 很多爬虫是不认的。 首次打开速度，各种加载 速度很慢。 客户端渲染：将模板和数据分别传送到客户端，在客户端由JavaScript模板引擎渲染出最终的HTML视图。 可以对模板文件（相对静态）进行缓存和负载平衡，对于流量很大的公众站点非常有价值； 由于将模板渲染的计算转移到客户端，可降低服务器负荷； 各种原来服务器做的事情丢给客户端做了，减少开销。 如果一个前端页面的内容分别来自多个后台系统，而这些后台的架构各不相同（Java、.NET、Ruby等），则服务器端渲染需要采用不同的技术，模板资源无法共享。客户端渲染则不存在这个问题，不同的后台系统可采用相同的客户端渲染技术，这样互相之间的模板资源可以公用，前端页面的整合非常容易； 注意问题 客户端渲染和服务端渲染的时候，文件的语法格式不能一样，否则会冲突]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[媒体查询 响应式开发]]></title>
      <url>%2F2016%2F09%2F10%2F39-%E5%AA%92%E4%BD%93%E6%9F%A5%E8%AF%A2%E5%93%8D%E5%BA%94%E5%BC%8F%E5%BC%80%E5%8F%91%2F</url>
      <content type="text"><![CDATA[媒体查询:响应式开发 第一种不同终端的宽度自适应代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang="en"&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; .container &#123; width: 1200px; height: 1000px; margin: 0 auto; background-color: red; &#125; @media screen and (min-width:1200px)&#123; body&#123; /*当屏幕大小最小满足1200px即大于1200px的时候 */ /*background-color: pink;*/ &#125; .container &#123; width: 1170px; background-color: pink; &#125; &#125; @media screen and (min-width:992px) and (max-width: 1200px)&#123; .container &#123; width: 970px; background: green; &#125; &#125; @media screen and (min-width: 768px) and (max-width: 992px)&#123; .container &#123; width: 750px; background-color: blue; &#125; &#125; @media screen and (max-width: 768px)&#123; .container &#123; width: 100%; background-color: orange; &#125; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="container"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 第二种不同终端宽度自适应代码 ：代码覆盖 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang="en"&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; html,body &#123; margin: 0 ; padding: 0; &#125; .container &#123; width: 1200px; height: 1000px; margin: 0 auto; background-color: red; &#125; /*以覆盖的方式存在*/ @media (max-width: 768px)&#123; .container &#123; width: 100%; background-color: orange; &#125; &#125; @media (min-width: 768px) &#123; .container &#123; width: 750px; background-color: blue; &#125; &#125; @media (min-width:992px) &#123; .container &#123; width: 970px; background: green; &#125; &#125; @media (min-width:1200px)&#123; /*当屏幕大小最小满足1200px即大于1200px的时候 */ /*background-color: pink;*/ .container &#123; width: 1170px; background-color: pink; &#125; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="container"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[require js]]></title>
      <url>%2F2016%2F09%2F10%2F143requirejs%2F</url>
      <content type="text"><![CDATA[1 函数调用的复杂性，在一个命名空间的概念下 1234567891011121314151617181920212223 //命名空间的概念下 var M = M || &#123;&#125;; M.m = M.m || &#123;&#125;;//||找true运算，undefined返回false M.m.module1 = (function()&#123;// some code here return &#123; func1:function()&#123;&#125;, func2:function()&#123;&#125; &#125; &#125;)(); M.m.module2 = (function()&#123; // some code here return &#123; func1:function()&#123;&#125;, func2:function()&#123;&#125; &#125; &#125;)(); //调用每个模块下面的方法，如果M 和 m更加长，那么调用起来是不是废了老劲了 M.m.module1.func1(); M.m.module1.func2(); M.m.module2.func1(); M.m.module2.func2(); 2 导入一个公共接口，本着面向对象的思想在进行简化 对外开发一个接口 www.myexcute.com 123456789101112131415161718//导入一个接口,就像导入jQuery一样 (function($,module1)&#123; //some code here //jQuery的所有方法可以使用 //$.extend //M.m.module1 接口所有的方法可以用 module1.func1();//这种调用的方式比起上面的调用是不简化了不少 module1.func2(); &#125;)(jQuery, M.m.module1); (function($,module2)&#123; //some code here //jQuery的所有方法可以使用 //$.extend //M.m.module1 接口所有的方法可以用 module2.func1(); module2.func2(); &#125;)(jQuery, M.m.module2); 虽然这个样子，代码冲突的可能性已经很小，但是代码依赖的问题，多脚本的管理、阻塞的问题，仍旧无法解决 3 此时require.js便初露头角 简单地说，有两点，一、模块作用域自成一体，不污染全局空间；二、模块指明依赖关系，并且依赖是通过参数传递的形式导入的，无需通过全局对象引用 – 依赖同样不污染全局空间。定义模块 3.1 如何定义模块 1define(id? , dependencies ? , factory) ; ?表示可选项 模块可以分为两种，第一种是无依赖的模块 123456789//math.jsdefine(function()&#123; var add = function(a,b)&#123; return a+b; &#125;; return &#123; add : add &#125;&#125;); 第二种是有依赖的模块 dependencies是一个数组形式的参数，factory函数接受的参数是依赖模块的返回值 12345//getWidth.js文件define(['jquery'],function($)&#123; //jquery.js和getWidth.js在同一目录下 var width = $(window).width(); return width;&#125;); 3.2 如何导入模块 require([‘module1’,’module2’ ],callback) 传入的依赖必须是一个数组形式存在的，callback是依赖传入完毕之后执行的逻辑;如果模块有返回值，则会直接传递给callback函数的形参，如果函数没有返回值，那么传递的callback形参的值是undefined 文件目录如下 12345678test - index.html- js - require.js - jquery.js - main.js //入口文件 - getWidth.js 12345//main.js require请求的是模块的路径，因为使用了data-main属性，require默认访问路径是main.js所在目录，也就是js/require(['getWidth','jquery'],function(ret)&#123; //这里的jquery是引入的本地文件 console.log(ret);&#125;)//等价于 js/getWidth.js js/jquery.js 关于requirejs的实现原理 indx.html文件中引入requirejs 1&lt;script src='require.js' data-main = "js/main"&gt; 加载requirejs脚本的script标签加入了data-main属性，这个属性指定的js将在加载完reuqire.js后处理，我们把require.config的配置加入到data-main后，就可以使每一个页面都使用这个配置，然后页面中就可以直接使用require来加载所有的短模块名 data-main还有一个重要的功能，当script标签指定data-main属性时，require会默认的将data-main指定的js为根路径，是什么意思呢？如上面的data-main=”js/main”设定后，我们在使用require([‘jquery’])后(不配置jquery的paths)，require会自动加载js/jquery.js这个文件，而不是jquery.js，相当于默认配置了： data-main需要给所有的脚本文件设置一个根路径。根据这个根路径，RequireJS将会去加载所有相关的模块。下面的脚本是一个使用data-main例子： 123require.config(&#123; baseUrl : "js"&#125;) 3.3 如果我们导入的文件是不符合require的规范或者导入文件来自本地服务器或者CDN或者其他的网站，这个时候上面的require方法就不能起作用了，这个时候我们需要配置文件的地址 12345//配置函数require.config(&#123;&#125;)baseUrl——用于加载模块的根路径。paths——用于映射不存在根路径下面的模块路径。shims——配置在脚本/模块外面并没有使用RequireJS的函数依赖并且初始化函数。假设underscore并没有使用 RequireJS定义，但是你还是想通过RequireJS来使用它，那么你就需要在配置中把它定义为一个shim。deps——加载依赖关系数组 不符合规范 : 先来看一个简单的例子,文件目录如下 1234567export- index.html- js - sayhello.js - main.js - require.js 12//index.html 加如下代码&lt;script src="js/require.js" data-main='js/main'&gt;&lt;/script&gt; 1234//sayhello.jsfunction hello()&#123; console.log("hello handsome you");&#125; 123456789101112//main.js require.config(&#123; paths : &#123; h : 'sayhello' //模块h的路径是js/hello.js 因为data-main属性的作用 &#125;, shim : &#123; h :&#123; exports : 'hello'&#125; //将hello函数暴露出去;如果少了这行代码会报错 &#125;&#125;)require(['h'],function(hello)&#123; hello();&#125;) 上面代码 exports: ‘hello’中的 hello，是我们在 hello.js 中定义的 hello 函数。当我们使用 function hello() {} 的方式定义一个函数的时候，它就是全局可用的。如果我们选择了把它 export给requirejs，那当我们的代码依赖于 hello 模块的时候，就可以拿到这个 hello 函数的引用了。 所以： exports 可以把某个非requirejs方式的代码中的某一个全局变量暴露出去，当作该模块以引用。 3.3.1 假如我想暴露多个sayhello.js中的全局变量呢？ 1234567//sayhello.jsfunction hello()&#123; console.log("hello handsome you");&#125;function hello1()&#123; console.log("hello1 handsome you");&#125; 这个时候main.js不能再用export了，应该使用init来初始化这些接口 123456789101112131415161718192021require.config(&#123; paths : &#123; h : 'sayhello' &#125;, //shim : &#123; // h :&#123; exports : 'hello'&#125; //&#125; shim : &#123; h :&#123; init: function() &#123; return &#123; h0: hello, h1: hello1 &#125; &#125;&#125; &#125;&#125;)require(['h'],function(he)&#123; console.log(arguments); he.h0() he.h1()&#125;) 3.3.2 导入外部服务器的文件，requirejs支持跨域 12345678910111213require.config(&#123; paths : &#123; "jq" : ["http://libs.baidu.com/jquery/2.0.3/jquery"], "a" : "js/a" &#125;&#125;)//配置完之后，下面可以引用jquery模块require(["jq","a"],function()&#123; //在这里面可以直接使用jquery的所有API $(function()&#123; alert("load finished"); &#125;)&#125;) 3.4 如何引入第三方不不符合AMD规范的模块呢？这个时候需要进行配置 1234567891011require.config(&#123; shim:&#123; 'underscore':&#123; exports:"_"; &#125; &#125;&#125;);//配置之后，我们就可以在其他模块中引入underscore模块了require('underscore',function(_)&#123; _.each([1,2,3], alert);&#125;); 3.5 如何引入第三方不符合AMD规范的插件 1234567891011require.config(&#123; shim: &#123; "underscore" : &#123; exports : "_"; &#125;, "jquery.form" : &#123; deps : ["jquery"] &#125; &#125;&#125;);// 4 requirejs优势 4.1并行加载 我们知道，`&lt;script&gt;&lt;/script&gt;` 标签会阻塞页面，加载 a.js 时，后面的所有文件都得等它加载完成并执行结束后才能开始加载、执行。而 require.js 的模块可以并行下载，没有依赖关系的模块还可以并行执行，大大加快页面访问速度。 4.2 不愁依赖 在我们定义模块的时候，我们就已经决定好模块的依赖 – c 依赖 b，b 又依赖 a。当我想用 c 模块的功能时，我只要在 require函数的依赖里指定 c： require([&apos;c&apos;], function(c) {...}); 至于 c 依赖的模块，c 依赖的模块的依赖模块… 等等，require.js 会帮我们打理 4.3 减少全局冲突 通过 define 的方式，我们大量减少了全局变量，这样代码冲突的概率就极小极小 – JavaScript 界有句话说，全局变量是魔鬼，想想，我们能减少魔鬼的数量，我想是件好事。 关于全局变量 有一点需要说明的是，require.js 环境中并不是只有 define 和 require 几个全局变量。许多库都会向全局环境中暴露变量，以 jQuery 为例，1.7版本后，它虽然注册自己为 AMD 模块，但同时也向全局环境中暴露了 jQuery 与 $。所以以下代码中，虽然我们没有向回调函数传入一份引用，jQuery/$ 同样是存在的：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[AMD and CMD]]></title>
      <url>%2F2016%2F09%2F10%2F155AMD-%E8%AF%AD%E6%B3%95%E8%A7%84%E8%8C%83%2F</url>
      <content type="text"><![CDATA[CMD([Common Module Definition]) AMD SeaJS 遵循 CMD 规范，RequireJS 遵循 AMD 规范。 CMD 模块依赖声明方式： 1234define(function (require) &#123; var a = require('./a'); var b = require('./b');&#125;) CMD 规范的弊端 不能直接压缩：require是局部变量，意味着不能直接的通过压缩工具进行压缩，若require这个变量被替换，加载器与自动化工具将无法获取模块的依赖。 模块书写有额外约定：路径参数不能进行字符串运算，不能使用变量代替，否则加载器与自动化工具无法正确提取路径。 AMD 模块依赖声明方式： 123define(['./a', './b'], function (a, b) &#123; // more code ..&#125;) AMD 规范的弊端 依赖提前声明在代码书写上不是那么友好 模块内部与 NodeJS 的 Modules 有一定的差异 其实无论是 CMD 还是 AMD 的异步模块，都无法与同步模块规范保持一致（NodeJS 的 Modules），只有谁比谁更像同步模块而已。AMD 要转换为同步模块，除了去掉define函数的包裹外，需要在头部使用require把依赖声明好，而 CMD 只需要去掉define函数的包裹即可。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[http status]]></title>
      <url>%2F2016%2F09%2F01%2F137httpstatus%2F</url>
      <content type="text"><![CDATA[HTTP状态码大全完整的 HTTP 1.1规范说明书来自于RFC 2616，你可以在http://www.talentdigger.cn/home/link.php?url=d3d3LnJmYy1lZGl0b3Iub3JnLw%3D%3D在线查阅。HTTP 1.1的状态码被标记为新特性，因为许多浏览器只支持 HTTP 1.0。你应只把状态码发送给支持 HTTP 1.1的客户端，支持协议版本可以通过调用request.getRequestProtocol来检查。本部分余下的内容会详细地介绍 HTTP 1.1中的状态码。这些状态码被分为五大类：100-199 用于指定客户端应相应的某些动作。200-299 用于表示请求成功。300-399 用于已经移动的文件并且常被包含在定位头信息中指定新的地址信息。400-499 用于指出客户端的错误。500-599 用于支持服务器错误。HttpServletResponse中的常量代表关联不同标准消息的状态码。在servlet程序中，你会更多地用到这些常量的标识来使用状态码。例如：你一般会使用response.setStatus(response.SC_NO_CONTENT)而不是 response.setStatus(204)，因为后者不易理解而且容易导致错误。但是，你应当注意到服务器允许对消息轻微的改变，而客户端只注意状态码的数字值。所以服务器可能只返回 HTTP/1.1 200 而不是 HTTP/1.1 200 OK。100 (Continue/继续)如果服务器收到头信息中带有100-continue的请求，这是指客户端询问是否可以在后续的请求中发送附件。在这种情况下，服务器用100(SC_CONTINUE)允许客户端继续或用417 (Expectation Failed)告诉客户端不同意接受附件。这个状态码是 HTTP 1.1中新加入的。101 (Switching Protocols/转换协议)101 (SC_SWITCHING_PROTOCOLS)状态码是指服务器将按照其上的头信息变为一个不同的协议。这是 HTTP 1.1中新加入的。200 (OK/正常)200 (SC_OK)的意思是一切正常。一般用于相应GET和POST请求。这个状态码对servlet是缺省的；如果没有调用setStatus方法的话，就会得到200。201 (Created/已创建)201 (SC_CREATED)表示服务器在请求的响应中建立了新文档；应在定位头信息中给出它的URL。202 (Accepted/接受)202 (SC_ACCEPTED)告诉客户端请求正在被执行，但还没有处理完。203 (Non-Authoritative Information/非官方信息)状态码203 (SC_NON_AUTHORITATIVE_INFORMATION)是表示文档被正常的返回，但是由于正在使用的是文档副本所以某些响应头信息可能不正确。这是 HTTP 1.1中新加入的。204 (No Content/无内容)在并没有新文档的情况下，204 (SC_NO_CONTENT)确保浏览器继续显示先前的文档。这各状态码对于用户周期性的重载某一页非常有用，并且你可以确定先前的页面是否已经更新。例如，某个servlet可能作如下操作：int pageVersion =Integer.parseInt(request.getParameter(“pageVersion”));if (pageVersion &gt;;= currentVersion) { response.setStatus(response.SC_NO_CONTENT);} else { // Create regular page}但是，这种方法对通过刷新响应头信息或等价的HTML标记自动重载的页面起作用，因为它会返回一个204状态码停止以后的重载。但基于JavaScript脚本的自动重载在这种情况下仍然需要能够起作用。可以阅读本书7.2 ( HTTP 1.1 Response Headers and Their Meaning/HTTP 1.1响应头信息以及他们的意义)部分的详细讨论。205 (Reset Content/重置内容)重置内容205 (SC_RESET_CONTENT)的意思是虽然没有新文档但浏览器要重置文档显示。这个状态码用于强迫浏览器清除表单域。这是 HTTP 1.1中新加入的。206 (Partial Content/局部内容)206 (SC_PARTIAL_CONTENT)是在服务器完成了一个包含Range头信息的局部请求时被发送的。这是 HTTP 1.1中新加入的。300 (Multiple Choices/多重选择)300 (SC_MULTIPLE_CHOICES)表示被请求的文档可以在多个地方找到，并将在返回的文档中列出来。如果服务器有首选设置，首选项将会被列于定位响应头信息中。301 (Moved Permanently)301 (SC_MOVED_PERMANENTLY)状态是指所请求的文档在别的地方；文档新的URL会在定位响应头信息中给出。浏览器会自动连接到新的URL。302 (Found/找到)与301有些类似，只是定位头信息中所给的URL应被理解为临时交换地址而不是永久的。注意：在 HTTP 1.0中，消息是临时移动(Moved Temporarily)的而不是被找到，因此HttpServletResponse中的常量是SC_MOVED_TEMPORARILY不是我们以为的SC_FOUND。注意代表状态码302的常量是SC_MOVED_TEMPORARILY而不是SC_FOUND。状态码302是非常有用的因为浏览器自动连接在定为响应头信息中给出的新URL。这非常有用，而且为此有一个专门的方法——sendRedirect。使用response.sendRedirect(url)比调用response.setStatus(response.SC_MOVED_TEMPORARILY)和response.setHeader(“Location”, url)多几个好处。首先，response.sendRedirect(url)方法明显要简单和容易。第二，servlet自动建立一页保存这一连接以提供给那些不能自动转向的浏览器显示。最后，在servlet 2.2版本（J2EE中的版本）中，sendRedirect能够处理相对路径，自动转换为绝对路径。但是你只能在2.1版本中使用绝对路径。如果你将用户转向到站点的另一页中，你要用 HttpServletResponse 中的 encodeURL 方法传送URL。这么做可预防不断使用基于URL重写的会话跟踪的情况。URL重写是一种在你的网站跟踪不使用 cookies 的用户的方法。这是通过在每一个URL尾部附加路径信息实现的，但是 servlet 会话跟踪API会自动的注意这些细节。会话跟踪在第九章讨论，并且养成使用 encodeURL 的习惯会使以后添加会话跟踪的功能更容易很多。核心技巧如果你将用户转向到你的站点的其他页面，用 response.sendRedirect(response.encodeURL(url)) 的方式事先计划好会话跟踪(session tracking)要比只是调用 response.sendRedirect(url) 好的多。这个状态码有时可以与301交换使用。例如，如果你错误的访问了http://www.talentdigger.cn/home/link.php?url=aG9zdC9%2BdXNlcg%3D%3D（路径信息不完整），有些服务器就会回复301状态码而有些则回复302。从技术上说，如果最初的请求是GET浏览器只是被假定自动转向。如果想了解更多细节，请看状态码307的讨论。303 (See Other/参见其他信息)这个状态码和 301、302 相似，只是如果最初的请求是 POST，那么新文档（在定位头信息中给出）药用 GET 找回。这个状态码是新加入 HTTP 1.1中的。304 (Not Modified/为修正)当客户端有一个缓存的文档，通过提供一个 If-Modified-Since 头信息可指出客户端只希望文档在指定日期之后有所修改时才会重载此文档，用这种方式可以进行有条件的请求。304 (SC_NOT_MODIFIED)是指缓冲的版本已经被更新并且客户端应刷新文档。另外，服务器将返回请求的文档及状态码 200。servlet一般情况下不会直接设置这个状态码。它们会实现getLastModified方法并根据修正日期让默认服务方法处理有条件的请求。这个方法的例程已在2.8部分(An Example Using Servlet Initialization and Page Modification Dates/一个使用servlet初始化和页面修正日期的例子)给出。305 (Use Proxy/使用代理)305 (SC_USE_PROXY)表示所请求的文档要通过定位头信息中的代理服务器获得。这个状态码是新加入 HTTP 1.1中的。307 (Temporary Redirect/临时重定向)浏览器处理307状态的规则与302相同。307状态被加入到 HTTP 1.1中是由于许多浏览器在收到302响应时即使是原始消息为POST的情况下仍然执行了错误的转向。只有在收到303响应时才假定浏览器会在POST请求时重定向。添加这个新的状态码的目的很明确：在响应为303时按照GET和POST请求转向；而在307响应时则按照GET请求转向而不是POST请求。注意：由于某些原因在HttpServletResponse中还没有与这个状态对应的常量。该状态码是新加入HTTP 1.1中的。注意在 HttpServletResponse 中没有 SC_TEMPORARY_REDIRECT 常量，所以你只能显示的使用307状态码。400 (Bad Request/错误请求)400 (SC_BAD_REQUEST)指出客户端请求中的语法错误。401 (Unauthorized/未授权)401 (SC_UNAUTHORIZED)表示客户端在授权头信息中没有有效的身份信息时访问受到密码保护的页面。这个响应必须包含一个WWW-Authenticate的授权信息头。例如，在本书4.5部分中的“Restricting Access to Web Pages./限制访问Web页。”403 (Forbidden/禁止)403 (SC_FORBIDDEN)的意思是除非拥有授权否则服务器拒绝提供所请求的资源。这个状态经常会由于服务器上的损坏文件或目录许可而引起。404 (Not Found/未找到)404 (SC_NOT_FOUND)状态每个网络程序员可能都遇到过，他告诉客户端所给的地址无法找到任何资源。它是表示“没有所访问页面”的标准方式。这个状态码是常用的响应并且在HttpServletResponse类中有专门的方法实现它：sendError(“message”)。相对于setStatus使用sendError得好处是：服务器会自动生成一个错误页来显示错误信息。但是，Internet Explorer 5浏览器却默认忽略你发挥的错误页面并显示其自定义的错误提示页面，虽然微软这么做违反了 HTTP 规范。要关闭此功能，在工具菜单里，选择Internet选项，进入高级标签页，并确认“显示友好的 HTTP 错误信息”选项（在我的浏览器中是倒数第8各选项）没有被选。但是很少有用户知道此选项，因此这个特性被IE5隐藏了起来使用户无法看到你所返回给用户的信息。而其他主流浏览器及IE4都完全的显示服务器生成的错误提示页面。可以参考图6-3及6-4中的例子。核心警告默认情况下，IE5忽略服务端生成的错误提示页面。405 (Method Not Allowed/方法未允许)405 (SC_METHOD_NOT_ALLOWED)指出请求方法(GET, POST, HEAD, PUT, DELETE, 等)对某些特定的资源不允许使用。该状态码是新加入 HTTP 1.1中的。406 (Not Acceptable/无法访问)406 (SC_NOT_ACCEPTABLE)表示请求资源的MIME类型与客户端中Accept头信息中指定的类型不一致。见本书7.2部分中的表7.1(HTTP 1.1 Response Headers and Their Meaning/HTTP 1.1响应头信息以及他们的意义)中对MIME类型的介绍。406是新加入 HTTP 1.1中的。407 (Proxy Authentication Required/代理服务器认证要求)407 (SC_PROXY_AUTHENTICATION_REQUIRED)与401状态有些相似，只是这个状态用于代理服务器。该状态指出客户端必须通过代理服务器的认证。代理服务器返回一个Proxy-Authenticate响应头信息给客户端，这会引起客户端使用带有Proxy-Authorization请求的头信息重新连接。该状态码是新加入 HTTP 1.1中的。408 (Request Timeout/请求超时)408 (SC_REQUEST_TIMEOUT)是指服务端等待客户端发送请求的时间过长。该状态码是新加入 HTTP 1.1中的。409 (Conflict/冲突)该状态通常与PUT请求一同使用，409 (SC_CONFLICT)状态常被用于试图上传版本不正确的文件时。该状态码是新加入 HTTP 1.1中的。410 (Gone/已经不存在)410 (SC_GONE)告诉客户端所请求的文档已经不存在并且没有更新的地址。410状态不同于404，410是在指导文档已被移走的情况下使用，而404则用于未知原因的无法访问。该状态码是新加入 HTTP 1.1中的。411 (Length Required/需要数据长度)411 (SC_LENGTH_REQUIRED)表示服务器不能处理请求（假设为带有附件的POST请求），除非客户端发送Content-Length头信息指出发送给服务器的数据的大小。该状态是新加入 HTTP 1.1的。412 (Precondition Failed/先决条件错误)412 (SC_PRECONDITION_FAILED)状态指出请求头信息中的某些先决条件是错误的。该状态是新加入 HTTP 1.1的。413 (Request Entity Too Large/请求实体过大)413 (SC_REQUEST_ENTITY_TOO_LARGE)告诉客户端现在所请求的文档比服务器现在想要处理的要大。如果服务器认为能够过一段时间处理，则会包含一个Retry-After的响应头信息。该状态是新加入 HTTP 1.1的。414 (Request URI Too Long/请求URI过长)414 (SC_REQUEST_URI_TOO_LONG)状态用于在URI过长的情况时。这里所指的“URI”是指URL中主机、域名及端口号之后的内容。例如：在URL–http://www.y2k-disaster.com:8080/we/look/silly/now/中URI是指/we/look/silly/now/。该状态是新加入 HTTP 1.1的。415 (Unsupported Media Type/不支持的媒体格式)415 (SC_UNSUPPORTED_MEDIA_TYPE)意味着请求所带的附件的格式类型服务器不知道如何处理。该状态是新加入 HTTP 1.1的。416 (Requested Range Not Satisfiable/请求范围无法满足)416表示客户端包含了一个服务器无法满足的Range头信息的请求。该状态是新加入 HTTP 1.1的。奇怪的是，在servlet 2.1版本API的HttpServletResponse中并没有相应的常量代表该状态。注意在servlet 2.1的规范中，类HttpServletResponse并没有SC_REQUESTED_RANGE_NOT_SATISFIABLE 这样的常量，所以你只能直接使用416。在servlet 2.2版本之后都包含了此常量。417 (Expectation Failed/期望失败)如果服务器得到一个带有100-continue值的Expect请求头信息，这是指客户端正在询问是否可以在后面的请求中发送附件。在这种情况下，服务器也会用该状态(417)告诉浏览器服务器不接收该附件或用100 (SC_CONTINUE)状态告诉客户端可以继续发送附件。该状态是新加入 HTTP 1.1的。500 (Internal Server Error/内部服务器错误)500 (SC_INTERNAL_SERVER_ERROR) 是常用的“服务器错误”状态。该状态经常由CGI程序引起也可能（但愿不会如此！）由无法正常运行的或返回头信息格式不正确的servlet引起。501 (Not Implemented/未实现)501 (SC_NOT_IMPLEMENTED)状态告诉客户端服务器不支持请求中要求的功能。例如，客户端执行了如PUT这样的服务器并不支持的命令。502 (Bad Gateway/错误的网关)502 (SC_BAD_GATEWAY)被用于充当代理或网关的服务器；该状态指出接收服务器接收到远端服务器的错误响应。503 (Service Unavailable/服务无法获得)状态码503 (SC_SERVICE_UNAVAILABLE)表示服务器由于在维护或已经超载而无法响应。例如，如果某些线程或数据库连接池已经没有空闲则servlet会返回这个头信息。服务器可提供一个Retry-After头信息告诉客户端什么时候可以在试一次。504 (Gateway Timeout/网关超时)该状态也用于充当代理或网关的服务器；它指出接收服务器没有从远端服务器得到及时的响应。该状态是新加入 HTTP 1.1的。505 (HTTP Version Not Supported/不支持的 HTTP 版本)505 (SC_HTTP_VERSION_NOT_SUPPORTED)状态码是说服务器并不支持在请求中所标明 HTTP 版本。该状态是新加入 HTTP 1.1的。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[内置对象源码角度理解]]></title>
      <url>%2F2016%2F09%2F01%2F85-%E4%BB%8E%E6%BA%90%E4%BB%A3%E7%A0%81%E8%A7%92%E5%BA%A6%E5%88%86%E6%9E%90%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%2F</url>
      <content type="text"><![CDATA[从源代码的角度理解内置对象(构造函数) 本地对象: Object Function Array String Boolean Number Date 这些是基本的类(引用类型)；使用这些引用类型的时候需要进行实例化；归根到底:这些只不过就是内置的构造函数而已，仅此而已 you can do , we all can do Math对象不需要new就可以直接使用，而其他对象的方法需要new才能调用它们的方法 所有的构造函数—-&gt;Function构造函数—–&gt;Object构造函数 function (小写) 用来声明函数 ; 就像用 var 声明 一个变量是一样的 Function 内置对象源代码 : Function是所有函数的构造函数，包括下面的内置对象12345678910Arguments.prototype.callee = 0;Arguments.prototype.caller = 0;Arguments.prototype = new Array();Arguments = &#123;&#125;;Function.prototype.arguments = 0;Function.prototype.arity = 0;Function.prototype.apply = function(thisArg,argArray) &#123;&#125;;//apply传入数值数组Function.prototype.call = function(thisArg,args) &#123;&#125;;//call传入数值，单个数值传入Function = &#123;&#125;;//声明Function是一个对象//ES5后有新增bind 所有的函数都是继承了Function的原型 Math内置对象源代码如下: Math对象本身就是一个对象，不需要声明就可以直接调用其方法,将Math作为对象，然后调用其方法就可以了123456789101112131415161718192021222324252627Math.E = 0;Math.LN10 = 0;Math.LN2 = 0;Math.LOG10E = 0;Math.LOG2E = 0;Math.PI = 0;Math.SQRT1_2 = 0;Math.SQRT2 = 0;Math.abs = function(x) &#123;&#125;;Math.acos = function(x) &#123;&#125;;Math.asin = function(x) &#123;&#125;;Math.atan = function(x) &#123;&#125;;Math.atan2 = function(x,y) &#123;&#125;;Math.ceil = function(x) &#123;&#125;;Math.cos = function(x) &#123;&#125;;Math.exp = function(x) &#123;&#125;;Math.floor = function(x) &#123;&#125;;Math.log = function(x) &#123;&#125;;Math.max = function(x) &#123;&#125;;Math.min = function(x) &#123;&#125;;Math.pow = function(x,y) &#123;&#125;;Math.random = function() &#123;&#125;;Math.round = function(x) &#123;&#125;;Math.sin = function(x) &#123;&#125;;Math.sqrt = function(x) &#123;&#125;;Math.tan = function(x) &#123;&#125;;Math = &#123;&#125;; //声明Math对象，以上所有的方法都是可以直接用的，无需newMath,因为Math在底层就不是构造函数 Array 内置对象(构造函数)源代码如下:1234567891011121314Array.isArray = function(obj) &#123;&#125;;//判断一个对象是不是数组，返回布尔类型function Array(args) &#123;&#125; //声明Array函数,所以需要new才可以调用Array的方法Array.prototype.concat = function(items) &#123;&#125;;Array.prototype.join = function(separator) &#123;&#125;;Array.prototype.push = function(items) &#123;&#125;;Array.prototype.slice = function(start,end) &#123;&#125;;Array.prototype.sort = function(compareFn) &#123;&#125;;Array.prototype.splice = function(start,deleteCount,items) &#123;&#125;;Array.prototype.unshift = function(items) &#123;&#125;;Array.prototype.valueOf = function() &#123;&#125;;Array.prototype.pop = function() &#123;&#125;;Array.prototype.shift = function() &#123;&#125;;Array.prototype.reverse = function() &#123;&#125;;//从源代码分析来看，可以得到哪些方法需要传入参数，哪些方法不需要传入参数 数组的定义 var arr = [ ]; var arr = new Array() ; var arr = new Array(size) ; 表示定义个数组长度为size ，length为size var arr = new Array(item1,item2,····)，表示定义了具体的一个数组，length为item的个数 1 arrObject.shift() : 改变原数组 删除数组的第一个 元素，返回所删除的元素； arrObject.pop( ) : 改变原数组 删除数组的最后一个 元素，返回所删除的元素; 注意如果要操作的数组为空，那么该方法不改变数组，注意返回值是undefined 不需要传参 2 arrObject.unshift( item1,item2,···· ) : 改变原数组 向原数组中头部添加一个或多个元素，返回添加后的数组的长度； arr.Object.push ( item1,,iten2,···· ) :改变原数组 向原数组中最后添加一个或多个元素，返回添加后数组的长度； 需要传一个参数，可以传入基本数据类型，也可以是复杂数据类型，比如向数组中添加一个对象3 arrObject.slice(start,end) :不改变原数组 ,返回一个新的数组,会重新开辟一块内存，存储返回的数组,start必须，表示从哪个位置(索引处)开始截取数组，end可选，如果没有设定，则表示从start开始到最后所有的元素，包括start索引出的元素，不包括end索引处的元素 4 arrObject.splice(index,howmany,item1,item2,····) 改变原数组，返回含有被删除元素的数组，会重新开辟一块内存，存储返回的数组 index表示开始删除元素的索引值，howmany表示要删除的元素的个数(可以为0 ，表示不删除元素，如果未规定这个数字，那么表示删除从index索引出开始到结束所有的元素)，itemx 表示要添加的元素 5 arrObject.sort( sortby) 改变原数组 如果不传参数，默认按照字符编码 顺序进行排序；如果传入一个函数，按照函数规定的规则排序； 5 arrObject.concat(arr1,arr2····) ，不改变原数组，返回一个新的数组，会重新开辟一块内存，存储返回的数组 可以添加元素，也可以添加数组； 6 arrObject.join(seperator) ，不改变原数组 该方法把数组中的所有元素中间加一个分隔符，组成一个字符串返回 7 arrObject.toString() ; 不改变原数组 返回值与没有参数的 join() 方法返回的字符串相同。其实就是应用了join方法； 8 arrObject.reverse() ; 改变原数组 返回颠倒后的数组的引用; 9 arrObject.forEach( funtion(item,index) { } ) ; 这个是遍历数组的新的方法，第一个参数是数组中的每一个元素，第二个参数index代表每个元素的索引；function函数里面的this指向是window; 4 既然数组在new之后是一个对象，var arr = new Array() 或者通过字面量声明一个数组 var arr = [1,2,3],那么数组就可以作为对象进行操作，然后给数组添加属性 12arr.name = "little arr";arr[len] = "three"; Object 内置对象(构造函数)源代码如下123456789101112131415161718192021222324Object.isExtensible = function(object) &#123;&#125;;Object.preventExtensions = function(obj) &#123;&#125;;Object.getOwnPropertyDescriptor = function(obj,prop) &#123;&#125;;Object.defineProperty = function(obj,prop,desc) &#123;&#125;;Object.defineProperties = function(obj,props) &#123;&#125;;Object.keys = function(obj) &#123;&#125;;Object.getOwnPropertyNames = function(obj) &#123;&#125;;Object.create = function(proto,props) &#123;&#125;;Object.getPrototypeOf = function(obj) &#123;&#125;;Object.seal = function(obj) &#123;&#125;;Object.isSealed = function(obj) &#123;&#125;;Object.freeze = function(obj) &#123;&#125;;Object.isFrozen = function(obj) &#123;&#125;;//以上方法不需要实例化对象即可通过Object对象直接调用Object.prototype.constructor = 0;Object.prototype.length = 0;Object.prototype.prototype = 0;function Object(value) &#123;&#125; //声明Object函数Object.prototype.toLocaleString = function() &#123;&#125;;Object.prototype.hasOwnProperty = function(propertyName) &#123;&#125;;Object.prototype.isPrototypeOf = function(o) &#123;&#125;;Object.prototype.propertyIsEnumerable = function(propertyName) &#123;&#125;;Object.prototype.toString = function() &#123;&#125;;Object.prototype.valueOf = function() &#123;&#125;; Date内置对象(构造函数)的源代码如下123456789101112131415161718192021222324252627282930313233343536373839404142434445Date.UTC = function(year,month,date,hours,minutes,seconds,milliseconds) &#123;&#125;;Date.parse = function(dateString) &#123;&#125;;//这两个方法不需要new Date 就可以使用function Date(args) &#123;&#125; //声明Date函数 以下方法必须new date对象才能用Date.prototype.getDate = function() &#123;&#125;;Date.prototype.getDay = function() &#123;&#125;;Date.prototype.getMonth = function() &#123;&#125;;Date.prototype.getFullYear = function() &#123;&#125;;Date.prototype.getHours = function() &#123;&#125;;Date.prototype.getMilliseconds = function() &#123;&#125;;Date.prototype.getMinutes = function() &#123;&#125;;Date.prototype.getSeconds = function() &#123;&#125;;Date.prototype.getTime = function() &#123;&#125;;Date.prototype.getTimezoneOffset = function() &#123;&#125;;Date.prototype.getUTCDate = function() &#123;&#125;;Date.prototype.getUTCDay = function() &#123;&#125;;Date.prototype.getUTCFullYear = function() &#123;&#125;;Date.prototype.getUTCHours = function() &#123;&#125;;Date.prototype.getUTCMilliseconds = function() &#123;&#125;;Date.prototype.getUTCMinutes = function() &#123;&#125;;Date.prototype.getUTCMonth = function() &#123;&#125;;Date.prototype.getUTCSeconds = function() &#123;&#125;;Date.prototype.getYear = function() &#123;&#125;;Date.prototype.setDate = function(date) &#123;&#125;;Date.prototype.setFullYear = function(year,month,day) &#123;&#125;;Date.prototype.setHours = function(hour,min,sec,ms) &#123;&#125;;Date.prototype.setMilliseconds = function(ms) &#123;&#125;;Date.prototype.setMinutes = function(min,sec,ms) &#123;&#125;;Date.prototype.setMonth = function(month,day) &#123;&#125;;Date.prototype.setSeconds = function(sec,ms) &#123;&#125;;Date.prototype.setTime = function(time) &#123;&#125;;Date.prototype.setUTCDate = function(date) &#123;&#125;;Date.prototype.setUTCFullYear = function(year,month,day) &#123;&#125;;Date.prototype.setUTCHours = function(hour,min,sec,ms) &#123;&#125;;Date.prototype.setUTCMilliseconds = function(ms) &#123;&#125;;Date.prototype.setUTCMinutes = function(min,sec,ms) &#123;&#125;;Date.prototype.setUTCMonth = function(month,day) &#123;&#125;;Date.prototype.setUTCSeconds = function(sec,ms) &#123;&#125;;Date.prototype.setYear = function(value) &#123;&#125;;Date.prototype.toDateString = function() &#123;&#125;;Date.prototype.toISOString = function() &#123;&#125;;Date.prototype.toLocaleDateString = function() &#123;&#125;;Date.prototype.toLocaleString = function() &#123;&#125;;Date.prototype.toLocaleTimeString = function() &#123;&#125;;Date.prototype.toTimeString = function() &#123;&#125;;Date.prototype.toUTCString = function() &#123;&#125;; RegExp正则对象123456789101112131415161718RegExp.leftContext = null;RegExp.input = null;RegExp.lastParen = null;RegExp.lastMatch = null;RegExp.rightContext = null;RegExp.$1 = null;RegExp.$2 = null;RegExp.$3 = null;RegExp.$4 = null;RegExp.$5 = null;RegExp.prototype.global = 0;RegExp.prototype.ignoreCase = 0;RegExp.prototype.lastIndex = 0;RegExp.prototype.multiline = 0;RegExp.prototype.source = null;function RegExp(pattern,options) &#123;&#125;RegExp.prototype.exec = function(String) &#123;&#125;;RegExp.prototype.test = function(String) &#123;&#125;; 创建正则对象的方法: 1234561 字面量 var patt1 = / pattern / attribute2 构造函数声明 var patt2 = new RegExp('pattern','attribute') var patt1 = /d\d/g; var patt2 = new RegExp('d\\d','g'); var patt3 = new RegExp('d\d','g');//注意区分patt2 和patt3 \ 是转义字符 正则对象的属性 1234567891011var patt1 = /d\d/g;console.log(patt1.source);//d\dconsole.log(patt1.global);//trueconsole.log(patt1.ignoreCase);//falseconsole.log(patt1.multiline );//fa;seconsole.log(patt1.lastIndex);//该属性存放一个整数，它声明的是上一次匹配文本之后的第一个字符的位置。//source :返回字符串形式 返回正则表达式匹配的原文本 pattern，该文本不包括正则表达式直接量使用的定界符，也不包括标志 g、i、m。//global ignoreCase multiline 返回true 或者false ,用来判断正则对象是否声明了 g i m//lastIndex:/*上次匹配的结果是由方法 RegExp.exec() 和 RegExp.test() 找到的，它们都以 lastIndex 属性所指的位置作为下次检索的起始点。这样，就可以通过反复调用这两个方法来遍历一个字符串中的所有匹配文本。该属性是可读可写的。只要目标字符串的下一次搜索开始，就可以对它进行设置。当方法 exec() 或 test() 再也找不到可以匹配的文本时，它们会自动把 lastIndex 属性重置为 0。*/ 正则对象的方法 12RegExpObject.test(str) 用来检测str字符串中是否有该正则对象，返回值是true或者false；RegExpObject.exec(str) 返回一个数组，其中存放匹配的结果。如果未找到匹配，则返回值为 null。 ###JS包装对象如下 Boolean 内置对象(构造函数)的源代码如下12function Boolean(value) &#123;&#125; //声明Boolean函数Boolean.prototype.valueOf = function() &#123;&#125;; Number内置对象(构造函数)的源代码如下1234567891011Number.MAX_VALUE = 0;Number.MIN_VALUE = 0;Number.NaN = 0;Number.NEGATIVE_INFINITY = 0;Number.POSITIVE_INFINITY = 0;//上面这几个Number方法不需要 new Number便可以直接使用function Number(value) &#123;&#125; //声明Number函数Number.prototype.toExponential = function(fractionalDigits) &#123;&#125;;Number.prototype.toFixed = function(fractionalDigits) &#123;&#125;;Number.prototype.toPrecision = function(precision) &#123;&#125;;Number.prototype.toString = function(radix) &#123;&#125;;Number.prototype.valueOf = function() &#123;&#125;; 1 numberObject.toString() 可以传入基数，表达将数字按照那个进制转化为字符串 2 numberObject.valueOf() 得到number对象的原始值； 3 numberObject.toFixed(n) 返回的是具有指定位数小数的数字的字符串表示 String 内置对象123456789101112131415161718192021222324252627282930313233String.fromCharCode = function(chars) &#123;&#125;;function String(value) &#123;&#125;String.prototype.anchor = function(nameAttribute) &#123;&#125;;String.prototype.big = function() &#123;&#125;;String.prototype.blink = function() &#123;&#125;;String.prototype.bold = function() &#123;&#125;;String.prototype.charAt = function(pos) &#123;&#125;;String.prototype.charCodeAt = function(index) &#123;&#125;;String.prototype.concat = function(strings) &#123;&#125;;String.prototype.fixed = function() &#123;&#125;;String.prototype.fontcolor = function(color) &#123;&#125;;String.prototype.fontsize = function(size) &#123;&#125;;String.prototype.indexOf = function(searchString,position) &#123;&#125;;String.prototype.italics = function() &#123;&#125;;String.prototype.lastIndexOf = function(searchString,position) &#123;&#125;;String.prototype.link = function(href) &#123;&#125;;String.prototype.localeCompare = function(that) &#123;&#125;;String.prototype.match = function(regexp) &#123;&#125;;String.prototype.replace = function(searchValue,replaceValue) &#123;&#125;;String.prototype.search = function(regexp) &#123;&#125;;String.prototype.slice = function(start,end) &#123;&#125;;String.prototype.small = function() &#123;&#125;;String.prototype.split = function(separator,limit) &#123;&#125;;String.prototype.strike = function() &#123;&#125;;String.prototype.sub = function() &#123;&#125;;String.prototype.substr = function(start,length) &#123;&#125;;String.prototype.substring = function(start,end) &#123;&#125;;String.prototype.sup = function() &#123;&#125;;String.prototype.toLowerCase = function() &#123;&#125;;String.prototype.toLocaleLowerCase = function() &#123;&#125;;String.prototype.toLocaleUpperCase = function() &#123;&#125;;String.prototype.toUpperCase = function() &#123;&#125;;String.prototype.valueOf = function() &#123;&#125;;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Function Review]]></title>
      <url>%2F2016%2F09%2F01%2F108-%E5%87%BD%E6%95%B0%E4%B8%93%E9%A2%98%20%20%E5%87%BD%E6%95%B0%E5%9F%9F%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%2F</url>
      <content type="text"><![CDATA[函数专题 函数域函数式编程1 函数声明:function fn(){ } 2 函数表达式：应用场景 var fn = function(){ } 123456789101112131415161718192021在构造函数中添加方法function Person(name) &#123; this.name = name; this.age = age; // 在构造函数内部中添加方法 this.getAge = function() &#123; return this.age; &#125;&#125;// 给原型添加方法Person.prototype.getName = function() &#123; return this.name;&#125;// 在对象中添加方法var a = &#123; m: 20, getM: function() &#123; return this.m; &#125;&#125; 3 匿名函数：应用场景，自执行以及作为参数传递 12345678910111213141516171819202122232425// 使用函数自执行的方式创建模块(function(window, undefined) &#123; // 声明jQuery构造函数 var jQuery = function(name) &#123; // 主动在构造函数中，返回一个jQuery实例 return new jQuery.fn.init(name); &#125; // 添加原型方法 jQuery.prototype = jQuery.fn = &#123; constructor: jQuery, //jQuery构造函数的prototype属性上有一个constructor属性，上面一行代码的操作会将prototype指向一个新的对象，所以需要加上这行代码，添加其constructor属性 init:function(name) &#123; ... &#125;,//实现选择器功能 css: function() &#123; ... return this&#125; //每次链式编程结束之后都返回实例化对象 &#125; jQuery.fn.init.prototype = jQuery.fn;//这行代码是jQuery实现链式编程的关键，返回的init构造函数的实例指向了函数jQuery的原型prototype，该原型上有jQuery上封装的API // 将jQuery改名为$，并将引用保存在window上，形成闭包，对外开发jQuery构造函数，这样我们就可以访问所有挂载在jQuery原型上的方法了 window.jQuery = window.$ = jQuery;//赋值运算，从右至左,返回等号右边的运算数 //window对象多了两个属性，一个是$ 一个是jQuery 都被赋值为jQuery函数，指向jQuer函数地址&#125;)(window);// 在使用时，我们直接执行了构造函数，因为在jQuery的构造函数中通过一些手段，返回的是jQuery的实例，所以我们就不用再每次用的时候在自己new了$('#div1');//$(name) 执行的时候,得到返回的 new jQuery.fn.init(name)对象 12345678910111213141516//函数自执行的方式 (function()&#123; console.log("func is excuted"); &#125;)(); (function()&#123; console.log("func is excuted"); &#125;()); ~function()&#123; console.log("func is excuted"); &#125;(); +function()&#123; console.log("func is excuted"); &#125;(); 4 函数的形参，传入的实参赋值给形参;形参作为变量名成为该函数作用域内的变量；如果实参个数小于形参个数，未被定义的将默认值为undefined 函数的参数是按值传递的，即会将传递的值复制一份到函数的局部变量中； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//----------------------------------------------------------------------------//先看一下这个栗子 var a = 10 ; var obj = &#123;name:"Jhon"&#125;; function fn(a,obj)&#123; a = a + 1 ; obj.name = "JiM"; console.log(a); &#125; fn(a,obj); console.log(a); console.log(obj.name);//-----------------------------------------------------------------------------//对比理解对象作为参数的传递 var person = &#123; name: 'Nicholas', age: 20 &#125; function setName(obj) &#123; // 传入一个引用 obj = &#123;&#125;; // 将传入的引用指向另外一个空的对象 obj.name = 'Greg'; // 给这个空的对象添加属性 &#125; setName(person);//类似于 obj = person ;然后回去执行函数，又将obj指向一个空的对象 console.log(person.name); // Nicholas 未被改变 //-------------------------------------------------------- var person = &#123; name: 'Nicholas', age: 20 &#125; function setName(obj) &#123; // 传入一个引用 obj.name = 'Greg'; // 修改引用的name属性 &#125; setName(person);//将obj指向person 类似于 obj = person; console.log(person.name); // Greg//对比以上两种情况，对于基本数据类型，是按值传递的，对于复杂数据类型，也是按值传递的，传递的是复杂数据类型对应的地址值；//---------------------------------------------------------------------- var c= 5; //----------------------函数的形参是局部变量 function fn(a,b)&#123; //a = 4 , b = 3 这两个是函数作用域内的变量 d = 6; //这个将会添加给全局作用域 console.log(a+b); &#125; fn(4,3);//----------------------------------------------------------------------------//传入的实参个数少于形参的个数，未被赋值的形参默认值为undefined function fn2 (a,b)&#123; console.log(a);//1 console.log(b);//undefined &#125; fn2(1);//----------------------------------------------------------------------------- 5 函数的调用方式: 作为函数体直接执行 作为构造函数调用 作为对象的方法调用 ; 这些都是函数的执行，函数内部的代码都会一行行的执行; 1234567function f1()&#123; console.log(this); var tmp = 1; this.x = 3; console.log(tmp); //A console.log(this.x); //B&#125; 5.1 函数直接执行 1console.log(f1());//undefined f1()函数执行后没有返回值，此时默认返回undefined 控制台输出 1234window13undefined 作为构造函数调用，此时内部的this指向new出来的对象 1 console.log(new f1()); 控制台输出 1234f1&#123;&#125; //这个其实就是new操作符创建的一个空的对象13f1&#123;x:3&#125; 6 函数简写 7 prototype属性和constructor属性 每个函数都自动拥有一个prototype属性，该属性是一个对象， 函数的prototype属性，包含一个不可枚举的属性constructor ；constructor属性指向该函数 类似形成了一个闭环 123456789101112function fn (a,b)&#123; fn.age = 19 ; console.log(a);//1 console.log(b);//undefined &#125; console.log(fn.prototype.constructor === fn);//truevar f = new fn(); console.dir(f);console.log(f.__proto__ === fn.prototype );//true console.log(f.__proto__.constructor == fn);//true 8 函数的name属性 123456789101112131415161718var func1 = function () &#123;&#125;; // ES5 func1.name // "" // ES6 func1.name // "func1" //上面代码中，变量func1等于一个匿名函数， ES5 和 ES6 的name属性返回的值不一样。 //如果将一个具名函数赋值给一个变量，则 ES5 和 ES6 的name属性都返回这个具名函数原本的名字。 const bar = function baz() &#123;&#125;; // ES5 bar.name // "baz" // ES6 bar.name // "baz" //Function构造函数返回的函数实例，name属性的值为 “anonymous” 。 (new Function).name // "anonymous" //bind返回的函数，name属性值会加上 “bound ” 前缀。 function foo() &#123;&#125;; foo.bind(&#123;&#125;).name // "bound foo" (function()&#123;&#125;).bind(&#123;&#125;).name // "bound "]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[图片居中的N中方式]]></title>
      <url>%2F2016%2F08%2F22%2F26-%E5%B1%85%E4%B8%AD%E7%9A%84N%E4%B8%AD%E6%96%B9%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[图片居中的N中方式：以下面的代码为例 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang="en"&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; div&#123; height: 200px; width: 300px; background-color: pink; margin: 100px auto; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt; &lt;img src="img/01.jpg" alt="" width="100px" height="100px"/&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 水平居中 第一种方法：给img的父盒子 设置 text-align:center,可以使文本或者图片水平居中 1234567div&#123; height: 200px; width: 300px; background-color: pink; margin: 100px auto; text-align:center &#125; 第二种方法:计算父盒子剩余宽度 给img添加margin 123img &#123; margin :0 100px ; (父盒子宽度-img宽度)/2 (300-100)/2&#125; 第三种方法: 由于margin: 0 auto 的居中只能给块级元素设置才有效果,所以将img转化为块级元素 1234img &#123; display :block ; margin :0 auto ;&#125; 第四种方法:给父盒子开启弹性布局,注意图片会被拉伸，因为默认开启弹性布局之后，align-self:strench 123456789div&#123; height: 200px; width: 300px; background-color: pink; margin: 100px auto; display: flex; justify-content: space-around; &#125; 第五种方法 :利用margin auto 的流体特性 123456789div&#123; position:relative;&#125;img&#123; position:absolute; left:0; right:0; margin:0 atuo ;&#125; 垂直居中 第一种方法：计算父盒子剩余高度给img添加margin 123img&#123; margin:50px 100px ;&#125; 第二种方法,给父盒子开启弹性布局，同时给img设置 align-self:center 123456789101112div&#123; height: 200px; width: 300px; background-color: pink; margin: 100px auto; display: flex; justify-content: space-around; &#125;img &#123; align-self:center&#125; 第三种方法 : 利用margin auto 的流体特性 123456789div&#123; position:relative;&#125;img&#123; position:absolute; top:0; bottom:0; margin:auto 0 ;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[jQuery中和DOM中 offset系列的不同]]></title>
      <url>%2F2016%2F08%2F17%2F17-%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1%E5%8F%82%E6%95%B0%E4%B8%AD%20offsetx%20clientx%20pagex%20screenx%EF%BC%9B%2F</url>
      <content type="text"><![CDATA[jQuery中和DOM中 offset系列的不同； 一 、jQuery中offset( ) 方法获取元素距离边界的值，该方法返回两个整形数值，一个代表left,一个代表top，其始终是获取的当前jquery对象相对于文档的边界的距离； 不写参数：jqueryObj.offset().left jqueryObj.offset().top 可以获取相应值 传入键值对参数：jQueryObj.offset({left:30,left:50});可以将匹配的元素设置距离边界的距离。 DOM中的offsetLeft offsetTop 获取元素距离边界值， 1)如果父元素有定位，那么DOM子元素是相对于父元素的border内边界的距离； 2)如果父元素没有定位，那么子元素是相对于文档边界的距离； 3)offsetLeft offsetTop 只能获取值，不能设置值，是一个只读属性； 二，事件对象参数的offsetX offsetY clientX clientY pageX pageY screenX screenY的区别 先总结下区别：(注意这些值都是整形的数值，代表事件源距离不同边界的以px计 的距离) event.clientX、event.clientY 鼠标相对于浏览器窗口可视区域的X，Y坐标（窗口坐标），可视区域不包括工具栏和滚动条。IE事件和标准事件都定义了这2个属性 event.pageX、event.pageY 类似于event.clientX、event.clientY，但它们使用的是文档坐标而非窗口坐标。这2个属性不是标准属性，但得到了广泛支持。IE事件中没有这2个属性。 event.offsetX、event.offsetY 鼠标相对于事件源元素（srcElement）的X,Y坐标，只有IE事件有这2个属性，标准事件没有对应的属性。 offsetX offsetY(偏移) 获取鼠标点击事件源相对于元素(content+padding)的左上角的坐标值,如果点击在border边界上的话，那么值为负数； event.screenX、event.screenY 鼠标相对于用户显示器屏幕左上角的X,Y坐标。标准事件和IE事件都定义了这2个属性]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[如何实现不同标签页之间的通信]]></title>
      <url>%2F2016%2F08%2F15%2F151%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%8D%E5%90%8C%E6%A0%87%E7%AD%BE%E9%A1%B5%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%2F</url>
      <content type="text"><![CDATA[1 通过cookie进行通信 cookie简单理解就是一种可以让服务器在客户端的硬盘或者内存里面存储少量数据,或者说从客户端硬盘读取数据的技术. 1.1 cookie可以是同域之间的不同标签页进行通信 假设在域名www.myvirtual1.com有以下文件 01 cookies.html 1234567&lt;script&gt; document.cookie = "name1=Jhon"; var d = new Date(); d.setDate(d.getDate()+5); var expires = d.toUTCString(); document.cookie = "name2=Jim;expires="+expires;&lt;/script&gt; 02 cookies.html 1234&lt;script&gt; console.log(document.cookie); //02cookies.html:9 name1=Jhon; name2=Jim; _ga=GA1.1.648196503.1489976857&lt;/script&gt; 1.2 不同域之间的标签页如何通过cookies进行通信呢？由于同源策略的影响，这个时候需要跨域来实现，这个时候需要设置cookie的domain属性 2 通过localStorage进行通信 假设在域名www.myvirtual1.com有以下文件 01localStorage.html 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang="en"&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;input type="button" value="set localStorage" id="btn"/&gt;&lt;script&gt; function sendMsg(text) &#123; window.localStorage.setItem('msg',text); &#125; document.getElementById("btn").onclick = function()&#123; sendMsg ('message1'); &#125;;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 02localStorage.html 1234567&lt;script&gt;//localstorage的增删改查的监听事件事件会监听 window.addEventListener('storage', function (evt) &#123; if(evt.key==='msg') console.log(evt.newValue); &#125;);&lt;/script&gt; storageEvent事件对象参数有以下常用属性 123key 属性用来表示storage存储的键值对属性的键oldValue 属性用来表示storage存储的原来的属性值newValue 属性用来表示storage存储的原来的属性值]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[js touch 事件对象参数]]></title>
      <url>%2F2016%2F08%2F13%2F28-%E7%A7%BB%E5%8A%A8%E7%AB%AF%20touch%E4%BA%8B%E4%BB%B6%E4%BB%A5%E5%8F%8A%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90%2F</url>
      <content type="text"><![CDATA[移动端 touch事件以及事件对象参数解析 一 :理解touch事件对象参数,其实就是事件对象参数新增了额外的几个参数，其中包括: TouchEvent : 12345678910111213141516171819- changedTouches 所有改变的触摸点的集合- targetTouches 目标元素上方的触摸点的- touches 改变的触摸点- 这三个对象里面的changdTouches:TouchList:[0]:Touch &#123;clientX:202.43899536132812 clientY:56.097999572753906 force:1 identifier:0 pageX:202.43899536132812 pageY:56.097999572753906 radiusX:14.02439022064209 radiusY:14.02439022064209 rotationAngle:0 screenX:348 screenY: &#125; 属性值都是一样的 每个事件对象参数可能包含以下两个属性[0] :包含触摸点的信息，length:包含触摸点的数量 二 : 触摸事件的绑定方法 走个demo看下效果,注意看控制台的输出：以下列出了一部分TouchEvent的参数 1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang="en"&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0"/&gt; &lt;style&gt; .box &#123; width: 200px; height: 200px; background-color: skyblue; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="box"&gt;&lt;/div&gt;&lt;script&gt; window.onload = function()&#123; var box = document.querySelector(".box"); box.addEventListener("touchstart",function(e)&#123; console.log("触发了touchstart"); console.log(e); console.log(e.changedTouches[0]); &#125;); box.addEventListener("touchmove",function(e)&#123;// console.log("触发了touchmove"); console.log(e); &#125;) box.addEventListener("touchend",function(e)&#123; console.log("触发了touchend"); console.log(e); &#125;) &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; TouchEvent altKey:false bubbles:true cancelBubble:false cancelable:true changedTouches:TouchList 0:Touch clientX:88 clientY:157 force:1 identifier:0 pageX:88 pageY:157 radiusX:15.333333015441895 radiusY:15.333333015441895 rotationAngle:0 screenX:258 screenY:275 target:div.box proto:Touch length:1 二 Touch事件:每一个Touch事件都对应一个TouchEvent, 只不过可能事件对象参数中的某些数值可能会不一样 touchstart touchmove(move过程持续触发) touchend touchstart touchmove 包含changedTouches targetTouches touches 这三个事件参数，且length不为0 但是 touchend 包含changedTouches 的length不为0 ，targetTouches touches的length为0]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HTML5 Application Cache]]></title>
      <url>%2F2016%2F08%2F13%2F134HTML5ApplicationCache%2F</url>
      <content type="text"></content>
    </entry>

    
    <entry>
      <title><![CDATA[cookie]]></title>
      <url>%2F2016%2F08%2F13%2F83-HTML%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8cookies%E7%AF%87%2F</url>
      <content type="text"><![CDATA[本地存储cookies篇 1 HTTP cookie，通常直接叫做cookie，是客户端用来存储数据的一种选项，它既可以在客户端设置也可以在服务器端设置。cookie会跟随任意HTTP请求一起发送。优点：兼容性好 缺点：一是增加了网络流量；二则是它的数据容量有限，最多只能存储4KB的数据，浏览器之间各有不同；三是不安全。 2.cookie的用途及工作原理那cookie具体能干什么呢？ cookie 将信息存储于用户硬盘，因此可以作为全局变量，这是它最大的一个优点。它最根本的用途是 Cookie 能够帮助 Web 站点 保存有关访问者的信息 ，以下列举cookie的几种小用途。 ① 保存用户登录信息。这应该是最常用的了。当您访问一个需要登录的界面，例如微博、百度及一些论坛，在登录过后一般都会有类似”下次自动登录”的选项，勾选过后下次就不需要重复验证。这种就可以通过cookie保存用户的id。 ② 创建购物车。购物网站通常把已选物品保存在cookie中，这样可以实现 不同页面 之间 数据的同步 (同一个域名下是可以共享cookie的)，同时在提交订单的时候又会把这些cookie传到后台。 ③ 跟踪用户行为。例如百度联盟会通过cookie记录用户的偏好信息，然后向用户推荐个性化推广信息，所以浏览其他网页的时候经常会发现旁边的小广告都是自己最近百度搜过的东西。这是可以禁用的，这也是cookie的缺点之一。 那么，cookie是怎么起作用的呢？ 在上一节中我们知道 cookie 是存在用户硬盘中，用户每次访问站点时，Web应用程序都可以读取 Cookie 包含的信息。当用户再次访问这个站点时，浏览器就会在本地硬盘上 查找 与该 URL 相关联的 Cookie 。如果该 Cookie 存在，浏览器就将它添加到 request header的Cookie字段中，与 http请求`一起发送到该站点。 在开发者工具network可以看到，如果有关该URL的cookie会被添加到请求上 要注意的是，添加到 request header 中是 浏览器的行为 ，存储在cookie的数据 每次 都会被浏览器 自动 放在http请求中。因此，如果这些数据不是每次都要发给服务器的话，这样做无疑会增加网络流量，这也是cookie的缺点之一。为了避免这点，我们必须考虑什么样的数据才应该放在cookie中，而不是滥用cookie。每次请求都需要携带的信息，最典型的就是 身份验证了，其他的大多信息都不适合放在cookie中。 cookie流程 用户在浏览器输入url,发送请求,服务器接受请求 服务器在响应报文中生成一个Set-Cookie报头,发给客户端 浏览器取出响应中Set-Cookie中内容,以cookie.txt形式保存在客户端 如果浏览器继续发送请求,浏览器会在硬盘中找到cookie文件,产生Cookie报头,与HTTP请求一起发送. 服务器接受含Cookie报头的请求,处理其中的cookie信息,找到对应资源给客户端. 浏览器每一次请求都会包含已有的cookie. 3 cookie属性name、value 是 cookie 的名和值。domian 、Path 、 Expires/max-age 、Size 、Http 、 Secure等均属cookie的属性。 domain 和 path 这两个选项共同决定了cookie能被哪些页面共享。 domain 参数是用来控制 cookie对「哪个域」有效，默认为设置 cookie的那个域。这个值可以包含子域，也可以不包含它。如上图的例子，Domain选项中，可以是”.google.com.hk&quot;(不包含子域,表示它对google.com.hk的所有子域都有效)，也可以是&quot;www.google.com.hk”(包含子域)。 path用来控制cookie发送的指定域的「路径」，默认为”/“，表示指定域下的所有路径都能访问。它是在域名的基础下，指定可以访问的路径。例如cookie设置为”domain=.google.com.hk; path=/webhp“，那么只有”.google.com.hk/webhp“及”/webhp“下的任一子目录如”/webhp/aaa“或”/webhp/bbb“会发送cookie信息，而”.google.com.hk“就不会发送，即使它们来自同一个域。 expries/max-age失效时间expries 和 max-age 是用来决定cookie的生命周期的，也就是cookie何时会被删除。 expries 表示的是失效时间，准确讲是「时刻」，max-age表示的是生效的「时间段」，以「秒」为单位。 若 max-age 为正值，则表示 cookie 会在 max-age 秒后失效。如例四中设置”max-age=10800;”，也就是生效时间是3个小时，那么 cookie 将在三小时后失效。 若 max-age 为负值，则cookie将在浏览器会话结束后失效，即 session，max-age的默认值为-1。若 max-age 为0，则表示删除cookie。 secure默认情况为空，不指定 secure 选项，即不论是 http 请求还是 https 请求，均会发送cookie。 是 cookie 的安全标志，是cookie中唯一的一个非键值对儿的部分。指定后，cookie只有在使用SSL连接（如HTTPS请求或其他安全协议请求的）时才会发送到服务器。 httponly（即http）httponly属性是用来限制客户端脚本对cookie的访问。将 cookie 设置成 httponly 可以减轻xss（跨站脚本攻击 Cross Site Scripting）攻击的危害， 防止cookie被窃取，以增强cookie的安全性。（由于cookie中可能存放身份验证信息，放在cookie中容易泄露） 默认情况是不指定 httponly，即可以通过 js 去访问。 ###4、如何利用以上属性去设置cookie？ 服务器端设置 服务器通过发送一个名为 Set-Cookie 的HTTP头来创建一个cookie，作为 Response Headers 的一部分。如下图所示，每个Set-Cookie 表示一个 cookie（如果有多个cookie,需写多个Set-Cookie），每个属性也是以名/值对的形式（除了secure），属性间以分号加空格隔开。格式如下： Set-Cookie: name=value[; expires=GMTDate][; domain=domain][; path=path][; secure] 只有cookie的名字和值是必需的。 客户端设置 客户端设置cookie的格式和Set-Cookie头中使用的格式一样。如下： document.cookie = “name=value[; expires=GMTDate][; domain=domain][; path=path][; secure]” 若想要添加多个cookie，只能重复执行 document.cookie（如上）。这可能和平时写的 js 不太一样，一般重复赋值是会覆盖的， 但对于cookie，重复执行 document.cookie 并「不覆盖」，而是「添加」（针对「不同名」的）。 5、cookie的缺点安全性：由于cookie在http中是明文传递的，其中包含的数据都可以被他人访问，可能会被篡改、盗用。 大小限制：cookie的大小限制在4kb左右，不适合大量存储。 增加流量：cookie每次请求都会被自动添加到Request Header中，无形中增加了流量。cookie信息越大，对服务器请求的时间越长]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[cookie设置 读取 删除操作]]></title>
      <url>%2F2016%2F08%2F10%2F153cookie%E8%AE%BE%E7%BD%AE-%E8%AF%BB%E5%8F%96-%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C%2F</url>
      <content type="text"><![CDATA[cookie设置，读取，删除12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;script&gt; function setCookie(name,value,expiresHours)&#123; var cookieString = name+'='+escape(value); if(expiresHours &gt; 0)&#123; var date = new Date(); date.setHours(date.getHours()+expiresHours); cookieString = cookieString + ";expires="+date.toUTCString(); &#125; //然后设置cookie document.cookie = cookieString ; &#125; setCookie('malename','Jhon',20); function getCookie(name)&#123; var strCookie = document.cookie ; var arrCookie = strCookie.split(';'); for(var i = 0 ; i &lt; arrCookie.length ; i++)&#123; var arr = arrCookie[i].split("="); if(arr[0] == name)&#123; return unescape(arr[1]); &#125;else&#123; return ""; &#125; &#125; &#125; console.log(getCookie('malename'));// document.cookie = 'malename = v;expire' //删除一个cookie function deleteCookie(name)&#123; var date = new Date(); date.setHours(date.getHours()-10); document.cookie = name+'=v'+';expires='+date.toUTCString(); &#125; function deleteCookie(name)&#123; var date=new Date(); date.setTime(date.getTime()-10000); //设定一个过去的时间即可 document.cookie=name+"=v; expires="+date.toGMTString(); &#125; function deleteCookie(name) &#123; var exp = new Date(); exp.setTime(exp.getTime() - 1); var cval=getCookie(name); if(cval!=null) document.cookie= name + "="+cval+";expires="+exp.toGMTString(); &#125; document.getElementById('btn').onclick = function()&#123; console.log("1"); deleteCookie('malename'); &#125;;&lt;/script&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[移动端高清多屏适配的解决方案]]></title>
      <url>%2F2016%2F08%2F10%2F156%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%AB%98%E6%B8%85%E5%A4%9A%E5%B1%8F%E9%80%82%E9%85%8D%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
      <content type="text"><![CDATA[1 平常开发，移动端场景： 开发移动端H5页面 面对不同分辨率的手机 面对不同屏幕尺寸的手机 2 视觉稿:对于移动端的开发而言，为了做到页面高清的效果，经常会对视觉稿有如下规范 首先选取一款手机屏幕作为基准(更多的是iphone6的375*667) 对于retina屏幕(比如dpr=2),为了达到高清的效果，视觉稿的大小会是基准的两倍，也就是说像素点的个数是原来的四倍(对于iphone6来说，375667 变成了 7501334) 3 引出两个问题 对于dpr = 2 的手机，胃泌素画布大小 x2 就可以解决高清问题？ 对于2倍大小的视觉稿，在具体的css编码中如何还原每一个区块 的真实宽高？ 4 由问题来看下基本的定义以及概念 物理像素 : (physical pixel)一个物理像素是显示器(手机屏幕)上最小的物理显示单元，在操作系统的调度下，每一个设备独立像素都有自己的颜色值和亮度值 设备独立像素 : (dp/dip density-independent pixel) 可以认为是计算机坐标系统中得一个点，这个点代表一个可以由程序使用并控制的虚拟像素(比如：CSS 像素,只是在android机中CSS 像素就不叫”CSS 像素”了而是叫”设备独立像素”)，然后由相关系统转换为物理像素。(跟设备的宽高一致) CSS像素：CSS像素是Web编程的概念，独立于设备的用于逻辑上衡量像素的单位，也就是说我们在做网页时用到的CSS像素单位，是抽象的，而不是实际存在的。 位图像素(png,jpg)是由像素（Pixel）组成的，像素是位图最小的信息单元，存储在图像栅格中。 每个像素都具有特定的位置和颜色值。按从左到右、从上到下的顺序来记录图像中每一个像素的信息，如：像素在屏幕上的位置、像素的颜色等。位图图像质量是由单位长度内像素的多少来决定的。单位长度内像素越多，分辨率越高，图像的效果越好。位图也称为“位图图像”“点阵图像”“数据图像”“数码图像” 矢量图是根据几何特性来绘制图形，是用线段和曲线描述图像，矢量可以是一个点或一条线，矢量图只能靠软件生成，矢量图文件占用内在空间较小，因为这种类型的图像文件包含独立的分离图像，可以自由无限制的重新组合； 位图和矢量图的区别 1 最大的区别，矢量图形与分辨率无关，可以将它缩放到任意大小和以任意分辨率在输出设备上打印出来，都不会影响清晰度，而位图是由一个一个像素点产生，当放大图像时，像素点也放大了，但每个像素点表示的颜色是单一的，所以在位图放大后就会出现咱们平时所见到的马赛克状。 2 位图表现的色彩比较丰富，可以表现出色彩丰富的图象，可逼真表现自然界各类实物；而矢量图形色彩不丰富，无法表现逼真的实物，矢量图常常用来表示标识、图标、Logo等简单直接的图像。 3 由于位图表现的色彩比较丰富，所以占用的空间会很大，颜色信息越多，占用空间越大，图像越清晰，占用空间越大；由于矢量图形表现的图像颜色比较单一，所以所占用的空间会很小。 4 经过软件矢量图可以很轻松的转化为位图，而位图要想转换为矢量图必须经过复杂而庞大的数据处理，而且生成的矢量图质量也会有很大的出入。 5 位图的文件类型很多，如.bmp、.pcx、.gif、.jpg、.tif、photoshop的.psd等； 矢量图形格式也很多，如AdobeIllustrator的.AI、.EPS和SVG、AutoCAD的.dwg和dxf、Corel DRAW的.cdr等。 设备像素比(device pixel ratio) 定义了物理像素和设备独立像素的对应关系 dpr = 物理像素/设备独立像素 (x 和 y方向上都是如此)，可以通过window.devicePixelRatio属性获取当前设备的dpr 比如iphone设备宽高 375x667,那么此时设备独立像素(css像素)就是375x667; 对于普通屏幕物理像素 375x667; 即一个css像素对应一个物理像素 对于retina屏幕(dpr=2)物理像素 750x1334;即一个css像素对应4个物理像素(x,y方向都进行了等比缩放) 5 对于图片高清显示的问题最完美的显示情况是一个位图像素对应一个物理像素，图片才能完美的显示 对于普通屏幕 ，200x300的位图在普通屏幕上显示是没有问题的 对于retina屏幕(dpr = 2)，200x300的位图在retina屏幕上显示的时候，位图像素的一个像素对应了4个物理像素(x,y方向都会进行缩放);所以会导致图片模糊，为什么会导致图片模糊呢？ 那么对于单个位图像素不能再进行分割，然后多余的物理像素会进行就近取色，所导致图片模糊 那么这个问题如何解决呢？ 根本实现，让一个位图像素对应一个物理像素 实现方法 1 提供400x600的位图 2 img标签的宽高设置为 200x300 如此一来，在retina屏幕下，位图像素的在img标签下，一个位图像素对应一个物理像素 但是问题又来了，如果 1 提供400x600的位图 2 img标签的宽高设置为 200x300 如此在普通屏幕下，这个时候，一个物理像素对应了四个位图像素，图片显示会模糊？同样，why? 这个时候一个物理像素点的取色同样对应了四个位图像素，所以它的取色只能经过一定的算法(显示的结果就是一张只有原图像素总数的四分之一，我们称这个过程是downsampling),肉眼看上去虽然图片没有特别模糊，但是会少了一些锐利度，或者图片有色差 6 以上对于retina屏幕下图片高清显示 如果图片大小400x600 1 img标签 width : 200 px ; height : 300 px 2 背景图片 width : 200 px ; height : 300 px backgroundground-image : url () ; background-size: 200px 300px (/contain) ###7 这样子也会带来一个新的问题:就是需要准备两套图片，但是还有一个解决方案就是我们只需要准备一套大图，然后需要一个图片服务器，用来处理小图，然后根据不同请求的URL进行下载不同图片]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Object.defineProperty(obj,prop,descriptor)]]></title>
      <url>%2F2016%2F08%2F09%2F116-Object%20%E6%96%B0%E5%A2%9EAPI%20%20%20Object.defineProperty(obj%2Cprop%2Cdescripter)%2F</url>
      <content type="text"><![CDATA[Object 新增API Object.defineProperty(obj,prop,descripter) 1 Object.defineProperty(obj,prop,descriptor) 接受三个参数，第一是要设置属性的对象，第二个是要设置的属性名，第三个是要设置的属性的相关信息descriptor对象，该对象有如下属性：value writable configurable enumerable get 和set；返回值是传递给defineProperty的对象，也就是obj，作为返回值 2 对于descriptor有如下可配置的信息：Both data and accessor descriptors are objects. They share the following required keys: configurable true if and only if the type of this property descriptor may be changed and if the property may be deleted from the corresponding object.Defaults to false. enumerable true if and only if this property shows up during enumeration of the properties on the corresponding object.Defaults to false. 第一种方式 : A data descriptor also has the following optional keys: value The value associated with the property. Can be any valid JavaScript value (number, object, function, etc).Defaults to undefined. writable true if and only if the value associated with the property may be changed with an assignment operator.Defaults to false. 12345678var obj=&#123;&#125;; Object.defineProperty(obj,"name",&#123; get:function()&#123; return 10; &#125; &#125;); obj.name=20; console.log(obj.name);//10 默认不可修改 writable false 第二种方式 An accessor descriptor also has the following optional keys: get A function which serves as a getter for the property, or undefined if there is no getter. The function return will be used as the value of property.Defaults to undefined. set A function which serves as a setter for the property, or undefined if there is no setter. The function will receive as only argument the new value being assigned to the property.Defaults to undefined. 3 先来看下默认值的影响123456789101112131415var obj = &#123;&#125;;Object.defineProperty(obj,"name",&#123; &#125;); //等价于如下:var obj = &#123;&#125;;Object.defineProperty(obj,"name",&#123; value : undefined, writable : false , configurable : false , enumerable : false&#125;); console.log(obj.name);//undefinedobj.name = "JiM";console.log(obj.name);//undefined 4 descriptor对象分为data descriptor 和 accessor descriptor，两者只能存在一个，两者共存会报错；1234567891011121314151617var obj= &#123;&#125;; Object.defineProperty(obj,"name",&#123; //------------------可在两者中存在 configurable:true, enumerable : false, //----------------------------data descriptor value:"Jhon", writable:true, //--------------------------accessor descriptor get : function()&#123; return "JiM"; &#125; set:function()&#123; &#125; //------data descriptor中的 value 或者 writable 任何一个不能和 accessor descriptor中的get set任何一个共同存在 descriptor对象中； &#125;); 5 descriptor对象的属性5.1 value 属性:用来设置obj对象的属性值，writable属性用来控制obj对象的属性值是否可以修改 12345678910var obj= &#123;&#125;; Object.defineProperty(obj,"name",&#123; configurable:true, enumerable : false, value:"Jhon", writable:false,//当设置为true的时候，obj的name属性可以被修改为 JiM333 ; &#125;); obj.name = 'JiM333'; console.log(obj.name);//Jhon 5.2 set 方法:用来设置属性的值obj.property = “value”的时候调用set方法，get方法用来获取属性的值 ，obj.property的时候调用get方法； 1234567891011121314151617var obj= &#123;&#125;; Object.defineProperty(obj,"name",&#123; configurable:true, enumerable : false, get : function()&#123; return " I always return this string, whatever you have assigned"; &#125;, set:function()&#123; obj.newName = "JiM2"; &#125; &#125;); obj.name = 'JiM333'; // 这个表达式相当于调用了descriptor的set方法 console.log(obj.name);// I always return this string, whatever you have assigned console.log(obj.newName); //JiM2 //obj.name 相当于调用descriptor的get方法 12345678910111213141516//接下来看一个最大调用栈溢出的问题 var obj= &#123;&#125;; Object.defineProperty(obj,"name",&#123; configurable:true, enumerable : false, get : function()&#123; return " I always return this string, whatever you have assigned"; &#125;, set:function()&#123; obj.name = "JiM2";//一直在重复的调用set函数，注意这个还是在给name属性赋值，而上一个案例是给一个newName属性赋值; &#125; &#125;); console.log(obj.name); obj.name = 'JiM333';//调用set函数； 5.3 configurable属性，用来设置descriptor对象的属性(value writable get set enumerable )是否可以修改;如果设置了false，那么这些属性都不可以修改，即使设置的值和原来一样；如果设置了true,那么就可以重新更改； The configurable attribute controls at the same time whether the property can be deleted from the object and whether its attributes (other than writable) can be changed. 12345678910111213141516171819202122232425262728var o = &#123;&#125;;Object.defineProperty(o, 'a', &#123; get: function() &#123; return 1; &#125;, configurable: false&#125;);Object.defineProperty(o, 'a', &#123; configurable: true&#125;); // throws a TypeErrorObject.defineProperty(o, 'a', &#123; enumerable: true&#125;); // throws a TypeErrorObject.defineProperty(o, 'a', &#123; set: function() &#123;&#125;&#125;); // throws a TypeError (set was undefined previously)Object.defineProperty(o, 'a', &#123; get: function() &#123; return 1; &#125;&#125;); // throws a TypeError// (even though the new get does exactly the same thing)Object.defineProperty(o, 'a', &#123; value: 12&#125;); // throws a TypeErrorObject.defineProperty(o, 'a', &#123; writable:true&#125;); // throws a TypeErrorconsole.log(o.a); // logs 1delete o.a; // Nothing happensconsole.log(o.a); // logs 1 5.4 enumerable 属性 The enumerable property attribute defines whether the property shows up in a for...in loop and Object.keys() or not. 12345678910111213141516171819202122232425var o = &#123;&#125;;Object.defineProperty(o, 'a', &#123; value: 1, enumerable: true&#125;);Object.defineProperty(o, 'b', &#123; value: 2, enumerable: false&#125;);Object.defineProperty(o, 'c', &#123; value: 3&#125;); // enumerable defaults to falseo.d = 4; // enumerable defaults to true // when creating a property by setting itfor (var i in o) &#123; console.log(i);&#125;// logs 'a' and 'd' (in undefined order)Object.keys(o); // ['a', 'd']o.propertyIsEnumerable('a'); // trueo.propertyIsEnumerable('b'); // falseo.propertyIsEnumerable('c'); // false 6 Object.defineProperties(obj ,prop) The **Object.defineProperties()** method defines new or modifies existing properties directly on an object, returning the object.1234567891011121314151617181920var obj = &#123;&#125;;Object.defineProperties(obj, &#123; 'property1': &#123; value: true, writable: true &#125;, 'property2': &#123; value: 'Hello', writable: false &#125; // etc. etc.&#125;);//注意prop的格式 &#123; 'property1' : &#123; &#125; 'property2' : &#123; &#125; 'property3' : &#123; &#125; //etc &#125; 7 Object.getOwnPropertyDescriptor(obj,’property’) ; 获取obj对象的指定属性的descriptor,返回时描述该属性的详细信息的对象；Object.getOwnPropertyDescriptors(obj); 获取obj对象的所有属性descriptor详细信息的对象，该对象包含了每个属性的descriptor对象；]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[js 事件对象参数]]></title>
      <url>%2F2016%2F08%2F02%2F45-js%E5%92%8CjQuey%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1%E5%8F%82%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9A%2F</url>
      <content type="text"><![CDATA[一 : js中事件参数的总结：1 所有的事件都有默认的事件对象参数，事件对象参数可以通过arguments属性查看,在不同浏览器中，事件对象参数支持不一样，谷歌和火狐支持事件对象参数 e ,而IE支持 window.event,针对不同浏览器需要兼容 1e = window.event ? window.event : e DragEvent TouchEvent 继承event和MouseEvent的事件对象参数属性值； 2 事件(Event) window事件 keyBoard事件 Form表单事件 123456789101112131415Event:bubbles:false 返回布尔值，指示该事件是否是冒泡事件，true代表是冒泡事件，false代表是捕获事件 cancelBubble:false 阻止事件冒泡，设置该属性值为true,可以阻止事件冒泡，默认falsecancelable:false cancelable 事件返回一个布尔值。如果用 preventDefault() 方法可以取消与事件关联的默认动作，则为 true，否则为 fasle。默认falsecomposed:false currentTarget: 即当前处理该事件的元素、文档或窗口。即事件绑定的元素defaultPrevented:falseeventPhase:2 eventPhase 属性返回事件传播的当前阶段。它的值是下面的三个常量之一，它们分别表示捕获阶段(1:事件通过捕获触发)、正常事件派发(2:直接点击事件绑定元素)和起泡阶段(3:事件通过冒泡触发)。 isTrusted:truepath:Array[1]returnValue:truesrcElement: 返回触发其他元素的绑定事件的 节点:即直接点击的节点target: 返回触发其他元素的绑定事件的 节点:即直接点击的节点timeStamp:type:"load" 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; #dv1 &#123; height: 300px; width: 300px; background-color: red; &#125; #dv2 &#123; height: 200px; width: 200px; background-color: blue; &#125; #dv3 &#123; height: 100px; width: 100px; background-color: green; &#125; #dv4 &#123; height: 50px; width: 50px; background-color: pink; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="dv1"&gt;1 &lt;div id="dv2"&gt;2 &lt;div id="dv3"&gt;3 &lt;div id="dv4"&gt;4&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;script src="common.js"&gt;&lt;/script&gt;&lt;script&gt;// e.target记录触发事件的目标 // my$("dv2").onclick = function(e)&#123; // console.log(e.target+"==="+window.event.srcElement+"=="+e.currentTarget); //这句代码里面的 // console.log(e.target.id+"==="+window.event.srcElement.id+"=="+e.currentTarget.id); // &#125;; my$("dv2").onclick = function(e)&#123; e = e || window.event; console.log(e.target+"====="+e.currentTarget); console.log(e.srcElement.id+"=="+e.target.id+"==="+"=="+e.currentTarget.id+"=="+e.bubbles+"=="+ e.eventPhase); &#125;;// 在 2 级 DOM 中，事件传播分为三个阶段：// 第一，捕获阶段。事件从 Document 对象沿着文档树向下传递给目标节点。如果目标的任何一个先辈专门注册了捕获事件句柄，那么在事件传播过程中运行这些句柄。// 第二个阶段发生在目标节点自身。直接注册砸目标上的适合的事件句柄将运行。这与 0 级事件模型提供的事件处理方法相似。// 第三，起泡阶段。在此阶段，事件将从目标元素向上传播回或起泡回 Document 对象的文档层次。 // target 事件属性可返回事件的目标节点（触发该事件的节点），如生成事件的元素、文档或窗口;// currentTarget currentTarget 事件属性返回其监听器触发事件的节点，即当前处理该事件的元素、文档或窗口。// 在捕获和起泡阶段，该属性是非常有用的，因为在这两阶段，它不同于 target 属性// srcElement.id + target.id +currentTarget.id + e.bubbles e.eventPhase// 如点击dv2 控制台输出：dv2 dv2 dv2 true 2 // 点击dv3 控制台输出 dv3 dv3 dv2 true 3 //点击dv4 控制台输出 dv4 dv4 dv2 true 3&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 3 鼠标事件(MouseEvent) 1234567891011121314151617181920212223242526272829303132333435363738394041altKey:falsebubbles:truebutton:0buttons:0cancelBubble:falsecancelable:trueclientX:230clientY:58composed:truectrlKey:falsecurrentTarget:nulldefaultPrevented:falsedetail:1eventPhase:0fromElement:nullisTrusted:truelayerX:230layerY:58metaKey:falsemovementX:0movementY:0offsetX:64offsetY:50pageX:230pageY:58path:Array[5]relatedTarget:nullreturnValue:truescreenX:371screenY:205shiftKey:falsesourceCapabilities:InputDeviceCapabilitiessrcElement:divtarget:divtimeStamp:141604.27000000002toElement:divtype:"click"view:Windowwhich:1x:230y:58 4 拖拽事件(DragEvent) 1234567dataTransfer:DataTransfer dropEffect:"none" effectAllowed:"uninitialized" files:FileList items:DataTransferItemList types:Array[0] __proto__:DataTransfer 5 触摸事件(TouchEvent) 123- changedTouches 所有改变的触摸点的集合- targetTouches 目标元素上方的触摸点的- touches 改变的触摸点 6 messageEvent 1234message 属性表示该message 的类型； data 属性为 window.postMessage 的第一个参数；origin 属性表示调用window.postMessage() 方法时调用页面的当前状态； source 属性记录调用 window.postMessage() 方法的窗口信息。 7 storageEvent 123key 属性用来表示storage存储的键值对属性的键oldValue 属性用来表示storage存储的原来的属性值newValue 属性用来表示storage存储的原来的属性值 二 : jQuery中事件参数,多了两个属性，e . originalEvent : 用于存放所有的事件对象参数值 ; e . data :12345originalEvent:EventoriginalEvent:MouseEventoriginalEvent:DragEventoriginalEvent:TouchEventdata : undefined (如果没有传值给这个参数，那么就是undefined) 对于drag事件和touch 事件的新增属性dataTransfer changedTouches targetTouches touches 存放在originalEvent属性里面. 三 : 标准Event方法1234preventDefault() : 该方法将通知 Web 浏览器不要执行与事件关联的默认动作（如果存在这样的动作）。例如，如果 type 属性是 "submit"，在事件传播的任意阶段可以调用任意的事件句柄，通过调用该方法，可以阻止提交表单。注意，如果 Event 对象的 cancelable 属性是 fasle，那么就没有默认动作，或者不能阻止默认动作。无论哪种情况，调用该方法都没有作用。stopPropagation() : 不再派发事件。终止事件在传播过程的捕获、目标处理或起泡阶段进一步传播。调用该方法后，该节点上处理该事件的处理程序将被调用，事件不再被分派到其他节点。该方法将停止事件的传播，阻止它被分派到其他 Document 节点。在事件传播的任何阶段都可以调用它。注意，虽然该方法不能阻止同一个 Document 节点上的其他事件句柄被调用，但是它可以阻止把事件分派到其他节点。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[window Object]]></title>
      <url>%2F2016%2F08%2F02%2F141windowObject%2F</url>
      <content type="text"><![CDATA[在应用有frameset或者iframe的页面时，parent是父窗口，top是最顶级父窗口（有的窗口中套了好几层frameset或者iframe），self是当前窗口， opener是用open方法打开当前窗口的那个窗口。 window.self 功能：是对当前窗口自身的引用。它和window属性是等价的。 语法：window.self 注：window、self、window.self是等价的。 window.top 功能：返回顶层窗口，即浏览器窗口。 语法：window.top 注：如果窗口本身就是顶层窗口，top属性返回的是对自身的引用。 window.parent 功能：返回父窗口。 语法：window.parent 注：如果窗口本身是顶层窗口，parent属性返回的是对自身的引用。 parent parent用于在iframe,frame中生成的子页面中访问父页面的对象。例如：A页面中有一个iframe或frame，那么iframe或frame中的页面就可以通过parent对象来引用A页面中的对象。这样就可以获取或返回值到A页面中。 在框架网页中，一般父窗口就是顶层窗口，但如果框架中还有框架，父窗口和顶层窗口就不一定相同了。 判断当前窗口是否在一个框架中： var b = window.top!=window.self; document.write( "当前窗口是否在一个框架中："+b ); 你应当将框架视为窗口中的不同区域，框架是浏览器窗口中特定的部分。一个浏览器窗口可以根据你的需要分成任意多的框架，一个单个的框架也可以分成其它多个框架，即所谓的嵌套框架]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[jQuery serialize]]></title>
      <url>%2F2016%2F07%2F22%2F74-jQuery%20%20%E5%AF%B9%E8%B1%A1serialize()%E6%96%B9%E6%B3%95%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[jQuery 对象$(“selector”).serialize()方法的使用1 表单元素:from 表单能够包含 input 元素，比如文本字段、复选框、单选框、提交按钮等等。表单还可以包含 menus、textarea、fieldset、legend 和 label 元素。表单用于向服务器传输数据。 input : type 类型 button checkbox file hidden image password radio reset submit text 。如果要表单元素的值包含到序列字符串中，元素必须使用 name 属性。默认text类型 textarea 必须属性 col row 该标签也有 name属性，也可以上传数据 2 select select 元素可创建单选或多选菜单。当提交表单时，浏览器会提交选定的项目，或者收集用逗号分隔的多个选项，将其合成一个单独的参数列表，并且在将 \ 表单数据提交给服务器时包括 name 属性。 属性 值 描述 DTD disabled disabled 规定禁用该下拉列表。 STF multiple multiple 规定可选择多个选项。 STF name name 规定下拉列表的名称。 STF size number 规定下拉列表中可见选项的数目。 STF option 元素必须位于select元素内部,不能单独的使用，没有name属性 属性 值 描述 DTD disabled disabled 规定此选项应在首次加载时被禁用。 STF label text 定义当使用 时所使用的标注。 STF selected selected 规定选项（在首次显示在列表中时）表现为选中状态。 STF value text 定义送往服务器的选项值。 STF 3 首先理解jQuery ajax - serialize() 方法注意：只会将”成功的控件“序列化为字符串 。如果不使用按钮来提交表单，则不对提交按钮的值序列化。如果要表单元素的值包含到序列字符串中，元素必须使用 name 属性。 什么是”成功的控件”？可以简单理解为 被选中的 表单元素 有name属性的表单元素；**注意name属性不能是js或者jQuery中的关键字，否则无法序列化 ；其实就是用户操作选中的那些控件内容会被序列化； 12345input type = text password hidden 可以直接被选中序列化为字符串 type = checkbox radio 只有当check="checked" 的时候才能被选中序列化为字符串 type = file button image 则不会被选中序列化为字符串input 元素有name 属性，发往服务器的是input元素的name属性值 和 input元素的 value 值select 元素有name 属性，发往服务器的数据是select的name属性值和 其子元素的option元素的 value值;注意不是option标签包裹的内容 &lt;option value="man"&gt;男&lt;/option&gt; 上传到服务器的是 man ; 1textarea 元素有name 属性，发往服务器的数据是textarea的name属性值和textarea元素的内容； 如果要表单元素的值包含到序列字符串中，元素必须使用 name 属性。否则无法序列化该元素的值；序列化的”键值对”是 对于input select 元素是 name 属性 的值 和 value 属性的值；如果value属性也有值，那么就提交value属性的值，如果没有value属性，或者value属性值为空字符串，则序列化的结果没有value值，如果value值是一个空的字符串，那么序列化的结果是一个 + 字符。 对于textarea 元素是textarea元素的 name属性值 和内容值 4 明白以上的内容，具体到serialize()的用法,是对所有选中的表单元素进行序列化；序列化表单值的作用是将表单中的值拼装成字符串形式的key-value键值对提交给后台服务器程序解析，来获取用户的输入值 定义:serialize()方法通过序列化表单值，创建标准的URL编码文本字符串 ，它的操作对象是代表表单元素集合的jQuery 对象.你可以选择一个或多个表单元素（比如input或文本框），或者 form 元素本身。序列化的值可在生成 AJAX 请求时用于 URL 查询字符串中，然后发送到服务器。 我们可以单独的获取某个表单元素的序列化的值，$(“input”).serialize(),序列化所有的input元素，\$(“input:password”).serialize(),序列化password ; \$(“form”).serialize() 序列化 form； 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;&lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;&lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt; &lt;script src="jquery-1.12.2.js"&gt;&lt;/script&gt; &lt;title&gt;serializeArray()与serialize()&lt;/title&gt; &lt;script type="text/javascript"&gt; function onClik()&#123; $("#results").html("serializeArray()与serialize()的区别如下："); var data1 = $("#form1").serializeArray(); //自动将form表单封装成json $("#results").append("&lt;br/&gt;&lt;b&gt;serializeArray:&lt;/b&gt;"); $.each(data1, function(i, field)&#123; $("#results").append(field.name+":"+field.value+" "); &#125;); $("#results").append("&lt;br/&gt;"); var data2 = $("#form1").serialize(); //自动将form表单封装成json $("#results").append("&lt;b&gt;serialize():&lt;/b&gt;"+data2); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;form id="form1" name="form1" method="post" action=""&gt; &lt;p&gt;进货人 : &lt;label for="name"&gt;&lt;/label&gt; &lt;input type="text" name="name" id="name" /&gt; &lt;!--没有value值，结果为空--&gt; &lt;/p&gt; &lt;p&gt;性别: &lt;label for="sex"&gt;&lt;/label&gt; &lt;select name="sex" size="1" id="sex"&gt; &lt;!--select有name属性，会序列化选中的option 。这里是第一个option--&gt; &lt;option value="man"&gt;男&lt;/option&gt; &lt;option value="女"&gt;女&lt;/option&gt; &lt;/select&gt; &lt;select name="sex" size="1" id="sex"&gt; &lt;!--select有name属性，会序列化选中的option 。这里是第二个option--&gt; &lt;option value="man"&gt;男&lt;/option&gt; &lt;option value="woman" selected="selected"&gt;女&lt;/option&gt; &lt;/select&gt; &lt;select&gt; &lt;!--select没有name属性，则不会被序列化--&gt; &lt;option value ="volvo"&gt;Volvo&lt;/option&gt; &lt;option value ="saab"&gt;Saab&lt;/option&gt; &lt;option value="opel"&gt;Opel&lt;/option&gt; &lt;option value="audi"&gt;Audi&lt;/option&gt; &lt;/select&gt; &lt;textarea name="txt" id="" cols="30" rows="10"&gt; 这是text &lt;!--注意这里面有空格，会被序列化为+--&gt; &lt;/textarea&gt; &lt;/p&gt; &lt;table width="708" border="1"&gt; &lt;tr&gt; &lt;td width="185"&gt;商品名&lt;/td&gt; &lt;td width="205"&gt;商品数量&lt;/td&gt; &lt;td width="296"&gt;商品价格&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;label for="pro_name"&gt;&lt;/label&gt; &lt;input type="text" name="pro_name" id="pro_name" /&gt;&lt;/td&gt; &lt;!--没有value值，结果是 pro_name= --&gt; &lt;td&gt;&lt;label for="pro_num"&gt;&lt;/label&gt; &lt;input type="text" name="pro_num" id="pro_num" /&gt;&lt;/td&gt; &lt;td&gt;&lt;label for="pro_price"&gt;&lt;/label&gt; &lt;input type="text" name="pro_price" id="pro_price" /&gt;&lt;/td&gt; &lt;input type="password" name="" value="123"/&gt;&lt;/td&gt; &lt;input type="hidden" name="hid" value="hid" /&gt;&lt;/td&gt; &lt;input type="file" name="fil" value="filess" /&gt;&lt;/td&gt; &lt;input type="checkbox" name="ck" value="ckk" checked="checked" /&gt;&lt;/td&gt;ck &lt;input type="checkbox" name="ck" value="ckk2" /&gt;&lt;/td&gt;ck2 &lt;input type="radio" name="ra" value="raa" checked="checked" /&gt;&lt;/td&gt;ra &lt;input type="radio" name="ra2" value="raa2" /&gt;&lt;/td&gt;ra2 &lt;!--没有被选中，不会序列化， --&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;input type="text" name="pro_name2" id="pro_name2" value=" " /&gt;&lt;/td&gt; &lt;!--注意此时的value属性值是一个 空格 序列化为 + --&gt; &lt;td&gt;&lt;input type="text" name="pro_num2" id="pro_num2" value=""/&gt;&lt;/td&gt; &lt;!--这个地方的value属性值是 空字符串 --&gt; &lt;td&gt;&lt;input type="text" name="pro_price2" id="pro_price2" /&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;p id="results"&gt;&lt;/p&gt; &lt;input type="button" name="submit" onclick="onClik();" value="提交"/&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;&lt;!--serializeArray()与serialize()的区别如下：--&gt;&lt;!--serializeArray:name: sex:man sex:woman txt: 这是text ck:ckk ra:raa pro_name: pro_num: pro_price: hid:hid pro_name2: pro_num2: pro_price2:--&gt;&lt;!--serialize():name=&amp;sex=man&amp;sex=woman&amp;txt=+++++++++++++%E8%BF%99%E6%98%AFtext%3C!&amp;#45;&amp;#45;%E6%B3%A8%E6%84%8F%E8%BF%99%E9%87%8C%E9%9D%A2%E6%9C%89%E7%A9%BA%E6%A0%BC%EF%BC%8C%E4%BC%9A%E8%A2%AB%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%BA%2B&amp;#45;&amp;#45;%3E%0D%0A++++++++&amp;ck=ckk&amp;ra=raa&amp;pro_name=&amp;pro_num=&amp;pro_price=&amp;hid=hid&amp;pro_name2=+&amp;pro_num2=&amp;pro_price2=--&gt; $.param()方法是serialize()方法的核心，用来对一个数组或对象按照key/value进行序列化。 12345678910111213141516171819202122232425262728293031323334353637param: function( a ) &#123; /// &lt;summary&gt; /// This method is internal. Use serialize() instead. /// &lt;/summary&gt; /// &lt;param name="a" type="Map"&gt;A map of key/value pairs to serialize into a string.&lt;/param&gt;' /// &lt;returns type="String" /&gt; /// &lt;private /&gt; var s = [ ]; function add( key, value )&#123; s[ s.length ] = encodeURIComponent(key) + '=' + encodeURIComponent(value); &#125;; // If an array was passed in, assume that it is an array // of form elements if ( jQuery.isArray(a) || a.jquery ) // Serialize the form elements jQuery.each( a, function()&#123; add( this.name, this.value ); &#125;); // Otherwise, assume that it's an object of key/value pairs else // Serialize the key/values for ( var j in a ) // If the value is an array then the key names need to be repeated if ( jQuery.isArray(a[j]) ) jQuery.each( a[j], function()&#123; add( j, this ); &#125;); else add( j, jQuery.isFunction(a[j]) ? a[j]() : a[j] ); // Return the resulting serialization return s.join("&amp;").replace(/%20/g, "+"); &#125; 5 如何 解决空字符串转化为 + 号 的问题？]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[offset scroll client]]></title>
      <url>%2F2016%2F07%2F21%2F27-js%20jQuery%20offset%20scroll%20client%2F</url>
      <content type="text"><![CDATA[一 js offset1 :如果父元素没有定位，那么offsetLeft offsetTop是元素自身border 边界左上角相对于body边界 的距离 2 :如果父元素有定位，那么offsetLeft offsetTop是元素自身border 边界左上角相对于父元素的border边界 3 offsetWidth offsetHeight 是一个只读属性，该属性的宽高包括 内容区+padding+border；返回它的屏幕尺寸； 通过ele.offsetWidth ele.offsetHeight可以获取元素的宽高 ; 包括padding值和border值 ele.offsetLeft 和 ele.offsetTop 指的是相对于文档或者定位父节点的左边距和上边距，是一个只读 属性 offset系列的属性值是数字类型，只可读，不能设置 4 所有的HTML元素都有offsetHeight offsetWidth属性，offsetTop offsetLeft 可以获取当前元素相对于 文档坐标系统的x y 坐标值; 对于很多元素，都是相对于文档坐标系统的值； 但是对于已经定位的元素的后代元素和一些其他 元素(表格元素)，这些属性返回的坐标是相对于祖先元素定位的的而非文档；offsetParent属性指定这些属性所相对的父元素，如果offsetParent为null,这些属性都是文档坐标； js scroll1 ele.scrollHeight ele.scrollWidth 用来获取元素的内容的宽高，包括padding,不包括 border(如果产生了滚动条，则不包括滚动条的宽度)，是一个只读 属性，包括内容区，内边距以及任何溢出的内容，当么有溢出的时候，等于clientHeight he clientWidth ，当有溢出的时候，大于它们； 2 ele.scrollTop ele.scorllLeft 用来获取元素自身(比如当元素内容宽高大于元素自身的时候，会产生scroll，经常用来获取body的卷曲距离)内容向上或者向左卷曲出去的距离，也就是元素的内容区相对于滚动条顶部的距离；是一个可读可写 的属性；可以设置滚动出去的距离； 3 如何获取页面的卷曲出去的距离，由于不同的浏览器支持不一样有的支持window.pageXoffset, window.pageYoffset(股和火狐都不支持) 有的支持(html)document.documentElement.scrollLeft ,document.documentElement.scrollTop(火狐)有的支持(body)document.body.scrollLeft, document.body.scrollTop(谷歌) 4 封装一个获取相对浏览器窗口偏移的兼容性代码： 123456789101112function scrollTop()&#123;return window.pageYoffset || document.documentElement.scrollTop || document.body.scrollTop || 0 ;&#125;fuction scrollLeft()&#123; return window.pageXoffset || document.documentElement.scrollLeft || document.body.scrollTop || 0 ; &#125;function getScroll() &#123; return&#123; left : window.pageXoffset || document.documentElement.scrollLeft || document.body.scrollTop || 0 ; return top : window.pageYoffset || document.documentElement.scrollTop || document.body.scrollTop || 0 ; &#125; ;&#125; 5 HTML元素并没有像window对象那样的scrollTop( ) 和scrollBy( ) 方法 ； js client1 ele.clientHeight ele.clientWidth 用来获取元素可视区域的宽高，是一个只读 属性；包括padding值，不包括border ，不包括滚动条，对于内联元素只是0 ； 2 ele.clientTop ele.clientLeft 用来获取元素的边框的宽度，以像素计；是一个只读 属性 3 如果元素设置了display:none ,不可见，那么无法获取宽高;结果为0； Submit offsetWidth offsetHeight 获取元素的元素的宽度包括 content+padding+border ,包括border ;scrollWidth scrollHeight clientWidth clientHeight 获取的元素的宽度仅仅包括content+padding,不包括border ； offsetTop offsetLeft 获取该元素的border外边界 距离已经定位了了父元素的border内边界 的距离，如果没有祖先元素都没有定位，则获取相对于body的边界的距离；scrollLeft scrollTop 获取元素相对于滚动条头部 的距离，clientLeft clientTop 获取元素的边框的宽度 以上所有的属性，只有scrollTop 和 scrollLeft 是一个可读可写的属性，其余仅仅可读 :语法 1ele.scrollTop = number ; ele.scrollLeft = number ; 1ele.scrollTop = 5 ;ele.scrollLeft = 10; 所有获取的结果是一个number类型的数字；设置值的时候也仅仅设置数字； 注意区分事件对象参数里面的 (都是只读属性) offsetX offsetY(偏移) 获取鼠标点击事件源相对于元素(content+padding)的左上角的坐标值,如果点击在border边界上的话，那么值为负数； clientX clientY 获取事件源相对于浏览器窗口的可视区域(不包括滚动条和工具栏)的左上角的坐标值 pageX pageY也是 screenX screenY 获取的是鼠标点击点相对于显示屏的屏幕的左上角的坐标值 滚动条是浏览器添加的，在内边距和边框之间添加了滚动条 二 jquery offset( )这是jquery中的一个方法1 如果不传参数，那么可以获取该元素的距离body边界的距离； 2 如果传了参数，那么可以设置该元素距离body的边界的距离， 3 注意，无论该元素的父元素是否定位 ，都是相对于body 边界的距离；这点和js不一样； jquery对象.offset( ) ; 该方法有两个整形返回值，一个代表left 一个代表top jquery对象.offset().left jquery对象.offset().top 可以获取left和top的值 jquery对象.offset( { left : 30 ,top : 20 } ) 可以设置该元素距离body边界的距离； jquery中如何获取元素的宽高1 height( )只可以获取内容高度，也就是原本设置的height高度值，或者由内容撑开的高度值 2 innerHeight( ) ,获取的高度包括 padding，不包括边框 3 outerHeight( ),获取的高度值包括 padding 和border ，不包括margin,outerHeight(false)，里面默认值是false，当设置为outerHeight(true)的时候，可以获取到margin的值； 3 width( ) innerWidth( ) outerWidth( )也是一样的道理 4 如果传入了数值参数，那么可以为元素设置宽高； jquery scroll1 $(“selector”).scrollTop( ) 、\$(“selector”).scrollLeft( ) 不传参数的时候，可以获取该对象 相对滚动条顶部和左侧的偏移 2 $(“selector”).scrollTop( number) 、 \$(“selector”).scrollLeft(number) 传入参数的话，则代表可以设置相对滚动条顶部和左侧的距离 三 所有的HTML元素都有scroll client offset这三组属性；scrollHeight scrollWidth scrollLeft scrollTop offsetHeight offsetWidth offsetLeft offsetTop offsetParent clientHeight clientWidth clientLeft clientTop]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HTML5 postMessage]]></title>
      <url>%2F2016%2F07%2F15%2F140HTML5postMessage%2F</url>
      <content type="text"><![CDATA[1 HTML5新的API允许跨域访问其他页面，postMessage ;语法如下 发送消息的窗口，通过postMessage API发送消息 12345targetWindow.postMessage(mes,targetOrigin)targetWindow 指目标窗口，也就是给哪个window发消息，是 window.frames 属性的成员或者由 window.open 方法创建的窗口 mes : 是要发送的信息targetOrigin : 是 限定 消息接受的域范围，如果不限定可以使用* 字符串参数，指明目标窗口的源，协议+主机+端口号[+URL]，URL会被忽略，所以可以不写，这个参数是为了安全考虑，postMessage()方法只会将message传递给指定窗口，当然如果愿意也可以建参数设置为"*"，这样可以传递给任意窗口，如果要指定和当前窗口同源的话设置为"/"。 接受消息的窗口，通过message事件为该窗口注册事件 12345window.addEventListener('message',function(e)&#123; console.log(e.data);//传递过来的消息 console.log(e.source);//发送消息的窗口对象 console.log(e.origin);//发送消息窗口的源（协议+主机+端口号）&#125;) 2 栗子分析 www.myvirtual1.com www.myvirtual2.com 是我的两个虚拟主机 假如在http://www.myvirtual1.com/post1.html 文件内容如下 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Post Message&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;iframe id="child" src="http://www.myvirtual2.com/post2.html"&gt;&lt;/iframe&gt;&lt;input type="button" id="btn" value="click to send message"/&gt;&lt;input type="text" id="send" placeholder='please input what you want to send anotherwindow'/&gt;&lt;script type="text/javascript"&gt;document.getElementById('btn').onclick = sendMessage();function sendMessage()&#123; var str = document.querySelector('#send').value; var frame = window.frames[0]; frame.postMessage(str,'http://www.myvirtual2.com'); console.log("message is sended");&#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; http://www.myvirtual2.com/post2.html 文件内容如下 12345678910111213141516171819202122232425262728&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt; &lt;style type="text/css"&gt; html,body&#123; height:100%; margin:0px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;input type="text" value="this will be changed when you click the button "/&gt;&lt;script type="text/javascript"&gt; function receiveMessage()&#123; window.addEventListener('message',function(e)&#123; //这个事件在当post1页面发送消息的时候才会触发 console.log(e.data);//传递过来的消息 console.log(e.source);//发送消息的窗口对象 console.log(e.origin);//发送消息窗口的源（协议+主机+端口号） document.querySelector('input').value = e.data; &#125;) &#125; window.onload = function()&#123; receiveMessage(); &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 3 跨域的时候，正常来说由于受同源策略的影响，不同域之间的页面不允许通信，postMessage方法可以跨域发送信息，然后在另外一个页面可以被处理。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[MINE类型对应表格]]></title>
      <url>%2F2016%2F07%2F11%2F75-MIME%E7%B1%BB%E5%9E%8B%E5%AF%B9%E5%BA%94%E8%A1%A8%E6%A0%BC%2F</url>
      <content type="text"><![CDATA[MIME类型对应表格按照文件扩展名排列的 Mime 类型列表 扩展名 类型/子类型 application/octet-stream 323 text/h323 acx application/internet-property-stream ai application/postscript aif audio/x-aiff aifc audio/x-aiff aiff audio/x-aiff asf video/x-ms-asf asr video/x-ms-asf asx video/x-ms-asf au audio/basic avi video/x-msvideo axs application/olescript bas text/plain bcpio application/x-bcpio bin application/octet-stream bmp image/bmp c text/plain cat application/vnd.ms-pkiseccat cdf application/x-cdf cer application/x-x509-ca-cert class application/octet-stream clp application/x-msclip cmx image/x-cmx cod image/cis-cod cpio application/x-cpio crd application/x-mscardfile crl application/pkix-crl crt application/x-x509-ca-cert csh application/x-csh css text/css dcr application/x-director der application/x-x509-ca-cert dir application/x-director dll application/x-msdownload dms application/octet-stream doc application/msword dot application/msword dvi application/x-dvi dxr application/x-director eps application/postscript etx text/x-setext evy application/envoy exe application/octet-stream fif application/fractals flr x-world/x-vrml gif image/gif gtar application/x-gtar gz application/x-gzip h text/plain hdf application/x-hdf hlp application/winhlp hqx application/mac-binhex40 hta application/hta htc text/x-component htm text/html html text/html htt text/webviewhtml ico image/x-icon ief image/ief iii application/x-iphone ins application/x-internet-signup isp application/x-internet-signup jfif image/pipeg jpe image/jpeg jpeg image/jpeg jpg image/jpeg js application/x-javascript latex application/x-latex lha application/octet-stream lsf video/x-la-asf lsx video/x-la-asf lzh application/octet-stream m13 application/x-msmediaview m14 application/x-msmediaview m3u audio/x-mpegurl man application/x-troff-man mdb application/x-msaccess me application/x-troff-me mht message/rfc822 mhtml message/rfc822 mid audio/mid mny application/x-msmoney mov video/quicktime movie video/x-sgi-movie mp2 video/mpeg mp3 audio/mpeg mpa video/mpeg mpe video/mpeg mpeg video/mpeg mpg video/mpeg mpp application/vnd.ms-project mpv2 video/mpeg ms application/x-troff-ms mvb application/x-msmediaview nws message/rfc822 oda application/oda p10 application/pkcs10 p12 application/x-pkcs12 p7b application/x-pkcs7-certificates p7c application/x-pkcs7-mime p7m application/x-pkcs7-mime p7r application/x-pkcs7-certreqresp p7s application/x-pkcs7-signature pbm image/x-portable-bitmap pdf application/pdf pfx application/x-pkcs12 pgm image/x-portable-graymap pko application/ynd.ms-pkipko pma application/x-perfmon pmc application/x-perfmon pml application/x-perfmon pmr application/x-perfmon pmw application/x-perfmon pnm image/x-portable-anymap pot, application/vnd.ms-powerpoint ppm image/x-portable-pixmap pps application/vnd.ms-powerpoint ppt application/vnd.ms-powerpoint prf application/pics-rules ps application/postscript pub application/x-mspublisher qt video/quicktime ra audio/x-pn-realaudio ram audio/x-pn-realaudio ras image/x-cmu-raster rgb image/x-rgb rmi audio/mid roff application/x-troff rtf application/rtf rtx text/richtext scd application/x-msschedule sct text/scriptlet setpay application/set-payment-initiation setreg application/set-registration-initiation sh application/x-sh shar application/x-shar sit application/x-stuffit snd audio/basic spc application/x-pkcs7-certificates spl application/futuresplash src application/x-wais-source sst application/vnd.ms-pkicertstore stl application/vnd.ms-pkistl stm text/html svg image/svg+xml sv4cpio application/x-sv4cpio sv4crc application/x-sv4crc swf application/x-shockwave-flash t application/x-troff tar application/x-tar tcl application/x-tcl tex application/x-tex texi application/x-texinfo texinfo application/x-texinfo tgz application/x-compressed tif image/tiff tiff image/tiff tr application/x-troff trm application/x-msterminal tsv text/tab-separated-values txt text/plain uls text/iuls ustar application/x-ustar vcf text/x-vcard vrml x-world/x-vrml wav audio/x-wav wcm application/vnd.ms-works wdb application/vnd.ms-works wks application/vnd.ms-works wmf application/x-msmetafile wps application/vnd.ms-works wri application/x-mswrite wrl x-world/x-vrml wrz x-world/x-vrml xaf x-world/x-vrml xbm image/x-xbitmap xla application/vnd.ms-excel xlc application/vnd.ms-excel xlm application/vnd.ms-excel xls application/vnd.ms-excel xlt application/vnd.ms-excel xlw application/vnd.ms-excel xof x-world/x-vrml xpm image/x-xpixmap xwd image/x-xwindowdump z application/x-compress zip application/zip]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[jQuery核心]]></title>
      <url>%2F2016%2F07%2F10%2F43-jQuery%E6%A0%B8%E5%BF%83%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2F</url>
      <content type="text"><![CDATA[jQuery核心 一 对象访问 1 each(callback)方法：定义 $(“selector”).each(callback),为每一个匹配到的元素作为上下文 执行callback函数； 首先这是一个循环，会给所有匹配到的DOM元素执行callback函数； 每次执行传递进来的callback函数的时候， 函数中的this关键字都指向不同的元素(注意this指的是DOM对象，而不是jquery对象，$(this)可以返回jquery对象) 每次执行函数的时候，都会给函数传递一个当前执行函数的元素在所有匹配到的元素集合中的所处位置作为参数(从0开始的整形) 如果callback中 return:false ,将停止循环；返回 true 将继续执行循环函数 2 get(index)方法，将匹配到的jquery对象作为DOM对象返回：定义 $(“selector”).get(index),可以返回第几个DOM元素 如果不传参数 $(“selector”).get(),那么将返回所有匹配到的DOM元素集合； 如果传递参数 $(“selector”).get(n)那么将返回匹配到的第n个DOM元素； 3 length属性和size()方法 $(“selector”).length ,\$(“selector”).size() 将返回匹配到的所DOM元素的个数； 4 context属性和selector属性 $(“selector”).context 返回DOM元素被选中的上下文 ，\$(“selector”).selector 返回选择器； 5 $(‘selector’).index() :如果不传参数，那么返回匹配元素在其同辈元素中的位置 二 核心函数 1 jQuery(“selector”,[context]) :选择器 在context中查找元素 ，不仅仅可以匹配到页面中的DOM元素，还可以匹配到script等，如下栗子 123&lt;script id="jq" src="jquery-1.12.2.js"&gt;&lt;/script&gt;&lt;script&gt; code here &lt;/script&gt;$("#jq"):获取唯一id的script (第一个) $("script") :获取页面中所有的script,此语境下可以获取两个;返回的同样是jQuery对象那个，然后也可以用jQuery的方法。 2 jQuery(html) :可以创建元素 $(“通过jquery动态创建元素“); 3 jQuery(function(){ }) :文档就绪执行函数 4 $(“button”).click(function () { $(“div”).each(function (index, domEle) { // domEle == this $(domEle).css(“backgroundColor”, “yellow”); if ($(this).is(“#stop”)) { $(“span”).text(“Stopped at div index #” + index); return false; } });}); 三 : each(callback) 函数的每次循环都会向函数传入一个index元素位置参数的理解: 12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang="en"&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; div&#123; border: 1px solid #000; height: 50px; width: 100px; margin: 0 auto; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;button&gt;Change colors&lt;/button&gt;&lt;span&gt;&lt;/span&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div id="stop"&gt;Stop here&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;script src="jquery-1.12.2.js"&gt;&lt;/script&gt;&lt;script&gt; $(function()&#123; $("button").click(function()&#123; $("div").each(function(index,DOM)&#123; console.log(arguments); console.log(index+DOM); &#125;) &#125;); &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; each(callback)中的回调函数中有两个参数，一个是 代表元素当前位置的整形数值，从0开始；一个是当前的DOM元素。(注意不是jQuery对象) 四 $ 或者 jQuery (注意不是jquery) 是顶级对象. 1console.log($) console.log(jQuery) 结果是一样的; 注意区分 $.each(obj,callbakc)需要传入两个参数，一个对象，一个函数;\$(“selector”).each(callback),只需要传入一个函数即可; callback函数中也会传入两个参数，第一个是当前元素的索引位置(从0开始计)，第二个是当前DOM元素。 123456789101112131415161718console.log($.each);//结果如下each: function( obj, callback ) &#123; var length, i = 0; if ( isArrayLike( obj ) ) &#123; length = obj.length; for ( ; i &lt; length; i++ ) &#123; if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) &#123; break; &#125; &#125; &#125; else &#123; for ( i in obj ) &#123; if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) &#123; break; &#125; &#125; &#125; 1234console.log($("selector").each) //结果如下each: function( callback ) &#123; return jQuery.each( this, callback );&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HTML5 拖拽]]></title>
      <url>%2F2016%2F07%2F08%2F14-HTML5%E7%9A%84%E5%85%A8%E5%B1%8FAPI%E6%8B%96%E6%8B%BDAPI%2F</url>
      <content type="text"><![CDATA[HTML5的高级ＡＰＩ 1,全屏API:DOM元素支持全屏，HTML5的标准写法是 ele.requestFullScreen( ), 即可使DOM元素全屏；但是由于该方法处于不够完善，所以需要写各个浏览器的兼容代码； 123456789101112if(this.webkitRequestFullScreen)&#123; this.webkitRequestFullScreen(); &#125;else if(this.mozRequestFullScreen)&#123; this.mozRequestFullScreen(); &#125;else if(this.requestFullScreen)&#123; this.requestFullScreen(); &#125;else if(this.msRequestFullscreen)&#123; // ie 比较恶心 // 去 微软的 开发中中心查询 MSDN // msRequestFullscreen this.msRequestFullscreen(); &#125; 2,拖拽API:拖拉事件(drag&amp;&amp;drop) 拖拉指的是，用户在某个对象上按下鼠标键不放，拖动它到另一个位置，然后释放鼠标键，将该对象放在那里。 拖拉的对象有好几种，包括Element节点、图片、链接、选中的文字等等。在HTML网页中，除了Element节点默认不可以拖拉，其他（图片、链接、选中的文字）都是可以直接拖拉的。为了让Element节点可拖拉，可以将该节点的draggable属性设为true。 draggable属性可用于任何Element节点，但是图片（img元素）和链接（a元素）不加这个属性，就可以拖拉。对于它们，用到这个属性的时候，往往是将其设为false，防止拖拉。 注意，一旦某个Element节点的draggable属性设为true，就无法再用鼠标选中该节点内部的文字或子节点了 首先来看有哪些拖放(drag和drop)的事件，如果要是元素可以拖拽， 首先要给该元素设置 draggable = true 属性，保证该元素可以被拖放.(img标签默认支持拖放，div默认不支持拖放) 拖拽元素的监听事件如下： ondrag 当拖动元素的时候运行脚本被拖动的元素在拖动过程中持续触发 ondragstart 当元素拖动操作开始时候运行脚本 ondragend 当拖动操作结束的时候运行脚本 目标元素的上的监听事件如下：在默认情况下，拖放的目标元素是不允许接受元素的，为了把元素拖放到其中，必须把默认处理给关掉 给目标元素设置 e.preventDefault() 阻止默认事件的发生；使得被拖放元素可以放入目标元素里面。 ondragover 当元素被拖动至有效拖放目标元素上方时持续执行脚本 ondragenter 当元素被拖动至有效拖动目标元素时执行脚本 ondragleave 当元素离开至有效拖放目标元素时运行脚本 ondrop 当被拖动元素正在被放下的时候运行脚本;注意，如果当前节点不允许drop，即使在该节点上方松开鼠标键，也不会触发该事件。如果用户按下Escape键，取消这个操作，也不会触发该事件。该事件的监听函数负责取出拖拉数据，并进行相关处理。注意：只有鼠标松开才算放下，鼠标松开的时候才会触发该事件 dragenter和dragover事件的监听函数，用来指定可以放下（drop）拖拉的数据。由于网页的大部分区域不适合作为drop的目标节点，所以这两个事件的默认设置为当前节点不允许drop。如果想要在目标节点上drop拖拉的数据，首先必须阻止这两个事件的默认行为，或者取消这两个事件。 注意如果想要使目标元素可以被放进来拖放的元素，因为默认地，无法将数据/元素放置到其他元素中。如果需要设置允许放置，我们必须阻止对元素的默认处理方式。此时需要对目标元素进行处理，调用dragover阻止默认事件 的方法： 123目标元素.ondragover = function(event)&#123; event.preventDefault() ;&#125; 3 代码演示 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091&lt;!DOCTYPE html&gt;&lt;html lang="zh-cn"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; html, body &#123; height: 100%; &#125; body &#123; margin: 0; display: flex; justify-content: space-around; align-items: center; &#125; div &#123; width: 400px; height: 400px; border: 1px solid #000; &#125; .left &#123; display: flex; flex-wrap: wrap; justify-content: space-around; align-items: center; &#125; div&gt;img &#123; width: 70px; height: 70px; margin: 10px; background-color: ; &#125; /* 使用css来修改 定义一个 高亮的颜色 */ .right.active &#123; background-color: lightblue; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="left"&gt; &lt;img src="imgs/lofter_1_noval_icon_ (1).jpg" alt=""&gt; &lt;img src="imgs/lofter_1_noval_icon_ (2).jpg" alt=""&gt; &lt;img src="imgs/lofter_1_noval_icon_ (3).jpg" alt=""&gt; &lt;/div&gt; &lt;div class="right"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&lt;script&gt; // .right 盒子 元素移入 颜色高亮 document.querySelector('.right').ondragenter = function () &#123; // this.style.background = 'lightgray'; this.classList.add('active'); // $(this).addClass('active'); &#125; // .right 移出 颜色还原 document.querySelector('.right').ondragleave = function () &#123; // 颜色 就是 直接设置透明 // this.style.background = 'transparent'; // this.style.background = 'rgba(0,0,0,0)'; this.classList.remove('active'); &#125; // 为了能够触发drop 必须设置如下代码,给目标元素设置阻止默认处理方式，允许元素可以被放置 document.querySelector('.right').ondragover = function (event) &#123; event.preventDefault(); &#125; // drop .right盒子绑定 // img 拖拽开始的 时候 保存为 全局变量 var imgs = document.querySelectorAll('.left&gt;img'); // 当前移动的 img var moveImg = undefined; // 循环绑定，给每个拖拽元素设置拖拽事件，每个元素被拖拽时触发该事件 for(var i=0;i&lt;imgs.length;i++)&#123; imgs[i].ondragstart = function()&#123; // 保存为全局变量 moveImg = this; // 打印是否保存 console.log(moveImg); &#125; &#125; document.querySelector('.right').ondrop = function () &#123;// moveImg.ondrop = function () &#123; console.log('进来了'); // 将 丢进来的 元素 设置为 子元素 // 获取丢进来的元素 在拖拽img的时候 将当前拖拽的img 存起来获取保存的img // 通过全局变量 moveImg 添加给自己 document.querySelector('.right').appendChild(moveImg); // 还原 自己的颜色 this.classList.remove('active') &#125;&lt;/script&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HTML5 文件读取API]]></title>
      <url>%2F2016%2F07%2F08%2F12HTMl5%20%20file%E7%9B%B8%E5%85%B3API%20%2F</url>
      <content type="text"><![CDATA[HTML5 文件读取 元素input=file的新增API fileAPI主要有5个: FileUpload:当用户选择或编辑一个文件名，file-upload 元素触发 onchange 事件句柄 FileList:可以看成一个对象，包含上传文件的相关信息，其中包括了File对象 File:可以看成是FileList的一个属性，它包含了文件的基本信息 FileReader:HTML5新增的API ,可以理解成一个封装好的函数，文件的读取都是由它完成的,如果需要使用需要new操作符创建一个读取对象； FileError:这个类可以自己生成，主要用来提示文件操作中的错误， DataTransfer,，Blob，。 首先，从源头来理解:看一下demo我们简单做一个工作中常用的头像上传的功能： html代码： 1234567&lt;body&gt;&lt;input type="file"/&gt;&lt;input type="button" value="上传头像"/&gt;&lt;div style="border: 1px solid #000 ;width:200px;height: 200px;"&gt; &lt;img src="" alt="" width="200px"/&gt;&lt;/div&gt;&lt;/body&gt; script代码:功能实现是点击input=button上传头像的按钮，可以将input=file里面的选择的文件上传； 123456789101112131415161718192021222324&lt;script&gt; document.querySelector("input[type=button]").onclick = function(e)&#123; var fileDom = document.querySelector("input[type=file]"); console.log(fileDom.files);//FileList console.log(fileDom.files[0]);//File// 获取文件 var file = fileDom.files[0];//File// 创建HTML5文件读取对象 var reader = new FileReader(); console.log(reader);// 从这个File对象可以获取name、size、lastModifiedDate和type等属性。//把这个File对象传给FileReader对象的读取方法，就能读取文件了。//// 调用文件读取对象的方法 reader.onload = function()&#123; console.log("读取完毕"); console.log(reader.result); document.querySelector("img").src = reader.result; &#125; // reader.readAsText(file); reader.readAsDataURL(file);//注意执行顺序，onload之后，会执行 reader.readAsDataURl(file),然后才进入函数体，无阻塞事件 &#125;&lt;/script&gt; 1 当我们没有先选择文件的时候，直接点击button按钮，此时控制台输出：因为没有选择文件上传，所以此时FileList的length为0 ； 12FileList &#123;length: 0&#125;//fileDom.filesFileReader &#123;readyState: 0, result: null, error: null, onloadstart: null, onprogress: null…&#125;// 2 如果我们选择一个文件上传之后，此时在点击button，此时控制台输出：(注意fileDom.files[0]中的0 代表什么，注意比较两种情况下FileList对象的属性，第一种没有上传文件的情况下，FileList对象只有一个属性值 length:0;而在第二种首先上传文件的情况下，FileList对象的属性为 0:File, length:1,console.log(fileDom.files[length])也能输出length属性对应的值) 123FileList &#123;0: File, length: 1&#125; //fileDom.filesFile &#123;name: "04_kiss.jpg", lastModified: 1486178231000, lastModifiedDate: Sat Feb 04 2017 11:17:11 GMT+0800 (中国标准时间), webkitRelativePath: "", size: 47689…&#125; //fileDom.files[0]FileReader &#123;readyState: 0, result: null, error: null, onloadstart: null, onprogress: null…&#125; 3 文件上传之后——FileList对象——FileList对象包含File对象——File对象里面又包含了以下API: 12345lastModified :文件修改lastModifiedDatename :文件名type :文件类型size :文件大小 4 FileReader 对象的相关API如下: 该对象的 方法将确定如何读取文件的方式，然后将读取到的文件存在其属性reader.result里面 123456789101112131415161718error: nullonabort: nullonerror: nullonload: nullonloadend: nullonloadstart: nullonprogress: nullreadyState: result:DONE: 2EMPTY: 0LOADING: 1abort: function abort() function readAsBinaryString: function readAsBinaryString(File Object) function readAsDataURL(File Object)function readAsText(File Object); 5 .FileError这个类可以自己生成，主要用来提示文件操作中的错误，以下基本为常量，可直接使用【类名.属性】 123456789101112ABORT_ERR: 3ENCODING_ERR: 5INVALID_MODIFICATION_ERR: 9INVALID_STATE_ERR: 7NOT_FOUND_ERR: 1NOT_READABLE_ERR: 4NO_MODIFICATION_ALLOWED_ERR: 6PATH_EXISTS_ERR: 12QUOTA_EXCEEDED_ERR: 10SECURITY_ERR: 2SYNTAX_ERR: 8TYPE_MISMATCH_ERR: 11]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HTML5 web存储]]></title>
      <url>%2F2016%2F07%2F01%2F13-HTML5%20web%E5%AD%98%E5%82%A8%EF%BC%9A%2F</url>
      <content type="text"><![CDATA[HTML5 web存储： 1 window.localStorage.setItem(key[string],data[string]); 可以将数据存储在用户端； 2 window.localStorage.getItem(key[string]);可以将setItem存储的数据取出来； 3 window.localStorage.clear(),会将客户端存储的数据全部清空； 4 window.localStorage.removeItem(key) ; 可以删除客户端指定的已经存储起来的数据； 1234567891011121314151617181920212223242526272829303132333435&lt;body&gt;&lt;h1&gt;请输入你的名字&lt;/h1&gt;姓名&lt;input type="text" value="1"/&gt;年龄&lt;input type="text" value="2"/&gt;&lt;input type="button" value="保存"/&gt;&lt;/body&gt;&lt;/html&gt;&lt;script&gt;// 用户第一次进来点击保存，将用户输入的内容保存在客户端// 获取点击保存按钮，将内容保存在客户端 document.querySelector("input[type=button]").onclick = function()&#123;// 获取输入的内容 var inputValue = document.querySelector("input[type=text]").value ; console.log(inputValue);// 如何创建一个HTMl5的WEB存储,将inoutValue 存储在userName中// window.localStorage.setItem(key[string],data[string]); window.localStorage.setItem('userName',inputValue); &#125;// 用户第二次进入的时候，页面加载完毕之后，将第一次输入的内容保存 window.onload = function()&#123; window.localStorage.clear() //可以将所有存储在客户端的数据清除; //window.localStorage.key(2); //将之前web存储的内容取出来// var userName = window.localStorage.getItem(key[string]) var userName = window.localStorage.getItem('userName'); console.log("取出来的userName值为"+userName); if(userName == undefined &amp;&amp; userName !== "")&#123; document.querySelector("h1").innerHTML = '请输入您的名字'; &#125;else&#123; // 将取出来的内容添加到欢迎行 document.querySelector("h1").innerHTML = userName +"欢迎您"; &#125; &#125;&lt;/script&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[操作属性节点]]></title>
      <url>%2F2016%2F06%2F22%2F07DOM%20juqery%E9%87%8C%E9%9D%A2%E6%93%8D%E4%BD%9C%E5%85%83%E7%B4%A0%E7%9A%84%E5%B1%9E%E6%80%A7%E8%8A%82%E7%82%B9%EF%BC%9Aele%2F</url>
      <content type="text"><![CDATA[1 DOM里面操作元素的属性节点：123456789101112ele.removeAttribute("属性名")，删除属性节点；ele.setAttribute("属性名"，"属性值") ，设置属性节点；ele.getAttribute("属性名")，获得属性节点的值；设置属性里面的style属性的值:ele.style.property = "value"，设置样式属性值；ele.property = "value"设置元素属性值；ele.className = "value" ，可以用来修改 类名；也可以用来获取类名HTML5中新增了classListAPI 可以操作类名ele.classList.remove("类名");可以用来移除类名 必须有参数ele.classList.add("类名") ;可以用来增加类名 必须有参数ele.classList.toggle("类名") ;判断该元素是否有此类名，有的话则加上，没有的话则删除；ele.classList.length ;可以返回该元素拥有的类名的的个数；ele.classList.contains("类名") ;返回布尔类型的值，如果包含该类名则返回true，不包含的话，则返回false； 2 jquery中操作元素的属性节点：12345678$("selector").css('property'),$("selector").css('property','value'),可以用来*获取*或者*设置*样式(style)属性里面的样式属性值；注意只能获取style样式属性里面的属性值；其底层运作就应用了getComputedStyle以及getPropertyValue方法。$("selector").attr("property"),$("selector").attr("property","value"),可以*获取*或者*设置*固有属性以及新增属性 ; 新增属性会在DOM树结构中显示。$("selector").removeAttr("property") 可以移除固有属性以及由attr设置的新增属性，会将属性直接从DOM树上移除;attr设置属性会在DOM树上显示;不能移除由prop设置的属性;$("selector").prop("property"),$("selector").prop("property","value")，可以*获取*和*设置*固有属性以及新增属性，但是新增属性不会再DOM树上显示$("selector").removeProp("property") 可以移除固有属性以及由prop设置的属性，但是仅仅是删除属性值值变为undefined;不能移除由attr设置的属性;$("selector").addClass("class1 class2") 为每一个匹配的元素添加类名，如果添加多个类，则需要用空格分开;$("selector").removeClass("class1 class2") 为每一匹配的元素删除类名，如果移除多个类名，则需要用空格分开$("selector").toggleClass("class") 为每一匹配的元素添加或者删除类名，存在则删除，不存在则移除; 3 “ . “操作符只能获取内嵌式的属性值，不能获取内联(style标签里面)式和外联式的属性;通过”.”也可以直接设置属性值，但是只能是固有属性的值，不能新增属性123ele.property 获取属性值(固有属性)ele.property = "value" 设置固有属性值，不能设置新增属性给元素,如果设置了新增属性，并不能在DOM树上显示；可以这么理解，DOM元素是一个对象，"."操作符可以为对象添加属性，无论是否是固有属性，都会为这个新增的属性开辟存储空间，只不过固有属性会在DOM树上显示，而新增属性不会再DOM树上显示，但是其设置的值还是存在的。 4 “.” 操作符 和 setAttribute(“property”,”value”)设置属性的区别 “.” 设置固有属性 ele.property = “value” ;可以使其在DOM元素中出现 ； “.” 设置新增属性 ele.property = “value” ;可以设置一个属性，但是并不会在DOM元素中出现 ； setAttribute 无论设置新增属性还是固有属性，都会在DOM元素中出现 ； 5 注意用什么方式设置属性，就要用什么方式获取属性，​ a 比如 “.” 操作符设置的属性无法用getAttribute(“property”)获取到;”.” 获取的未被设置的属性值是 undefined; ​ b 比如setAttribute(“property”,”value”)设置的属性值无法用 “.” 操作符来获取；获取未被设置的属性值是null; ​ c “.”操作符设置属性要通过”.”操作符获取；setAttribute设置的属性值只能通过getAttribute来获取； 6 所有的属性节点里面，最常用的就是style属性节点，如何操作style属性节点，要理清元素属性和元素样式属性的关系，元素属性包括样式属性；注意:元素的属性–&gt;包括style 属性，id属性 class属性 title属性等—&gt;style属性里面又包含了一些样式属性–&gt;字体，文本，文本装饰，布局，尺寸，定位，颜色，变换(transform)，过渡(transition)，背景，外补白，内补白等都是属性; a) JAVAScript( DOM ) 中操作☞ 获取 style的属性值: 12ele.style.getPropertyValue('property');//只能获取内嵌式 style 属性中的CSS属性window.getComputedStyle("ele","null").getPropertyValue("property");//可以获取包括style属性里面的CSS样式属性以及&lt;style&gt;&lt;/style&gt;标签里面的CSS样式属性，或者外联式的CSS样式属性； 获取元素内嵌式style属性的值: ele.style.property 等价于 ele.style.getPropertyValue(‘property’) 来获取style样式属性的属性值，注意获取的属性值结果是一个字符串类型 ； 只能获取内嵌式style 的属性值 ； 如果是内联式或者外联式的属性值则获取不到，返回的结果是一个空字符串 总结来说就是， 只能获取内嵌式style的样式属性值，返回该属性的字符串值； 如果获取的属性内嵌式style里面没有该属性，那么返回空字符串； 这两种获取style样式属性总会返回一个字符串的结果，要么有值，要么是一个空字符串； 获取元素内联style标签里面或者外联式的元素的style样式某个属性值 : 1234ele.currentStyle['property'] //在旧的IE支持该方法window.getComputedStyle("元素":"伪类").property window.getComputedStyle("元素"，"伪类)"[property]window.getComputedStyle("元素"，"伪类").getPropertyValue("直接属性名"); window.getComputedStyle(“元素”，”伪类)可以获取该元素的所有的最终 使用的CSS属性值 ele.style 也是可以获取该元素的所有的最终使用的CSS属性 二者区别是 第一: window.getComputedStyle(“ele”,”伪类”)是一个只读的属性，而ele.style 是一个可读可写的属性；第二:getComputedStyle方法获取的是最终应用在元素上的所有CSS属性对象（即使没有CSS代码，也会把默认的祖宗八代都显示出来）；而element.style只能获取元素style属性中(注意：内嵌式)的CSS样式。因此对于一个光秃秃的元素`，getComputedStyle方法返回对象中length属性值（如果有）就是190+(据我测试FF:192, IE9:195, Chrome:253, 不同环境结果可能有差异), 而element.style就是0`。 12&lt;div style='width: 100px ;background-color: #000000 ;margin: 0 auto;'&gt;&lt;/div&gt; 的ele.style.length = 6 ,分别是width background-color 和4个margin值&lt;div style='width: 100px ;background-color: #000000 ;'&gt;&lt;/div&gt; 而这个div的ele.style.length = 2 ,分别是width 和 background-color; 封装兼容低版本的获取元素属性值的代码:注意一点就是获取的结果是一个字符串类型的属性值，比如18px red等字符串 123function getComputedStyle(ele,attr)&#123; return window.getComputedStyle ? window.getComputedStyle(ele,null)[attr] : ele.currentStyle(attr)&#125; b) JAVAScript(DOM)中操作☞ 设置 style的属性值: 设置style属性的值 ele.style.property = “value” 等价于 ele.style.setProperty(‘property’,’value’)来设置元素的style样式属性值 7 对于不是元素的样式属性，比如offsetWidth offsetHeight clientWidth clientHeight scrollWidth scrollHeight 等，不能通过获取样式属性的方法获取这些值。 js中 123ele.offsetWidth(包括border) ele.scrollWidth ele.clientWidth(包括padding)ele.offsetHeight(包括border) ele.scrollHeight ele.clientWidth(包括padding)ele.offsetLeft ele.offsetTop ele.scrollLeft ele.scrollTop ele.clientLeft ele.clientTop jquery中 123456$("selector").width() $("selector").innerWidth()[包括padding] $("selector").outerWidth()[包括border,设置为诶true时，包括margin];返回值是一个整形数值类型;如果里面设置数值,可以设置被选中元素的宽度$("selector").height() $("selector").innerHeight()[包括padding] $("selector").outerHeight()[包括border，设置为true时，包括margin];返回值是一个整形数值类型;如果里面设置数值,可以设置被选中元素的高度$("selector").offset() 返回当前元素相对视口的**偏移** ;返回值包括两个整形数值的属性，一个代表left一个代表top,始终是相对于视口的距离$("selector").position() 返回当前元素相对于父元素的**偏移**;返回包括两个整形数值的属性;$("selector").scrollLeft()返回值是相对于滚动条左部的距离$("selector").scrollTop() 返回的是相对于滚动条顶部的距离 ###8 代码解释:(嗯，乱一点点，不好意思)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang="en"&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; div&#123; height: 150px; padding: 10px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;input type="button" id='btn1' value='1' style="width: 20px;height: 20px;background-color: #003C78;"/&gt;&lt;input type="button" id='btn2' value='2' style="width: 20px;height: 20px;background-color: #003C78;"/&gt;&lt;div style='width: 100px ;background-color: #000000 ;'&gt;&lt;/div&gt;&lt;script&gt; console.log('先讲解如何获取内嵌style样式属性值'); document.querySelector('#btn1').onclick = function()&#123; var dv = document.querySelector('div');// "."操作符的情况 dv.style.width = "200px";//可以通过"."操作设置元素的style属性值 console.log(dv.style.width);// 200px 可以获取内嵌式style样式属性值 console.log(dv.style.padding);//不可以获取外联式style样式属性值，只能获取到一个空字符串 console.log(typeof dv.style.height);//string// 通过style的方法API dv.style.setProperty ("height","200px");//可以通过setProperty设置style 属性的值 console.log(dv.style.getPropertyValue('height'));//200px 可以获取内嵌样式的属性值 console.log(dv.style.getPropertyValue('width'));//200px 可以获取内嵌样式的属性值 console.log(dv.style.getPropertyValue('padding'));//空字符串，不能获取外联style样式表里面的属性值 console.log(typeof dv.style.getPropertyValue('padding'));//string// 两者一样，// 1 都是可以获取内嵌的style的属性值，如果获取内联式或者外联式的样式属性值，则获取不到，获取结果为一个空的字符串// 2 同时可以设置style的样式属性值； &#125; console.log('以下讲解如何获取内联或者外联的style样式属性值'); document.querySelector("#btn2").onclick = function()&#123; var dv = document.querySelector("div");// console.log(dv.currentStyle['height']);// console.log(dv.currentStyle['width']); console.log(window.getComputedStyle(dv,null)['width']);//100px console.log(window.getComputedStyle(dv,null).width);//100px console.log(window.getComputedStyle(dv,null)['height']);//150px console.log(window.getComputedStyle(dv,null).height);//150px console.log(window.getComputedStyle(dv,null));//获取当前元素的所有的最终使用的CSS属性值，包括内嵌，内联，外联 console.log(dv.style);//建议读者看下控制台的输出结果，代表style属性里面的样式属性值(内嵌) &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[javascriptClosure]]></title>
      <url>%2F2016%2F06%2F19%2F96-Javascript%20%20%E9%97%AD%E5%8C%85(closure)%2F</url>
      <content type="text"><![CDATA[Javascript 闭包(closure)理解闭包之前，以下概念必须清楚 基础数据类型与引用数据类型 内存空间 垃圾回收机制 执行上下文 变量对象与活动对象 1 为什么需要闭包？ 我们从变量的作用域来进行考究原因 javascript中变量作用域分为两种，一种是全局作用域，一种是函数作用域(ES6中新增块级作用域) 1.1 函数内部可以访问函数外部的变量，即可以直接读取全局变量 1234var num = 200;function getNum ()&#123; console.log(num);// 输出 200 &#125; 1.2 函数外部却无法直接访问函数内部用var声明的函数内部变量 1234function getNum()&#123; var num = 200 ;&#125;console.log(num);//Uncaught ReferenceError: num is not defined 2.既然有需求，那么就要解决？什么是闭包？ 闭包，官方对闭包的解释是：一个拥有许多变量和绑定了这些变量的环境的表达式（通常是一个函数），因而这些变量也是该表达式的一部分。 啰里啰嗦，抽离靶向的，何必相互为难， 闭包就是一个函数； OK了， 再进一步，这个函数可以用来获取另外一个函数内部的变量 2.1闭包的特点： 2.1.1 作为一个函数变量的一个引用，当函数返回时，其处于激活状态。 2.1.2 一个闭包就是当一个函数返回时，一个没有释放资源的栈区。简单的说，Javascript允许使用内部函数—即函数定义和函数表达式 位于另一个函数的函数体内。而且，这些内部函数可以访问它们所在的外部函数中声明的所有局部变量 、参数 和声明的其他内部函数 。当其中一个这样的内部函数在包含它们的外部函数之外被调用时，就会形成闭包。 2.1.3 闭包的作用 : 一个是可以读取函数内部的变量;(局部变量) ,另一个就是让这些变量的值始终保持在内存中 。 2.1.3 闭包形成的条件: 在一个函数内部有一个新的函数 这个新的函数访问了外部函数内的变量 2.2 闭包栗子 2.2.1 如下一段代码，getInnerNum 可以访问 getNum 函数内部所有的变量，参数，以及函数的值，getInnerNum被getNum函数包住了 1234567 function getNum()&#123; var num = 200 ; function getInnerNum()&#123; console.log(num); &#125; &#125;//getInnerNum();直接引用是错误的，getInnerNum是在函数体内声明的，可以理解为是局部变量，外部不能直接调用函数内的嵌套函数 2.2.2 那么如果我们想要getNum内部的变量，该如何访问呢？既然getInnerNum可以访问num变量，不如将这个函数作为返回值 12345678910function getNum()&#123; var num = 200 ; function getInnerNum()&#123; console.log(num); &#125; return getInnerNum;//注意返回的是一个引用地址，改地址存放了函数getInnerNum &#125; // console.log(getNum());//可以判断出getNum 函数执行后返回的是getInnerNum 的函数体 getNum()(); //200 注意区分下面这段代码 123456789var num = 300; function getNum()&#123; var num = 200 ; function getInnerNum()&#123; console.log(this.num);//this在执行的时候指向谁？函数的执行上下文 &#125; return getInnerNum;//注意返回的是一个引用地址，改地址存放了函数getInnerNum &#125; getNum()();// 300 2.2.3 明确垃圾回收机制，函数体执行后，函数内部声明的变量 ，在函数调用完毕之后，被垃圾回收机制(garbage collection) 回收; 如果 situation 1 : 闭包的作用 一个是可以读取函数内部的变量;(局部变量) ,另一个就是让这些变量的值始终保持在内存中 12345678910111213141516 function getNum()&#123; var num = 200 ; addNum = function()&#123; console.log("addNum is completed"); num++; &#125; function getInnerNum()&#123; console.log(num); &#125; return getInnerNum;//注意返回的是一个引用地址，改地址存放了函数getInnerNum &#125; getNum()();//200 addNum();//addNum is completed getNum()();//200//getNum()每次执行都会重新声明 var num = 200 ;所以输出 200;//对于垃圾回收机制，函数执行过程中，为函数内部声明的变量分配栈或者堆内存，在函数执行结束之后，释放占据的内存 12345 getNum()();//200//进行了以下动作getNum() //声明num addNum函数(全局) getInnerNum函数(局部)//得到返回的getInnerNum 函数，然后运行该函数getInnerNum(); situation 2 :闭包的作用 一个是可以读取函数内部的变量;(局部变量) ,另一个就是让这些变量的值始终保持在内存中 1234567891011121314151617 function getNum()&#123; var num = 200 ; addNum = function()&#123; console.log("addNum is completed"); num++; &#125; function getInnerNum()&#123; console.log(num); &#125; return getInnerNum;//注意返回的是一个引用地址，改地址存放了函数getInnerNum &#125; var result = getNum() result();//200 addNum();//addNum is completed result();//201//getNum() 只执行了一次，所以 var num = 200 也只声明了一次//因为将内部的函数getInnerNum 赋值给了全局变量result,所以外部函数getNum并不算执行完毕，所以函数内部声明的变量在栈或者堆内存中不会被垃圾回收机制回收 此时，我们将getNum()的返回值getInnerNum函数给到变量result，result被执行了两次，第一次输出了 200 第二次输出201；这是为什么呢？ 原因就在于 getNum 是 getInnerNum 的父函数，而 getInnerNum 被赋给了一个全局变量result，这导致 getInnerNum 始终在内存中，而 getInnerNum 的存在依赖于 getNum ，因此 getNum 也始终在内存中，不会在调用结束后，被垃圾回收机制（garbage collection）回收。 因为result引用了getInnerNum.而 getInnerNum又是依赖于getNum，所以result间接引用了外部函数，所以getNum会一直在内存中存在，不会被垃圾回收机制回收；那么其所形成的作用域链也会一直存在； 同时，函数在执行的过程中动态为函数内部变量分配的内存也会一直存在； 1result = null ; 我们需要了解垃圾回收机制 对于局部变量，只在函数执行的时候存在，函数运行完毕，局部变量 就会被垃圾回收机制回收； 对于全局变量，垃圾回收机制则很难判断什么时候可回收 局部变量只在函数的执行过程中存在，函数执行过程中 会为局部变量在栈或堆 上分配相应的空间，以存储它们的值，然后再函数中使用这些变量，直至函数结束 但是在闭包中，由于内部函数getInnerNum 被赋值给了全局变量result,所以getNum函数并不算结束，所以垃圾回收机制不会将变量回收，所以函数中的变量 n 是一直存在于内存中的，并没有被回收 函数的执行上下文，在执行完毕之后，生命周期结束，那么该函数的执行上下文就会失去引用。其占用的内存空间很快就会被垃圾回收器释放。可是闭包的存在，会阻止这一过程。 这段代码中另一个值得注意的地方，就是 1234addNum = function()&#123; console.log("addNum is completed"); num++; &#125; 这一行，首先在addNum前面没有使用var关键字，因此addNum是一个全局变量，而不是局部变量。其次，addNum的值是一个匿名函数（anonymous function），而这个匿名函数本身也是一个闭包，所以addNum相当于是一个setter，可以在函数外部对函数内部的局部变量进行操作。 situation3 : 看下立即执行函数如何利用闭包 123456789101112131415(function getNum()&#123; var num = 200 ; addNum = function()&#123; console.log("addNum is completed"); num++; &#125; function getInnerNum()&#123; console.log(num); &#125; window.result = getInnerNum ;//注意这行代码，将内部引用赋值给全局变量result，所以该作用域链会一直存在;jQuery底层源码也是这种实现形式&#125;)() //立即执行函数result();//200addNum();//addNum is completedresult();//201 situation 4 数组中的元素引用，形成闭包 12345678910111213141516var arr = []; for(var i = 0 ; i &lt; 3 ; i++)&#123; arr[i] = outFunc(i); //innerFunc被数组中的每一个元素引用，每次循环都会形成一个闭包，每次传进去的 i 都会作为变量对象 function outFunc(num)&#123; function innerFunc()&#123; console.log(num); &#125; return innerFunc ; &#125; &#125; arr[0](); arr[1](); arr[2](); situation5 setTimeout(fn,time) 定时器函数的执行：按道理来说，既然fn被作为参数传入了setTimeout中，那么fn将会被保存在setTimeout变量对象中，setTimeout执行完毕之后，它的变量对象也就不存在了。可是事实上并不是这样。它仍然是存在的。这正是因为闭包。 很显然，这是在函数的内部实现中，setTimeout通过特殊的方式，保留了fn的引用，让setTimeout的变量对象，并没有在其执行完毕后被垃圾收集器回收。因此setTimeout执行结束后经过time时间后，会自动执行fn函数。 12345678 for(var i = 0 ; i &lt; 5 ; i++)&#123; setTimeout( function fn() &#123; console.log(i); &#125;, i*1000 ) &#125;//由于javascript执行代码单线程，遇到setTimeout会将setTimeout放到事件队列当中//这个循环创建了5个setTimeout函数，将执行函数fn添加到事件队列中//作用域链 全局作用域--&gt;setTimeout作用域(也是全局作用域，因为setTimeout内部的this指向的是window) 如何输出1,2,3,4,5呢？ 1234567891011121314151617 for(var i = 0 ;i &lt; 5 ;i++)&#123; function res (num)&#123; var timer = setTimeout(function fn()&#123; console.log(num) &#125;,i*1000); &#125; res(i) &#125;//因为res函数执行的时候，创建了res函数作用域，传入的num作为res当前执行上下文中的变量对象中的一员，fn函数执行的时候,会先在fn作用域内找num ,找不到则往上一层一层找；//作用域链如下:全局作用域---&gt;res函数作用域---&gt;setTimeout---&gt; fn函数作用域(fn在setTimeout内部实现了闭包，所以fn执行的时候，可以获取到当前作用域链上的变量)//---------------------------------------------//这两种方法都是可以的，推荐第二种立即执行; for (var i=1; i&lt;=5; i++) &#123; (function (i) &#123;setTimeout( function fn() &#123; console.log(i); &#125;, i*1000 )&#125;)(i); &#125; 123456789101112 var num = 999; for(var i = 0 ;i &lt; 5 ;i++)&#123; (function(num)&#123; setTimeout(function fn()&#123; console.log(this); console.log(this.num); var num = 5; console.log(num) &#125;,i*1000); &#125;)(i) &#125;//通过这个案例的验证，可以发现setTimeout内部实现了闭包，fn执行的时候上下文不会被垃圾回收机制回收; 3 如何避免闭包？ 闭包的作用:一个是可以读取函数内部的变量;(局部变量) ,另一个就是让这些变量的值始终保持在内存中 第一个作用使我们想要的，但是第二个会使闭包一直占据内存，这个是我们应该尽力去避免的；由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。 4 看下面这行代码的输出: this改变了函数执行的上下文 12345678910111213141516171819202122 var num = 300; function getNum()&#123; var num = 200 ; addNum = function()&#123; console.log("addNum is completed---"+num); num++; console.log("addNum is completed---"+num); &#125; function getInnerNum()&#123; console.log(this.num);//函数执行的时候，this指向其运行的时候所在的对象 &#125; return getInnerNum;//注意返回的是一个引用地址，改地址存放了函数getInnerNum &#125; var result = getNum() result(); addNum(); result();//控制台输出 300 addNum is completed---200 addNum is completed---201 300 5 此时回过头来理解下文章开始的一些基础的定义，以及重新回忆下链式作用域，变量的取值(就近原则)，全局作用域，局部作用域 完结vvv]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HTML5 dataset]]></title>
      <url>%2F2016%2F06%2F15%2F22-HTML5%20data%20%E5%B1%9E%E6%80%A7%E7%9A%84%E8%BF%90%E7%94%A8%EF%BC%9A%2F</url>
      <content type="text"><![CDATA[属性操作 DOM jQuery 中对比解析： DOM中操作元素属性的方法： 1 直接在元素内声明： 1&lt;div id=&quot;dv&quot; class=&quot;cls&quot; abc = &quot;hello&quot;&gt;&lt;/div&gt; 声明之后可以对元素的属性进行操作 123console.log(document.getElementById("dv").getAttribute("class"));console.log(document.getElementById("dv").getAttribute("abc"));console.log(document.getElementById("dv").abc); 输出结果：cls hello undefined ( . 操作符只能操作HTML元素固有的属性，这些个”莫须有”的无法操作) 2 通过setAttribute(“属性名”,”属性值”)，可以为元素设置固有属性值或者新的属性 通过 ele.property = “value”,可以为元素设置属性值 123456789101112document.getElementById("dv").setAttribute("index","9");document.getElementById("dv").aaaa = "hello again"; //不起作用document.getElementById("dv").style.height = "200px";document.getElementById("dv").title = "我是通过固有属性设置的";上面这行代码执行完毕之后：&lt;div id="dv" class="cls" abc = "hello" index="9" style="height:200px;" title = "我是通过固有属性设置的"&gt;&lt;/div&gt;然后在执行下这段代码的话：console.log(document.getElementById("dv").index);console.log(document.getElementById("dv").title);输出结果：undefined 我是通过固有属性设置的 注意细节 ： “ . “ 运算符 可以直接设置固有属性 比如 class title lang href src 等某些元素特有的一些属性，以及样式属性 style; 但是 “. “ 运算符不能直接设置新增的属性 ，比如 index aaa 等新增的，原来并不存在的属性，obj.index 不会报错，但是不会起作用，如果用”[ ]”运算符，obj[index] 会直接报错，[ ] 运算符不能操作不存在的属性， 总结： 1 “ . ”运算符只能 设置 元素的固有属性和 以及 获取 元素的固有属性值，不能给元素设置新增属性以及获取元素的新增属性值； 2 setAttribute(“property”,”value”),getAttribute(“property”),其中property属性名既可以是固有的属性，也可以是新增属性，可以设置元素的属性值或者获取元素的属性值。 3 jquery中操作元素属性的方法： prop(“property”,”value”),可以设置jquery对象的固有属性，注意仅仅是固有属性，也就是说W3C里面本来就有的属性，prop(“property”)，可以获取jquery对象属性值； attr(“property”,”value”),可以设置jquery对象的固有属性，也就是说W3C里面本来就有的属性，也可以新增一些W3C没有规定的属性，比如index aaa 等等符合命名规则的新增属性；attr(“property”)，可以获取jquery对象属性值，包括固有属性以及新增属性。 4 HTML全局属性(固有属性) 属性 描述 accesskey 规定激活元素的快捷键。 class 规定元素的一个或多个类名（引用样式表中的类）。 contenteditable 规定元素内容是否可编辑。 contextmenu 规定元素的上下文菜单。上下文菜单在用户点击元素时显示。 data-* 用于存储页面或应用程序的私有定制数据。 dir 规定元素中内容的文本方向。 draggable 规定元素是否可拖动。 dropzone 规定在拖动被拖动数据时是否进行复制、移动或链接。 hidden 规定元素仍未或不再相关。 id 规定元素的唯一 id。 lang 规定元素内容的语言。 spellcheck 规定是否对元素进行拼写和语法检查。 style 规定元素的行内 CSS 样式。 tabindex 规定元素的 tab 键次序。 title 规定有关元素的额外信息。 translate 规定是否应该翻译元素内容。 5 HTML5 新增API dataset 5.1.1 js中 原生js方法对dataset属性的修改会直接在DOM树上表现出来； 先来看下原来的获取和设置属性的方式是否可以起作用 setAttribute getAttribute . 操作符； 12345678910111213141516171819202122232425262728293031323334353637 &lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang="en"&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; [data-color] &#123; background-color: red; &#125; [data-width]&#123; width: 100px; &#125; [data-height]&#123; height: 100px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;input type="button" value="按钮"/&gt;&lt;div id="dv" class="box" aaa="nothing" data-color="red" data-position="pos" data-address="china" data-width="w" data-height="h" data-name-first="kobe" data-nameLast = "james"&gt;&lt;/div&gt;&lt;script&gt; window.onload = function()&#123; document.querySelector("input[type=button]").onclick = function()&#123; var box = document.querySelector("#dv"); console.log(box.className);//box console.log(box.id);//dv console.log(box.aaa);//undefined . 操作符只能操作html元素固有的属性// console.log(box.data-position);//报错 ，无法操作 console.log(box.getAttribute("data-position"));//pos box.setAttribute("data-position","poschange");//设置data* 的属性值 console.log(box.getAttribute("data-position"));//poschange &#125;; &#125;;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 既然原来的方法可以操作data* 属性，那么 dataset这个新的API还有什么作用呢？好的，如果我想获取所有的属性值，那么该怎么操作呢？这个时候，dataset的威力就显示出来了 5.1.2 dataset是HTML5新增的一个API ,里面存放了所有的使用 data-xx 格式设置的属性集合，是一个对象;我们仅仅改变script标签里面的代码，html代码不变； 12345678910111213141516171819&lt;script&gt; window.onload = function()&#123; document.querySelector("input[type=button]").onclick = function()&#123; var box = document.querySelector("#dv"); console.log(box.dataset);//可以获取所有的data-xx 属性值，实际工作中便于解析成字符串 //DOMStringMap &#123;color: "red", position: "pos", address: "china", width: "w", height: "h",nameFirst:"kobe"namelast:"james"&#125; console.log(typeof box.dataset);//object console.log(box.dataset.color);//red console.log(box.dataset.position);//pos box.dataset.position = "poschange" ;//通过dataset设置属性值 console.log(box.dataset.position);//poschange //注意 data-xx-yy 以及data-nameLast 命名的方式细节处理 //console.log(box.dataset.name-first);//会报错 console.log(box.dataset.nameFirst);//kobe console.log(box.dataset.nameLast);//undefined 获取不到 console.log(box.dataset.namelast);//james &#125;; &#125;;&lt;/script&gt; dataset 接口可以直接操作由data-xx 格式设置的所有data属性,即可以获取值，也可以设置值 data-name-first 设置的属性，获取的时候 必须以data.nameFirst data-nameLast 设置的属性，获取的时候 必须以 dataset.namelast 5.2.1 jQuery中 attr prop jquery中dataset属性值的操作不会在DOM树上表现出来； 1234567891011&lt;script src="jquery-1.12.2.js"&gt;&lt;/script&gt;&lt;script&gt; $(function()&#123; $("input:button").click(function()&#123; console.log($("#dv").attr("data-color"));//red console.log($("#dv").prop("data-color"));//获取不到 undefined 同样prop也无法设置 $("#dv").attr("data-color","green");//DOM 树上会显示改变 console.log($("#dv").attr("data-color"));//green &#125;); &#125;);&lt;/script&gt; 5.2.2 jquery中 data(“key”)获取属性值 data(“key”,”value”)设置属性值； 1234567891011121314151617&lt;script src="jquery-1.12.2.js"&gt;&lt;/script&gt;&lt;script&gt; $(function()&#123; $("input:button").click(function()&#123; console.log($("#dv").data); console.log($("#dv").data("color"));//red $("#dv").data("color" , "green");//设置属性，不会在DOM树上表现出来 console.log(document.querySelector("#dv").dataset.color); //js获取还是red 这个需要注意 console.log($("#dv").data("color"));//green console.log($("#dv").data("nameFirst"));//kobe console.log($("#dv").data("nameLast"));//undefined console.log($("#dv").data("namelast"));//james &#125;); &#125;);&lt;/script&gt; jquery中data(“key”,”value” )方法可以获取元素的属性值，也可以设置元素的属性值 data-name-first 设置的属性，获取的时候 必须以data(“nameFirst”) data-nameLast 设置的属性，获取的时候 必须以 dataset(“namelast”) 这点和原生js是一致的。 这个新的属性很方便我们在元素上存取数据而不用进行Ajax请求 5.3.1根据以上总结，我们在给data-xxx 属性命名的时候，尽量不应该包含大写字母，以方便查询 5.3.2 data-xx 属性里面可以存储的页面应用或者应用程序的私有的自定义的数据，不进行Ajax请求调用服务器端的数据查询，增加性能； 睡觉!]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[从chorm开发者工具看return 以及闭包的执行]]></title>
      <url>%2F2016%2F06%2F13%2F107-%E4%BB%8Echorm%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7%E7%9C%8Breturn%20%E4%BB%A5%E5%8F%8A%E9%97%AD%E5%8C%85%E7%9A%84%E6%89%A7%E8%A1%8C%2F</url>
      <content type="text"><![CDATA[从chorm开发者工具看return 以及闭包的执行1 函数在执行过程中，如果遇到return，则直接结束当前函数{ } 代码块的执行; 2 闭包的形成， 一个函数(假如是out)内部有一函数(inner) inner函数访问out函数作用域的变量 inner函数赋值给out函数作用域外的变量； 3 开发者工具 —&gt;source—&gt; scope local 等可以查看到程序执行的顺序以及闭包的形成; 4 通过开发者工具，我们可以清晰的看到代码执行的过程，然后需要思考这个过程发生了什么: 在函数的执行上下文创建阶段:变量对象被创建 在函数的执行上下文执行阶段:变量对象变为活动对象的过程 函数的this指向是在函数执行的过程中才被确定，并不是其生声明的时候被确认 执行上下文的入栈和出栈 函数执行的返回值 return会终止当前函数代码块的执行，直接跳出当前执行函数体 ​函数的实参传递，是给当前作用域增加了变量 123456789101112131415161718192021222324252627282930313233//这个闭包只有foofunction foo() &#123; var a = 2; return function bar() &#123; var b = 9; return function fn() &#123; console.log(a); &#125; &#125;&#125;var bar = foo();var fn = bar();fn();// ---------------------------------------------------//这个闭包有bar和foofunction foo() &#123; var a = 2; return function bar() &#123; //return之后下面的代码不再执行，当前函数执行完毕，当前上下文出栈 var b = 9; return function fn() &#123; console.log(a, b); &#125; &#125;&#125;var bar = foo();var fn = bar();fn(); 12345678910111213141516171819202122232425262728293031//函数立即执行的形式的闭包(function() &#123; var a = 10; var b = 20; var test = &#123; m: 20, add: function(x) &#123; return a + x; &#125;, sum: function() &#123; return a + b + this.m; &#125;, mark: function(k, j) &#123; return k + j; &#125; &#125; window.winTest = test;//将函数的内部变量test赋值给window中的属性&#125;)();winTest.add(100);winTest.sum();winTest.mark();var _mark = test.mark();console.log(_mark);//上面的所有调用，最少都访问了自执行函数中的test变量，因此都能形成闭包。即使mark方法没有访问私有变量a，b。 123456789function b ()&#123; function a ()&#123; console.log("func"); &#125; var a = 5 ; console.log(a);&#125;b();//变量声明提升，函数function的优先级大于变量var ，在开发者工具可以看下a直接就是函数]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[javascript常用API总结]]></title>
      <url>%2F2016%2F06%2F08%2F15-javascript%20%E5%B8%B8%E7%94%A8API%E6%80%BB%E7%BB%93%EF%BC%9A%2F</url>
      <content type="text"><![CDATA[javascript 常用API总结： 一、节点 1.1 节点属性 1234567891011121314151617181920Node.nodeName //返回节点名称，只读Node.nodeType //返回节点类型的常数值，只读Node.nodeValue //返回Text或Comment节点的文本值，只读Node.textContent //返回当前节点和它的所有后代节点的文本内容，可读写Node.baseURI //返回当前网页的绝对路径Node.ownerDocument //返回当前节点所在的顶层文档对象，即documentNode.nextSibling //返回紧跟在当前节点后面的第一个兄弟节点Node.previousSibling //返回当前节点前面的、距离最近的一个兄弟节点Node.parentNode //返回当前节点的父节点Node.parentElement //返回当前节点的父Element节点Node.childNodes //返回当前节点的所有子节点Node.firstChild //返回当前节点的第一个子节点Node.lastChild //返回当前节点的最后一个子节点//parentNode接口Node.children //返回指定节点的所有Element子节点Node.firstElementChild //返回当前节点的第一个Element子节点Node.lastElementChild //返回当前节点的最后一个Element子节点Node.childElementCount //返回当前节点所有Element子节点的数目。 1.2 操作 12345678910111213141516Node.appendChild(node) //向节点添加最后一个子节点Node.hasChildNodes() //返回布尔值，表示当前节点是否有子节点Node.cloneNode(true); // 默认为false(克隆节点), true(克隆节点及其属性，以及后代)Node.insertBefore(newNode,oldNode) // 在指定子节点之前插入新的子节点Node.removeChild(node) //删除节点，在要删除节点的父节点上操作Node.replaceChild(newChild,oldChild) //替换节点Node.contains(node) //返回一个布尔值，表示参数节点是否为当前节点的后代节点。Node.compareDocumentPosition(node) //返回一个7个比特位的二进制值，表示参数节点和当前节点的关系Node.isEqualNode(noe) //返回布尔值，用于检查两个节点是否相等。所谓相等的节点，指的是两个节点的类型相同、属性相同、子节点相同。Node.normalize() //用于清理当前节点内部的所有Text节点。它会去除空的文本节点，并且将毗邻的文本节点合并成一个。//ChildNode接口Node.remove() //用于删除当前节点Node.before() //Node.after()Node.replaceWith() 1.3 Document节点 1.3.1 Document节点的属性 12345678910111213141516171819202122232425262728document.doctype //document.documentElement //返回当前文档的根节点document.defaultView //返回document对象所在的window对象document.body //返回当前文档的&lt;body&gt;节点document.head //返回当前文档的&lt;head&gt;节点document.activeElement //返回当前文档中获得焦点的那个元素。//节点集合属性document.links //返回当前文档的所有a元素document.forms //返回页面中所有表单元素document.images //返回页面中所有图片元素document.embeds //返回网页中所有嵌入对象document.scripts //返回当前文档的所有脚本document.styleSheets //返回当前网页的所有样式表//文档信息属性document.documentURI //表示当前文档的网址document.URL //返回当前文档的网址document.domain //返回当前文档的域名document.lastModified //返回当前文档最后修改的时间戳document.location //返回location对象，提供当前文档的URL信息document.referrer //返回当前文档的访问来源document.title //返回当前文档的标题document.characterSet属性返回渲染当前文档的字符集，比如UTF-8、ISO-8859-1。document.readyState //返回当前文档的状态document.designMode //控制当前文档是否可编辑，可读写document.compatMode //返回浏览器处理文档的模式document.cookie //用来操作Cookie 1.3.2 Document节点的方法 （1）读写方法 1234document.open() //用于新建并打开一个文档document.close() //不安比open方法所新建的文档document.write() //用于向当前文档写入内容document.writeIn() //用于向当前文档写入内容，尾部添加换行符。 （2）查找节点 1234567document.querySelector(selectors) //接受一个CSS选择器作为参数，返回第一个匹配该选择器的元素节点。document.querySelectorAll(selectors) //接受一个CSS选择器作为参数，返回所有匹配该选择器的元素节点。document.getElementsByTagName(tagName) //返回所有指定HTML标签的元素document.getElementsByClassName(className) //返回包括了所有class名字符合指定条件的元素document.getElementsByName(name) //用于选择拥有name属性的HTML元素（比如&lt;form&gt;、&lt;radio&gt;、&lt;img&gt;、&lt;frame&gt;、&lt;embed&gt;和&lt;object&gt;等）document.getElementById(id) //返回匹配指定id属性的元素节点。document.elementFromPoint(x,y) //返回位于页面指定位置最上层的Element子节点。 （3）生成节点 1234document.createElement(tagName) //用来生成HTML元素节点。document.createTextNode(text) //用来生成文本节点document.createAttribute(name) //生成一个新的属性对象节点，并返回它。document.createDocumentFragment() //生成一个DocumentFragment对象 （4）事件方法 1234document.createEvent(type) //生成一个事件对象，该对象能被element.dispatchEvent()方法使用document.addEventListener(type,listener,capture) //注册事件document.removeEventListener(type,listener,capture) //注销事件document.dispatchEvent(event) //触发事件 （5）其他 123document.hasFocus() //返回一个布尔值，表示当前文档之中是否有元素被激活或获得焦点。document.adoptNode(externalNode) //将某个节点，从其原来所在的文档移除，插入当前文档，并返回插入后的新节点。document.importNode(externalNode, deep) //从外部文档拷贝指定节点，插入当前文档。 1.4 Element节点 1.4.1 Element节点的属性 （1）特性属性 12345678Element.attributes //返回当前元素节点的所有属性节点Element.id //返回指定元素的id属性，可读写Element.tagName //返回指定元素的大写标签名Element.innerHTML //返回该元素包含的HTML代码，可读写Element.outerHTML //返回指定元素节点的所有HTML代码，包括它自身和包含的的所有子元素，可读写Element.className //返回当前元素的class属性，可读写Element.classList //返回当前元素节点的所有class集合Element.dataset //返回元素节点中所有的data-*属性。 （2）尺寸属性 12345678910111213Element.clientHeight //返回元素节点可见部分的高度Element.clientWidth //返回元素节点可见部分的宽度Element.clientLeft //返回元素节点左边框的宽度Element.clientTop //返回元素节点顶部边框的宽度Element.scrollHeight //返回元素节点的总高度Element.scrollWidth //返回元素节点的总宽度Element.scrollLeft //返回元素节点的水平滚动条向右滚动的像素数值,通过设置这个属性可以改变元素的滚动位置Element.scrollTop //返回元素节点的垂直滚动向下滚动的像素数值Element.offsetHeight //返回元素的垂直高度(包含border,padding)Element.offsetWidth //返回元素的水平宽度(包含border,padding)Element.offsetLeft //返回当前元素左上角相对于Element.offsetParent节点的垂直偏移Element.offsetTop //返回水平位移Element.style //返回元素节点的行内样式 （3）节点相关属性 1234567Element.children //包括当前元素节点的所有子元素Element.childElementCount //返回当前元素节点包含的子HTML元素节点的个数Element.firstElementChild //返回当前节点的第一个Element子节点 Element.lastElementChild //返回当前节点的最后一个Element子节点 Element.nextElementSibling //返回当前元素节点的下一个兄弟HTML元素节点Element.previousElementSibling //返回当前元素节点的前一个兄弟HTML节点Element.offsetParent //返回当前元素节点的最靠近的、并且CSS的position属性不等于static的父元素。 1.4.2 Element节点的方法 （1）位置方法 1234567891011121314151617getBoundingClientRect() // getBoundingClientRect返回一个对象，包含top,left,right,bottom,width,height // width、height 元素自身宽高// top 元素上外边界距窗口最上面的距离// right 元素右外边界距窗口最上面的距离// bottom 元素下外边界距窗口最上面的距离// left 元素左外边界距窗口最上面的距离// width 元素自身宽(包含border,padding) // height 元素自身高(包含border,padding) getClientRects() //返回当前元素在页面上形参的所有矩形。// 元素在页面上的偏移量 var rect = el.getBoundingClientRect() return &#123; top: rect.top + document.body.scrollTop, left: rect.left + document.body.scrollLeft &#125; （2）属性方法 1234Element.getAttribute()：读取指定属性 Element.setAttribute()：设置指定属性 Element.hasAttribute()：返回一个布尔值，表示当前元素节点是否有指定的属性 Element.removeAttribute()：移除指定属性 （3）查找方法 1234Element.querySelector() Element.querySelectorAll() Element.getElementsByTagName() Element.getElementsByClassName() （4）事件方法 1234567891011121314151617181920Element.addEventListener()：添加事件的回调函数 Element.removeEventListener()：移除事件监听函数 Element.dispatchEvent()：触发事件//ie8Element.attachEvent(oneventName,listener)Element.detachEvent(oneventName,listener)// event对象 var event = window.event||event; // 事件的目标节点 var target = event.target || event.srcElement;// 事件代理 ul.addEventListener('click', function(event) &#123; if (event.target.tagName.toLowerCase() === 'li') &#123; console.log(event.target.innerHTML) &#125; &#125;); （5）其他 1234567891011Element.scrollIntoView() //滚动当前元素，进入浏览器的可见区域//解析HTML字符串，然后将生成的节点插入DOM树的指定位置。Element.insertAdjacentHTML(where, htmlString); Element.insertAdjacentHTML('beforeBegin', htmlString); // 在该元素前插入 Element.insertAdjacentHTML('afterBegin', htmlString); // 在该元素第一个子元素前插入 Element.insertAdjacentHTML('beforeEnd', htmlString); // 在该元素最后一个子元素后面插入 Element.insertAdjacentHTML('afterEnd', htmlString); // 在该元素后插入Element.remove() //用于将当前元素节点从DOM中移除Element.focus() //用于将当前页面的焦点，转移到指定元素上 二、CSS操作 （1）类名操作 12345678910111213141516171819//ie8以下Element.className //获取元素节点的类名Element.className += ' ' + newClassName //新增一个类名//判断是否有某个类名function hasClass(element,className)&#123; return new RegExp(className,'gi').test(element.className);&#125;//移除classfunction removeClass(element,className)&#123; element.className = element.className.replace(new RegExp('(^|\\b)' + className.split(' ').join('|') + '(\\b|$)', 'gi'),'');&#125;//ie10 element.classList.add(className) //新增element.classList.remove(className) //删除element.classList.contains(className) //是否包含element.classList.toggle(className) //toggle class （2）style操作 1234567891011121314151617element.setAttribute('style','')element.style.backgroundColor = 'red'element.style.cssText //用来读写或删除整个style属性element.style.setProperty(propertyName,value) //设置css属性element.style.getPropertyValue(property) //获取css属性element.style.removeProperty(property) //删除css属性操作非内联样式//ie8element.currentStyle[attrName]//ie9+window.getComputedStyle(el,null)[attrName] window.getComputedStyle(el,null).getPropertyValue(attrName)//伪类window.getComputedStyle(el,':after')[attrName] 三、对象 3.1 Object对象 （1）生成实例对象 1var o = new Object() （2）属性 1Object.prototype //返回原型对象 （3）方法 12Object.keys(o) //遍历对象的可枚举属性Object.getOwnPropertyName(o) //遍历对象不可枚举的属性 对象实例的方法 123456valueOf()：返回当前对象对应的值。 toString()：返回当前对象对应的字符串形式。 toLocaleString()：返回当前对象对应的本地字符串形式。 hasOwnProperty()：判断某个属性是否为当前对象自身的属性，还是继承自原型对象的属性。 isPrototypeOf()：判断当前对象是否为另一个对象的原型。propertyIsEnumerable()：判断某个属性是否可枚举。 3.2 Array对象 （1）生成实例对象 1var a = new Array() （2）属性 1a.length //长度 （3）Array.isArray() 1Array.isArray(a) //用来判断一个值是否为数组 （4）Array实例的方法 12345678910111213141516171819202122a.valueof() //返回数组本身a.toString() //返回数组的字符串形式a.push(value,vlaue....) //用于在数组的末端添加一个或多个元素，并返回添加新元素后的数组长度。pop() //用于删除数组的最后一个元素，并返回该元素join() //以参数作为分隔符，将所有数组成员组成一个字符串返回。如果不提供参数，默认用逗号分隔。concat() //用于多个数组的合并。它将新数组的成员，添加到原数组的尾部，然后返回一个新数组，原数组不变。shift() //用于删除数组的第一个元素，并返回该元素。unshift(value) //用于在数组的第一个位置添加元素，并返回添加新元素后的数组长度。reverse() //用于颠倒数组中元素的顺序，返回改变后的数组slice(start_index, upto_index); //用于提取原数组的一部分，返回一个新数组，原数组不变。第一个参数为起始位置（从0开始），第二个参数为终止位置（但该位置的元素本身不包括在内）。如果省略第二个参数，则一直返回到原数组的最后一个成员。负数表示倒数第几个。splice(index, count_to_remove, addElement1, addElement2, ...); //用于删除原数组的一部分成员，并可以在被删除的位置添加入新的数组成员，返回值是被删除的元素。第一个参数是删除的起始位置，第二个参数是被删除的元素个数。如果后面还有更多的参数，则表示这些就是要被插入数组的新元素。sort() //对数组成员进行排序，默认是按照字典顺序排序。排序后，原数组将被改变。如果想让sort方法按照自定义方式排序，可以传入一个函数作为参数，表示按照自定义方法进行排序。该函数本身又接受两个参数，表示进行比较的两个元素。如果返回值大于0，表示第一个元素排在第二个元素后面；其他情况下，都是第一个元素排在第二个元素前面。map() //对数组的所有成员依次调用一个函数，根据函数结果返回一个新数组。map(elem,index,arr) //map方法接受一个函数作为参数。该函数调用时，map方法会将其传入三个参数，分别是当前成员、当前位置和数组本身。forEach() //遍历数组的所有成员，执行某种操作,参数是一个函数。它接受三个参数，分别是当前位置的值、当前位置的编号和整个数组。filter() //参数是一个函数，所有数组成员依次执行该函数，返回结果为true的成员组成一个新数组返回。该方法不会改变原数组。some() //用来判断数组成员是否符合某种条件。接受一个函数作为参数，所有数组成员依次执行该函数，返回一个布尔值。该函数接受三个参数，依次是当前位置的成员、当前位置的序号和整个数组。只要有一个数组成员的返回值是true，则整个some方法的返回值就是true，否则false。every() //用来判断数组成员是否符合某种条件。接受一个函数作为参数，所有数组成员依次执行该函数，返回一个布尔值。该函数接受三个参数，依次是当前位置的成员、当前位置的序号和整个数组。所有数组成员的返回值都是true，才返回true，否则false。reduce() //依次处理数组的每个成员，最终累计为一个值。从左到右处理（从第一个成员到最后一个成员）reduceRight() //依次处理数组的每个成员，最终累计为一个值。从右到左（从最后一个成员到第一个成员）indexOf(s) //返回给定元素在数组中第一次出现的位置，如果没有出现则返回-1。可以接受第二个参数，表示搜索的开始位置lastIndexOf() //返回给定元素在数组中最后一次出现的位置，如果没有出现则返回-1。 3.3 Number对象 （1）生成对象 1var n = new Number() （2）Number对象的属性 1234567Number.POSITIVE_INFINITY：正的无限，指向Infinity。 Number.NEGATIVE_INFINITY：负的无限，指向-Infinity。 Number.NaN：表示非数值，指向NaN。 Number.MAX_VALUE：表示最大的正数，相应的，最小的负数为-Number.MAX_VALUE。 Number.MIN_VALUE：表示最小的正数（即最接近0的正数，在64位浮点数体系中为5e-324），相应的，最接近0的负数为-Number.MIN_VALUE。 Number.MAX_SAFE_INTEGER：表示能够精确表示的最大整数，即9007199254740991。 Number.MIN_SAFE_INTEGER：表示能够精确表示的最小整数，即-9007199254740991。 （4）Number对象实例的方法 1234toString() //用来将一个数值转为字符串形式.可以接受一个参数，表示输出的进制。如果省略这个参数，默认将数值先转为十进制，再输出字符串；否则，就根据参数指定的进制，将一个数字转化成某个进制的字符串。toFixed() //用于将一个数转为指定位数的小数，返回这个小数对应的字符串。toExponential() //用于将一个数转为科学计数法形式。可传入一个参数，参数表示小数点后有效数字的位数，范围为0到20，超出这个范围，会抛出一个RangeError。toPrecision() //用于将一个数转为指定位数的有效数字。 3.4 String 对象 （1）生成实例对象 1var s = new String() （2）String对象的属性 1s.length //返回字符串的长度 （3）方法 1234567891011121314151617s.chatAt(index) //返回指定位置的字符s.fromCharCode() //该方法的参数是一系列Unicode码点，返回对应的字符串。s.charCodeAt(index) //返回给定位置字符的Unicode码点（十进制表示）s.concat(s2) //用于连接两个字符串s.slice(start,end) //用于从原字符串取出子字符串并返回，不改变原字符串。第一个参数是子字符串的开始位置，第二个参数是子字符串的结束位置（不含该位置）。如果参数是负值，表示从结尾开始倒数计算的位置，即该负值加上字符串长度。s.substring(start,end) //用于从原字符串取出子字符串并返回，不改变原字符串.第一个参数表示子字符串的开始位置，第二个位置表示结束位置。s.substr(start,length) //用于从原字符串取出子字符串并返回，不改变原字符串。第一个参数是子字符串的开始位置，第二个参数是子字符串的长度。如果第一个参数是负数，表示倒数计算的字符位置。如果第二个参数是负数，将被自动转为0，因此会返回空字符串。s.indexOf(s) //返回给定元素在字符串中第一次出现的位置，如果没有出现则返回-1。可以接受第二个参数，表示搜索的开始位置 s.lastIndexOf() //返回给定元素在字符串中最后一次出现的位置，如果没有出现则返回-1。s.trim() //用于去除字符串两端的空格，返回一个新字符串s.toLowerCase() //用于将一个字符串全部转为小写,返回一个新字符串，不改变原字符串。s.toUpperCase() //全部转为大写s.localeCompare(s2) //用于比较两个字符串。它返回一个整数，如果小于0，表示第一个字符串小于第二个字符串；如果等于0，表示两者相等；如果大于0，表示第一个字符串大于第二个字符串。s.match(regexp) //用于确定原字符串是否匹配某个子字符串，返回一个数组，成员为匹配的第一个字符串。如果没有找到匹配，则返回null。s.search() //返回值为匹配的第一个位置。如果没有找到匹配，则返回-1。s.replace(oldValue,newValue) //用于替换匹配的子字符串，一般情况下只替换第一个匹配（除非使用带有g修饰符的正则表达式）。s.split() //按照给定规则分割字符串，返回一个由分割出来的子字符串组成的数组。还可传入第二个参数，决定了返回数组的成员数。 3.5 Math对象 （1）属性 12345678Math.E：常数e。 Math.LN2：2的自然对数。 Math.LN10：10的自然对数。 Math.LOG2E：以2为底的e的对数。 Math.LOG10E：以10为底的e的对数。 Math.PI：常数Pi。 Math.SQRT1_2：0.5的平方根。 Math.SQRT2：2的平方根。 （2）数学方法 1234567891011Math.abs()：返回参数的绝对值 Math.ceil()：向上取整，接受一个参数，返回大于该参数的最小整数。 Math.floor()：向下取整 Math.max(n,n1,...)：可接受多个参数，返回最大值 Math.min(n,n1,..)：可接受多个参数，返回最小值 Math.pow(n,e)：指数运算, 返回以第一个参数为底数、第二个参数为幂的指数值。 Math.sqrt()：返回参数值的平方根。如果参数是一个负值，则返回NaN。 Math.log()：返回以e为底的自然对数值。Math.exp()：返回e的指数，也就是常数e的参数次方。Math.round()：四舍五入 Math.random()：返回0到1之间的一个伪随机数，可能等于0，但是一定小于1。 （3）三角函数方法 123456Math.sin()：返回参数的正弦 Math.cos()：返回参数的余弦 Math.tan()：返回参数的正切 Math.asin()：返回参数的反正弦（弧度值） Math.acos()：返回参数的反余弦（弧度值） Math.atan()：返回参数的反正切（弧度值） 3.6 JSON对象 （1）方法 123456JSON.stringify() //用于将一个值转为字符串。该字符串应该符合JSON格式，并且可以被JSON.parse方法还原。//（JSON.stringify(obj, selectedProperties)）还可以接受一个数组，作为第二个参数，指定需要转成字符串的属性。//还可以接受第三个参数，用于增加返回的JSON字符串的可读性。如果是数字，表示每个属性前面添加的空格（最多不超过10个）；如果是字符串（不超过10个字符），则该字符串会添加在每行前面。JSON.parse() //用于将JSON字符串转化成对象。 3.7 console对象 （1）方法 1234567891011121314151617181920212223242526console.log(text,text2,...) //用于在console窗口输出信息。它可以接受多个参数，将它们的结果连接起来输出。如果第一个参数是格式字符串（使用了格式占位符），console.log方法将依次用后面的参数替换占位符，然后再进行输出。console.info() //在console窗口输出信息，同时，会在输出信息的前面，加上一个蓝色图标。console.debug() //在console窗口输出信息，同时，会在输出信息的前面，加上一个蓝色图标。console.warn() //输出信息时，在最前面加一个黄色三角，表示警告；console.error() //输出信息时，在最前面加一个红色的叉，表示出错，同时会显示错误发生的堆栈console.table() //可以将复合类型的数据转为表格显示。console.count() //用于计数，输出它被调用了多少次。console.dir() //用来对一个对象进行检查（inspect），并以易于阅读和打印的格式显示。console.dirxml() //用于以目录树的形式，显示DOM节点。console.assert() //接受两个参数，第一个参数是表达式，第二个参数是字符串。只有当第一个参数为false，才会输出第二个参数，否则不会有任何结果。//这两个方法用于计时，可以算出一个操作所花费的准确时间。console.time()console.timeEnd()//time方法表示计时开始，timeEnd方法表示计时结束。它们的参数是计时器的名称。调用timeEnd方法之后，console窗口会显示“计时器名称: 所耗费的时间”。console.profile() //用来新建一个性能测试器（profile），它的参数是性能测试器的名字。console.profileEnd() //用来结束正在运行的性能测试器。console.group()console.groupend()//上面这两个方法用于将显示的信息分组。它只在输出大量信息时有用，分在一组的信息，可以用鼠标折叠/展开。console.groupCollapsed() //用于将显示的信息分组，该组的内容，在第一次显示时是收起的（collapsed），而不是展开的。console.trace() //显示当前执行的代码在堆栈中的调用路径。console.clear() //用于清除当前控制台的所有输出，将光标回置到第一行。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[less]]></title>
      <url>%2F2016%2F06%2F08%2F48-less%E7%A8%8B%E5%BA%8F%E5%8C%96%E7%BC%96%E8%AF%91CSS%2F</url>
      <content type="text"><![CDATA[less程序化编译CSS1 语法:定义变量，LESS 允许开发者自定义变量，变量可以在全局样式中使用，变量使得样式修改起来更加简单。12345/*语法：@变量名: 值*/@mainColor : red ;div &#123; color:@mainColor ;&#125; 2 Mixin 混入:功能对用开发者来说并不陌生，很多动态语言都支持 Mixin（混入）特性，它是多重继承的一种实现，在 LESS 中，混入是指在一个 CLASS 中引入另外一个已经定义的 CLASS，就像在当前 CLASS 中增加一个属性一样。 样式混入 12345678910.red &#123; color : red ;&#125;.border &#123; border:2px solid #000 ;&#125;.mixin-class &#123; .red(); .border();&#125; 函数混入(变量必须要有默认值:如果后面的代码用到了该变量，否则会提示undefined) 12345678910.red(@color:red)&#123; color : @color ;&#125;.border(@color:#ccc,@width:3px)&#123; border : @width solid @color ;&#125;.mixin-func &#123; .red(skyblue); .border(#666,10px);&#125; 3 嵌套:在我们书写标准 CSS 的时候，遇到多层的元素嵌套这种情况时，我们要么采用从外到内的选择器嵌套定义，要么采用给特定元素加 CLASS 或 ID 的方式”比如以下这段html的嵌套书写 12345678910111213141516&lt;div class="container"&gt; &lt;div class="row"&gt; &lt;div class="column"&gt; &lt;h3&gt;&lt;/h3&gt; &lt;a href=""&gt;&lt;img src="" alt=""/&gt;&lt;/a&gt; &lt;/div&gt; &lt;div class="column"&gt; &lt;h3&gt;&lt;/h3&gt; &lt;a href=""&gt;&lt;img src="" alt=""/&gt;&lt;/a&gt; &lt;/div&gt; &lt;div class="column"&gt; &lt;h3&gt;&lt;/h3&gt; &lt;a href=""&gt;&lt;img src="" alt=""/&gt;&lt;/a&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; css样式如下: 12345678910111213141516171819202122232425262728.container&#123; width:1000px; height:80px; position:relative;&#125;.container&gt;.row &#123; width:100%; height:100%;&#125;.container&gt;.row&gt;.column &#123; width:33.333%; height:100%; border:2px solid #000;&#125;/*后代选择器*/.container&gt;.row&gt;.column h3 &#123; margin:0;&#125;.container&gt;.row&gt;.column a &#123; dispaly:block; width:100%; height:100%; text-decoration:none;&#125;.container&gt;.row&gt;.column a : hover &#123; color:#dddddd; background-color:#ccc;&#125; less编译如下(注意伪类需要加 &amp;:伪类 ) 12345678910111213141516171819202122232425262728.container &#123; width:1000px; height:80px; position:relative; .row &#123; width:100%; height:100%; .column &#123; width:33.333%; height:100%; border:2px solid #000; h3 &#123; margin:0; &#125; a &#123; dispaly:block; width:100%; height:100%; text-decoration:none; &#125; /*&amp;:伪类*/ &amp;:hover &#123; color:#dddddd; background-color:#ccc; &#125; &#125; &#125; &#125; 注意伪类选择符：E:hover E : link E :first-child 4 Import导入:可以使我们的样式编译模块化,这个思想很重呀，模块化的编程会使我们的维护特别简单。1@import "lessFileName"; 5 Less cmd命令符1lessc -v :查看less文件的版本; 6 在less文件中，/**/ 注释同样可以在css中出现，而 // 注释只会在less中出现，不会再编译的css中出现。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[div居中的几种方式]]></title>
      <url>%2F2016%2F06%2F02%2F152div%E5%B1%85%E4%B8%AD%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[div居中的几种方式 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768* 水平居中：给div设置一个宽度，然后添加margin:0 auto属性 div&#123; width:200px; margin:0 auto; &#125;* 让绝对定位的div居中 div &#123; position: absolute; width: 300px; height: 300px; margin: auto; top: 0; left: 0; bottom: 0; right: 0; background-color: pink; /* 方便看效果 */ &#125;* 水平垂直居中一 确定容器的宽高 宽500 高 300 的层 设置层的外边距 div &#123; position: relative; /* 相对定位或绝对定位均可 */ width:500px; height:300px; top: 50%; left: 50%; margin: -150px 0 0 -250px; /* 外边距为自身宽高的一半 */ background-color: pink; /* 方便看效果 */ &#125;* 水平垂直居中二 未知容器的宽高，利用 `transform` 属性 div &#123; position: absolute; /* 相对定位或绝对定位均可 */ width:500px; height:300px; top: 50%; left: 50%; transform: translate(-50%, -50%); background-color: pink; /* 方便看效果 */ &#125;* 水平垂直居中三 利用 flex 布局 实际使用时应考虑兼容性 .container &#123; display: flex; align-items: center; /* 垂直居中 */ justify-content: center; /* 水平居中 */ &#125; .container div &#123; width: 100px; height: 100px; background-color: pink; /* 方便看效果 */ &#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[伪类选择符]]></title>
      <url>%2F2016%2F05%2F28%2F06%20%E4%BC%AA%E7%B1%BB%E9%80%89%E6%8B%A9%E7%AC%A6%20%E5%85%B3%E7%B3%BB%E9%80%89%E6%8B%A9%E7%AC%A6%2F</url>
      <content type="text"><![CDATA[伪类选择符一 先看定义： ​ E:first-child{ } :匹配父元素的第一个子元素E。 要使该属性生效，E元素必须是某个元素的子元素，E的父元素最高是body，即E可以是body的子元素 注意两点 第一 E 必须是某个元素的子元素 第二 E 必须是该元素的 第一个子元素，否则无法获取； ​ E:first-of-type{ } : 匹配同类型中的第一个同级兄弟元素E ，可以理解为在同辈元素中找到所有的E 元素组成一个新的集合，可以选中这个新的集合中的第一个E 元素 要使该属性生效，E元素必须是某个元素的子元素，E的父元素最高是html，即E可以是html的子元素，也就是说E可以是body该选择符总是能命中父元素的第1个为E的子元素，不论第1个子元素是否为E 注意和first-child 的区别，第一：E 必须是某个元素的子元素，第二 E 不必是父元素的额第一个子元素 ​ E:nth-child (n){ } :匹配父元素的第n个子元素E，假设该子元素不是E，则选择符无效。注意n 的取值是从 1 开始。 要使该属性生效，E元素必须是某个元素的子元素，E的父元素最高是body，即E可以是body的子元素该选择符允许使用一个乘法因子(n)来作为换算方式，比如我们想选中所有的偶数子元素E，那么选择符可以写成：E:nth-child(2n) 注意：第一：E元素必须是某个元素的子元素，第二，n的取值要对应父元素的所有子元素组成的集合的索引值 ​ E:nth-of-type(n) { } :匹配同类型中的第n个同级兄弟元素E。 可以理解为在同辈元素中找到所有的E 元素组成一个新的集合，可以选中这个新的集合中的第 n 个E 元素 要使该属性生效，E元素必须是某个元素的子元素，E的父元素最高是html，即E可以是html的子元素，也就是说E可以是body该选择符总是能命中父元素的第n个为E的子元素，不论第n个子元素是否为E 二 :直接撸代码 12345678910111213141516&lt;style&gt; p:first-child &#123; background-color: pink; &#125; p:first-of-type &#123; color: blue; &#125; &lt;/style&gt;&lt;div&gt; &lt;p&gt;第1个p&lt;/p&gt; &lt;p&gt;第2个p&lt;/p&gt; &lt;span&gt;第1个span&lt;/span&gt; &lt;p&gt;第3个p&lt;/p&gt; &lt;span&gt;第2个span&lt;/span&gt; &lt;/div&gt; 结果：第一个p 的背景色会变，颜色字体会变（注意：大家最可能搞混的是选中第一个p会这么写 1div:first-child &#123; &#125; //这么写是错误的，大家注意区分 12345678910111213141516&lt;div&gt; &lt;div&gt;这是一个div &lt;/div&gt; &lt;p&gt;第1个p&lt;/p&gt; &lt;p&gt;第2个p&lt;/p&gt; &lt;span&gt;第1个span&lt;/span&gt; &lt;p&gt;第3个p&lt;/p&gt; &lt;span&gt;第2个span&lt;/span&gt; &lt;/div&gt;&lt;style&gt; p:first-child &#123; background-color: pink; &#125; p:first-of-type &#123; color: blue; &#125; &lt;/style&gt; 结果：第一个p的背景色不会变，颜色字体会变。 如果在前面加一个div,那么不会改变： first-child伪类选择器选择的元素必须是某个父元素的的第一个子元素才能被选中。 first-of-type 伪类选择器选择的可以选择第一个该类型的元素，无论其是不是父元素的第一个子元素。 1234567891011121314&lt;style&gt; p:nth-child(1)&#123; font-size: 30px; &#125; &lt;/style&gt;&lt;div&gt; &lt;p&gt;第1个p&lt;/p&gt; &lt;p&gt;第2个p&lt;/p&gt; &lt;span&gt;第1个span&lt;/span&gt; &lt;p&gt;第3个p&lt;/p&gt; &lt;span&gt;第2个span&lt;/span&gt; &lt;/div&gt; 1234567891011121314151617&lt;style&gt; p:nth-child(1)&#123; font-size: 30px; &#125;//这行代码已经无法命中第一个p，需要用下面的代码 p:nth-of-type(1)&#123; font-size: 30px; &#125; &lt;/style&gt; &lt;div&gt; &lt;div&gt;这是一个div &lt;/div&gt; &lt;p&gt;第1个p&lt;/p&gt; &lt;p&gt;第2个p&lt;/p&gt; &lt;span&gt;第1个span&lt;/span&gt; &lt;p&gt;第3个p&lt;/p&gt; &lt;span&gt;第2个span&lt;/span&gt; &lt;/div&gt; nth-child(n) 伪类选择器，选择的范围是所有子元素的同辈元素组成的一个集合，然后n代表该集合中某个元素的索引 p:nth-child(2) 可以获取 ‘’第1个p’ p:nth-child(3) 可以获取 ‘第2个p ‘’;注意：如果里面是n的表达式 比如p:nth-child(n) ,也是会选择中所有的p标签，n或从 0 一直递增。选择的过程是：判断第一个div，发现不是p标签，然后不选中，执行n+1，此时判断第一个p ，判断出来是一个p标签，然后选中，依次类推。 nth-of-type(n) 伪类选择器，选择的范围是所有子元素中该类型的元素组成的一个集合，然后 n 代表该类型结合中元素的索引 比如 p:nth-of-type(2){ } 则可以选中第2个p p:nth-of-type(3){ } 则可以选中第3个p 三 last-child last-of-type nth-last-child(n) nth-last-of-type(n),和上面一样，只是从后面开始 四 需要注意的一点就是 first-child last-child 。 五 综合下jquery 12345&lt;script src=jquery-1.12.2.js&gt; &lt;/script&gt;&lt;script&gt; $("p:first-child").css("border","2px solid green"); $("p:first-of-type").css("border","2px solid red");&lt;/script&gt; 在jquery中也是如此，如果用first-child 伪类选择该元素，那么该元素必须是其父元素的第一个子元素，仔细回顾伪类的定义;first-of-child ,等以上的几个伪类选择器，在jquery中一样的规则。可以说新的CSS 3 向jquery学习和借鉴了很多特点。 二 关系选择符 E+F 只会选择所有匹配到的E后面紧邻 的F元素 E~F 只会选择所有匹配到的E后面所有 的F元素 123456789101112131415161718192021&lt;style&gt; p+p&#123; font-size: 30px; &#125; //这行代码只能选中 第2个p 和 第4个p p~p&#123; font-size: 30px; &#125; //这行代码将选中 第2 3 4 5 个p &lt;/style&gt; &lt;div&gt; &lt;div&gt;这是一个div &lt;/div&gt; &lt;p&gt;第1个p&lt;/p&gt; &lt;p&gt;第2个p&lt;/p&gt; &lt;span&gt;第1个span&lt;/span&gt; &lt;p&gt;第3个p&lt;/p&gt; &lt;p&gt;第4个p&lt;/p&gt; &lt;span&gt;第2个span&lt;/span&gt; &lt;p&gt;第5个p&lt;/p&gt; &lt;/div&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[margin auto position定位使盒子居中]]></title>
      <url>%2F2016%2F05%2F23%2F02margin%20%20auto%20%20position%2F</url>
      <content type="text"><![CDATA[position定位如何在父盒子居中 一 简单了解position定位取值： position:left right bottom top length | % length 是确定单位距离的取值，单位以px em等 百分比%,此时要明确百分比对应的取值标准，水平方向 left= 百分比值 X 父元素的宽度(基准是父元素padding+width)，垂直方向 top = 百分比值 X 父元素的高度(此时基准是父元素的padding+height)；前提是父元素设置了除 static之外的定位，否则，百分比取值基准是浏览器的高度和宽度。 二 margin 取值 auto：水平（默认）书写模式下，margin-top/margin-bottom计算值为0，margin-left/margin-right取决于可用空间；这也是块级元素的流体特性 。思考 auto 的取值什么时候会起作用。 length : 用长度值来定义外补白。可以为负值 百分比： 用百分比来定义外补白。水平（默认）书写模式下，参照其包含块 width 进行计算，其它情况参照 height ，可以为负值 三：理解margin的auto取值问题： 标准流下的margin的auto取值：对于块级元素，margin: 0 auto ;可以使块级元素居中显示，就是利用了块级元素的流体特性 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang="en"&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; .bigbox &#123; width: 800px; height: 200px; margin: 100px auto; //使bigbox在body中居中 border: 1px solid #000; &#125; .smallbox &#123; width: 100px; height: 100px; background-color: limegreen; margin:0 auto; //使smallbox在bigbox中居中 &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="bigbox"&gt; &lt;div class="smallbox"&gt;&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 标准流下的auto取值：如果发生了元素转化，块级元素转化为行内块元素,display:inline-block position float 等 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang="en"&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; .bigbox &#123; width: 800px; height: 200px; margin: 100px auto; //使bigbox在body中居中 border: 1px solid #000; position:absolute; //display:inline-block; &#125; .smallbox &#123; width: 100px; height: 100px; background-color: limegreen; margin:0 auto; //使smallbox在bigbox中居中 position:absolute; //display:inline-block; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="bigbox"&gt; &lt;div class="smallbox"&gt;&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 建议大家拿到自己的浏览器上看效果：此时 margin的 auto 你会奇怪的发现不起作用了。 bigbox不在body中居中，smallbox不在bigbox中居中。 auto：水平（默认）书写模式下，margin-top/margin-bottom计算值为0，margin-left/margin-right取决于可用空间。品味这句话：我们可以理解，块级元素独占一整行，即使设置了宽高，仍然独占一整行；而行内块元素却不是。所以 ，margin 的auto值对于块级元素使用时候，会使其居中显示，而对于行内块元素使用的时候，却不会使其居中。 四：定位使盒子居中的方法： 两种方法： 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang="en"&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; .bigbox &#123; width: 800px; height: 200px; margin: 100px auto; border: 1px solid #000; position: relative; &#125; .smallbox &#123; width: 100px; height: 100px; background-color: limegreen; position: absolute; left: 50%; /*定位的百分比 left=百分比*父元素的宽度*/ margin-left: -50px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="bigbox"&gt; &lt;div class="smallbox"&gt;&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang="en"&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; .bigbox &#123; width: 800px; height: 200px; margin: 100px auto; border: 1px solid #000; position: relative; &#125; .smallbox&#123; background-color: limegreen; width: 100px; height: 100px; position: absolute; left: 0; right: 0; margin:0 auto; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="bigbox"&gt; &lt;div class="smallbox"&gt;&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 其中第二种方法适用于不知道子元素的高宽的时候想要使子元素居中的效果。其实也是利用了流体特性，因为元素既要距离左边距0 又要距离右边距0 同时给该元素设置了margin:0 auto; 所以会用margin值填充左右的补白； 扩展：如果去掉bigbox的宽度设置，那么，无论浏览器的窗口如何变化，都可以使盒子居中，包括大盒子的body居中，小盒子在大盒子居中。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[DOMContentLoaded]]></title>
      <url>%2F2016%2F05%2F13%2F158DOMContentLoaded%2F</url>
      <content type="text"><![CDATA[1 DOMContentLoaded 和 onload事件 onload事件会在页面或者图像加载完成后立即发生。 DOMContentLoaded这个事件是从HTML中的onLoad的延伸而来的，当一个页面完成加载时,初始化脚本的方法是使用load事件，但这个类函数的缺点是仅在所有资源都完全加载后才被触发,这有时会导致比较严重的延迟,开发人员随后创建了一种自定义事件,domready,它在DOM加载之后及资源加载之前被触发。jQuery中的$(function(){})就是封装的这个方法 1.1 先来看下浏览器向服务器发送请求之后，请求到了HTML文档之后便开始解析，先生成DOM树 ，然后生成CSSDOM树，再由二者结合生成渲染树(RenderTree),有了所有的节点的样式，浏览器便可以genuine这些节点以及它们的样式确定它们的位置和大小，这就是layout阶段，之后浏览器会进行渲染，总结如下 DOM–&gt;CSSOM–&gt;RenderTree–&gt;layout–&gt;Paint 1.2 当然了这个时候我们还没有考虑到javascript;javascript会阻塞DOM的生成，也就是说当浏览器解析HTML的时候，如果遇到了script标签就会停止对HTML的解析，转而进行处理javascript脚本 如果脚本是内联的，浏览器会先执行这段javascript代码 如果脚本是外联的，浏览器会先加载脚本，然后执行 因为javascript可以查询任意对象的样式，也就是说在CSSOM解析完毕之后，javascript才会被执行 处理完毕脚本之后会继续解析HTML文档 1.3 总结: 当文档中没有javascript脚本的时候，浏览器解析玩文档便能触发DOMContentLoaded事件 如果文档中包含脚本，则会阻塞文档的解析，同时脚本的执行需要等待CSSOM解析完毕才能执行 DOMContentLoaded事件的触发不需要等待图片等其他资源加载完成 2 异步脚本 2.1 我们知道同步脚本的解析对网页渲染有影响，如果我们想要页面尽快的显示，那我们可以使用异步脚本；HTML5中有两种执行异步脚本的方法:defer和async 2.2 看下二者的区别 2.2.1 script脚本，没有defer和async属性 1&lt;script src="***.js"&gt;&lt;/script&gt; 当HTML文档解析的时候遇到javascript标签，会停止对文档的解析，进而加载javascript脚本，加载完毕之后立即执行 2.2.2 defer脚本 1&lt;script src="***.js" defer&gt;&lt;/script&gt; 当HTML文档解析的时候遇见defer脚本，则会在后台加载脚本，文档的解析过程不会中断， 当文档解析结束之后，defer脚本执行；defer脚本的执行顺序与定义的时候的位置有关 defer属性只适用于外联脚本，如果script标签没有src属性，只是内联脚本，不要使用defer 如果声明了多个defer脚本，则会按照顺序进行执行 defer脚本会在DOMContentLoaded和loaded事件触发之前执行 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;defer &amp; async&lt;/title&gt; &lt;link rel="stylesheet" type="text/css" href="css/main.css"&gt; &lt;!-- adding a 'defer' attribute, by default, the value will be 'true' --&gt; &lt;script type="text/javascript" src="js/1.js" defer&gt;&lt;/script&gt; &lt;script type="text/javascript" src="js/2.js" defer&gt;&lt;/script&gt; &lt;script type="text/javascript" defer&gt; console.log(3); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="text"&gt;Hello World&lt;/div&gt; &lt;script type="text/javascript"&gt; document.addEventListener("DOMContentLoaded", function() &#123; console.log('dom content loaded, ready state:', this.readyState); &#125;, false); window.addEventListener('load', function() &#123; console.log('window loaded, dom ready state:', document.readyState); &#125;, false); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 12//js/1.jsconsole.log("1"); 12//js/2.jsconsole.log("2"); 输出如下 1234531220defer.html:17 dom content loaded, ready state: interactive20defer.html:21 window loaded, dom ready state: complete 2.2.3 async脚本 1&lt;script src="***.js" async&gt;&lt;/script&gt; 当HTML文档解析的时候遇见async脚本，则会在后台加载脚本，文档的解析过程不会中断， 脚本加载完成之后，文档停止解析，async脚本执行；async脚本执行完毕之后，文档继续解析 只适用于外联脚本，这一点和defer一致 如果有多个声明了async的脚本，其下载和执行也是异步的，不能确保彼此的先后顺序 async会在load事件之前执行，但并不能确保与DOMContentLoaded的执行先后顺序 2.2.4 async脚本不考虑依赖，加载完毕之后马上会执行，这点对于不需要依赖的javascript脚本是非常合适的，但是对于需要依赖的javascript脚本而言，defer无疑是最合适的。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[window]]></title>
      <url>%2F2016%2F05%2F13%2F80-window%E5%AF%B9%E8%B1%A1%2F</url>
      <content type="text"><![CDATA[1 window对象1.1 Window 对象表示浏览器中打开的窗口。 如果文档包含框架（frame 或 iframe 标签），浏览器会为 HTML 文档创建一个 window 对象，并为每个框架创建一个额外的 window 对象。 1.2 innerHeight innerWidth 表示浏览器中 文档显示区 的高度和宽度，如果F12，调出控制台，那么会影响文档显示区的高度 1.3 outerHeight outerWidth iframe标签 contentDocument 属性能够以 HTML 对象来返回 iframe 中的文档。 可以通过所有标准的 DOM 方法来处理被返回的对象。 12345678910111213141516&lt;html&gt;&lt;head&gt;&lt;script type="text/javascript"&gt;function getTextNode()&#123;var x=document.getElementById("frame1").contentDocument;alert(x.getElementsByTagName("h2")[0].childNodes[0].nodeValue);&#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;iframe src="frame_a.htm" id="frame1"&gt;&lt;/iframe&gt;&lt;br /&gt;&lt;br /&gt;&lt;input type="button" onclick="getTextNode()" value="Get text" /&gt;&lt;/body&gt;&lt;/html&gt; 2 window对象的属性2.1 location属性：window对象的location属性指向Location对象.通过如下方式可以查看所有的locatio对象的属性和方法 123for (var key in location)&#123; console.log(key + "--&gt;"+location[key]);&#125; hash 设置或返回从井号 (#) 开始的 URL（锚）。 host 设置或返回主机名和当前 URL 的端口号。 hostname 设置或返回当前 URL 的主机名。 href 设置或返回完整的 URL。 pathname 设置或返回当前 URL 的路径部分。 port 设置或返回当前 URL 的端口号。 protocol 设置或返回当前 URL 的协议。 search 设置或返回从问号 (?) 开始的 URL（查询部分）。 2.2 history属性: window对象的history属性指向History对象 12345&lt;input type="button" value="按钮" id="btn"/&gt;&lt;script&gt; //如果HTML以id来为元素命名，并且Window对象没有此名字的属性，Window对象会赋予一个属性，它的名字是id值，指向ＨＴＭＬ 元素； console.log(window.btn);//&lt;input type="button" value="按钮" id="btn"/&gt;&lt;/script&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[清除浮动的方式]]></title>
      <url>%2F2016%2F04%2F28%2F38-%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8%E7%9A%84%E6%96%B9%E5%BC%8F%EF%BC%9A%2F</url>
      <content type="text"><![CDATA[清除浮动的方式： 第一：给父元素设置高度 第二：给父元素设置 overflow:hidden ，zoom:1 (zoom :1用来兼容IE6)触发BFC，父元素仍然会被设置了浮动的子元素的高度撑开(如果父元素没有设置高度的话) 第三：伪元素，在当前元素的前后添加伪元素，使该伪元素设置：clear:both;注意height必须设置为0 ，否则该元素回避实际高出若干像素； 1234567clearfix::before,clearfix::after &#123; content:""; display:block; visibility:hidden;//伪元素不可见 line-height:0; height:0 ;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Ajax 如何处理缓存]]></title>
      <url>%2F2016%2F04%2F17%2F154Ajax-%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E7%BC%93%E5%AD%98%2F</url>
      <content type="text"><![CDATA[1.GET请求缓存处理，不想要缓存GET请求？ 浏览器会缓存GET请求，不会缓存POST请求，因此解决为： 浏览器就会在本地硬盘上 查找 与该 URL 相关联的 Cookie 。如果该 Cookie 存在，浏览器就将它添加到 request header的Cookie字段中，与 http请求`一起发送到该站点 方法1：GET请求URL后加随机数，让服务器认为是不同的请求，如：”http://www.example.com/index.jsp?class=articele&amp;page=5&amp;t&quot;+new Date().getTime(); 或者 URL 参数后加上 “?ran=” + Math.random(); //当然这里参数 ran可以任意取了 方法2：在ajax发送请求前加上xmlHttpRequest.setRequestHeader(“If-modified-since”,”0”); 方法3：在ajax发送请求前加上xmlHttpRequest.setRequestHeader(“Cache-Control”,”no-cache”); 方法4：若为jQuery ajax, 设置ajax属性cache:false;(注意：cache属性对post没有用，对get才有用)或者 beforeSend :function(xmlHttp){xmlHttp.setRequestHeader(“If-Modified-Since”,”0”);xmlHttp.setRequestHeader(“Cache-Control”,”no-cache”);}, 方法5：在服务器端响应请求时加上response.setHeader(“Cache-Control”,”no-cache,must-revalidate”); 方法6：使用POST代替GET,浏览器不会对POST做缓存 注意：为什么cache属性对post没有用，对get才有用？ 因为1.浏览器缓存url请求原理就是判断url是否相同，url相同则读取缓存，url不相同则读取服务器 2.使用GET方式提交url类似”http://www.example.com/index.jsp?class=articele&amp;page=5“，而POST方式提交url类似http://www.example.com/index.jsp，参数是在请求 head里的，不在url上，请求参数url始终相同 3.jquery ajax GET方式提交： data: “t=” + new Date().getTime(), 或者 data:{“t”: new Date().getTime()}或者cash:false都是在请求后面加上不同的参数，cach:false会启动生成参数附加在url请求里，因此浏览器认为是不同的请求，就重新请求服务器]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[jquery height innerHeight outerHeight]]></title>
      <url>%2F2016%2F04%2F17%2F01jquery%20%20height()%20%20innerHeight%20()%20%20outerHeight(%20)%2F</url>
      <content type="text"><![CDATA[一 看解释： 1 height( )只可以获取内容高度，也就是原本设置的height高度值，或者由内容撑开的高度值 2 innerHeight( ) ,获取的高度包括 padding，不包括边框 3 outerHeight( ),获取的高度值包括 padding 和border ，不包括margin， 二 撸代码： 不写参数可以获取当前值 123456789101112131415161718192021222324252627282930&lt;style&gt; *&#123; margin: 0; padding: 0; &#125; div&#123; border: 5px solid #000; position: absolute; width: 300px; height: 200px; margin: 100px; &#125; p&#123; border: 1px solid green; width: 200px; height:18px padding: 10px; margin: 20px; &#125; &lt;/style&gt; &lt;div&gt; &lt;p id="p2"&gt;这是一个段落&lt;/p&gt; &lt;/div&gt; &lt;script src="jquery-1.12.2.js"&gt;&lt;/script&gt;&lt;script&gt; console.log($("#p2").height()); //18 padding 18 margin 18 console.log($("#p2").innerHeight()); //18 38 38 console.log($("#p2").outerHeight()); //20 40 40&lt;/script&gt; 代码解释：padding 和 margin 逐渐加上之后，输出值变化如注释所示。 写了参数可以设置 height(number) innerHeight(number) outerHeight(number) 它们各自代表的高度的值 写了参数也可以这么设置 height(number+”px”) 栗子: $(“selector”).height(100+”px”); Tips $(“selector”).width(number) 等价于 \$(“selector”).css(“width”,number); 12345678910&lt;script&gt; $("#btn").click(function()&#123; $("#p2").height(30); $("#p2").innerHeight(60); $("#p2").outerHeight(70)； console.log($("#p2").height()); console.log($("#p2").innerHeight()); console.log($("#p2").outerHeight()); &#125;)&lt;/script&gt; 三：width( ) innerWidth( ) outerWidth( )也是一样的道理。 四：这些方法对隐藏元素和显示元素均有效。 五：如果获取的元素是一个节点列表，那么可以获取或者设置该列表元素的额第一个元素的宽高； 六 ：window对象的尺寸 js 中有三种方法能够确定浏览器窗口的尺寸（浏览器的视口，不包括工具栏F12和滚动条）。123456789101112对于Internet Explorer、Chrome、Firefox、Opera 以及 Safari- window.innerHeight - 浏览器窗口的内部高度 - window.innerWidth - 浏览器窗口的内部宽度 对于 Internet Explorer 8、7、6、5：- document.documentElement.clientHeight - document.documentElement.clientWidth 或者- document.body.clientHeight - document.body.clientWidth //封装一个兼容各个浏览的代码var height = window.innerHeight||document.documentElement.clientHeight||document.body.clientHeightvar width = window.innerWidth || document.documentElement.clientWidth || docuemnt.body.clientWidth jQuery中1$(window).height() $(window),width() ;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[the performance optimization of the JS code]]></title>
      <url>%2F2016%2F04%2F17%2F84-Javascritp%E4%BB%A3%E7%A0%81%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95%2F</url>
      <content type="text"><![CDATA[Javascritp代码性能优化1 代码性能测试 : 简单方法 根据运行前后的时间来判断1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang="en"&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script&gt; //先定义一个数组 var arr = [];// console.log(Boolean(arr)); for(var i = 0,len = 10000 ;i &lt; len ; i++)&#123; arr.push(i); &#125; //定义一个函数累加求和 var sum = 0 ;//全局的sum变量 function loopFor (arr)&#123; for(var i = 0 ; i &lt; arr.length ; i++)&#123; sum += arr[i] &#125; &#125; //定义一个递归方法删除数组,shift()函数删除数组第一个函数，并返回删除元素 function loopShift(arr) &#123; if (!!arr.length) &#123; sum += arr.shift(); arguments.callee(arr); &#125; &#125; //定义一个测试性能的函数 function test (fn,param)&#123; //记录开始执行函数的时间 var start = new Date().getTime(); //开始执行函数 fn(param); //记录结束执行函数的时间 var end = new Date().getTime(); //输出执行结果 console.log("sum="+sum+";"+"执行时间是"+(end - start)+"ms"); &#125; //分贝执行，看下效果// test(loopFor,arr); //我电脑上大概0~1 ms test(loopShift,arr);//这个大概10ms&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 综合来看，递归这种方法还是十分消耗性能的 2 浏览器开发者工具提供性能分析开发者工具—-profiles —-Record Javascript CPU Profile 3 javascript性能优化 async 设置或返回是否脚本一旦可用，就应异步执行。 charset 设置或返回脚本的 charset 属性值。 cross Origin 设置或返回脚本的 CORS 设置。 defer 设置或返回当页面完成解析后是否执行脚本。 src 设置或返回脚本的 src 属性值。 text 设置或返回属于脚本子节点的所有文本节点的内容。 type 设置或返回脚本的 type 属性值。 当浏览器解析页面的时候，遇到了javascript代码，无论该代码是在内嵌式文件中还是在外链式文件中，页面的加载和渲染都必须停止下来等待脚本执行完毕，因为脚本可能改变页面或者javascript的命名空间； 改善性能的方法： 3.1 为了不影响页面的渲染，尽量将script标签放在body的底部 3.2 每个script标签在加载的时候，都会阻塞页面渲染，所以减少页面包含的script标签数量有助于改善这一情况；包括减少内嵌式或者外链式的script标签；async 属性规定一旦脚本可用，则会异步执行。类似于告诉浏览器链接进来的脚本不糊生成文档内容，因此浏览器可以在下载脚本的时候继续解析和渲染文档； 注释：async 属性仅适用于外部脚本（只有在使用 src 属性时）。 注释：有多种执行外部脚本的方法： 如果 async=”async”：脚本相对于页面的其余部分异步地执行（当页面继续进行解析时，脚本将被执行） 如果不使用 async 且 defer=”defer”：脚本将在页面完成解析时执行 如果既不使用 async 也不使用 defer：在浏览器继续解析页面之前，立即读取并执行脚本 3.3 动态创建脚本 文档对象模型允许我们使用javascript动态创建HTML的几乎全部文档内容，script标签和页面中的其他元素一样，很容易被创建； 12345var script =document.createElement("script");script.type = "text/javascript";script.src = 'script1.js';document.getElementsByTagName("head")[0].appendChild(script);//getElementsByTagName获取到的是一个nodeList(一个伪数组) 12345678 var script =document.createElement("script"); script.type = "text/javascript"; script.onload = function()&#123; console.log("script is loaded"); &#125; script.src = 'script1.js'; document.getElementsByTagName("head")[0].appendChild(script);//通过监听onload事件加载script脚本 123456789101112//对于比较** 的IE有着另外一种实现方式 script有一个属性 readyState var script = document.createElement("script");script.type = "text/javascript";script.onreadystatechange = function()&#123; if(script.readyState == 'loaded' || script.readyState == "complete")&#123; script.onreadystatechange = null; console.log("script is loaded"); &#125;&#125;;script.src = "script1.js";//script的readyState的属性值随着外部下载文件的过程而改变；//uninitialized loading loaded interactive complete 如果想要实现兼容，我们需要封装一个代码 123456789101112131415161718192021function loadScript (url,callback)&#123; var script = document.createELement("script"); script.type = "text/javascript"; if(script.readyState )&#123; //表示是IE script.onreadystatechange = function()&#123; if(script.readyState == 'loaded' || script.readyState == "complete")&#123; script.onreadystatechange = null;//不在使用的函数需要清除掉，减少对内存的占用 callback(); &#125; &#125; &#125;else&#123; script.onload = function()&#123; callback(); &#125; &#125; script.src = url ; document.getElementsByTagName("head")[0].appendChild(script); &#125;loadScript('script1.js',function()&#123; console.log("script1.js is loaded");&#125;) 3.4 通过对XHR发送请求，加载javascript脚本 1234567891011var xhr = new XMLHttpRequest();xhr.open('get','script1.js','true');xhr.onreadystatechange = function()&#123; if(xhr.status &gt;=200 &amp;&amp; xhr.status &lt;300 || xhr.status == 304)&#123; var script = document.createElement("script"); script.type = "text/javascript"; script.text = xhr.responseText; document.body.appendChild(script); &#125;&#125;;//有个缺点就是javascript文件必须与页面同域，不能从CDN(Content Delivery Network)下载 4 内存管理虽然javascript具有垃圾回收机制，但是为了让页面具有更好地性能，还是需要进行内存的优化；对于局部变量，在其执行完毕之后，会被自动清除(闭包除外)，但是对于全局变量以及全局的函数，如果数据不再使用，最好通过设置为null的形式进行手动接触占用]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Ajax(Asynchronous JavaScript and XML)]]></title>
      <url>%2F2016%2F04%2F17%2F65js%E5%92%8CjQuery%E7%9A%84%20%20AJAX%20%20%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%2F</url>
      <content type="text"><![CDATA[一:Ajax(Asynchronous JavaScript and XML)客户端:发送请求，确定请求方式以及处理请求的URL,发送给服务器——&gt;&gt;ajxa(javascript+XMLHttpRequset):作为媒介，xhr的open() send() 以及onreadystatechange()方法处理客户端和服务器之间的联系&lt;&lt;——服务器:处理请求，后台程序处理数据，返回给客户端;可以实现异步交互。 同步交互:客户端向服务器发送请求，客户端的页面进行响应，刷新页面 异步交互:客户端向服务器发送请求，客户端的页面进行响应，并不会刷新页面。 (这个是我们对于页面感官上感受) 从浏览器和服务器之间来理解同步和异步 同步:浏览器发送请求，等待服务器的响应，等服务器返回响应，然后浏览器继续执行 异步:浏览器通过javascript内置XMLHttpRequest对象向服务器发送请求，不等待服务器响应，浏览器继续执行代码，等服务器状态改变，onreadystatechange监听到改变，会执行回调函数； Ajax 采用一种沙箱安全模型。因此，Ajax 代码（具体来说就是 XMLHttpRequest 对象）只能对所在的同一个域发送请求 我们需要检测并判断响应头的MIME类型后确定使用request.responseText或者request.responseXML JS——Ajax1 ajax的要点是XMLHttpRequset对象,根据不同浏览器兼容性，下面代码可以创建兼容性极强的XMLHttpRequset对象 123456789101112131415161718192021222324&lt;script type="text/javascript"&gt;function GetXmlHttpObject()&#123; var xmlHttp=null; try &#123; // Firefox, Opera 8.0+, Safari xmlHttp=new XMLHttpRequest(); &#125; catch (e) &#123; // Internet Explorer try &#123; xmlHttp=new ActiveXObject("Msxml2.XMLHTTP"); &#125; catch (e) &#123; xmlHttp=new ActiveXObject("Microsoft.XMLHTTP"); &#125; &#125; return xmlHttp;&#125;&lt;/script&gt; 2 XMLHttpRequest对象重要的属性 readystate存储着服务器相应状态的信息每当服务器响应状态改变的时候，onreadystatechange函数就会被执行 status由服务器返回的HTTP状态代码 200一切正常 404 NOT FOUND 403 Forbidden statusText由服务器返回的HTTP状态描述，比如200 “OK” 404 “NOT FOUND” 以上三个当响应不完成的时候，可以通过输出它们判断问题所在 12345678910xhr.onreadystatechange = function()&#123; if(xhr.readyState == 4 )&#123; //代表服务器已经完全接受响应 if(xhr.status == 200 )&#123; //代表服务器响应状态OK sone code &#125;else&#123; alert("status is "+xhr.status) ; &#125; &#125;&#125;//以上代码可以用来检测状态码的问题 当readyState小于3的时候，status statusText 读取这些属性会导致一个异常。(注意S大写) 0 Uninitialized 初始化状态。XMLHttpRequest 对象已创建或已被 abort() 方法重置。 1 Open open() 方法已调用，但是 send() 方法未调用。请求还没有被发送。 2 Sent send() 方法已调用，HTTP 请求已发送到 Web 服务器。未接收到响应。 3 Receiving 所有响应头部都已经接收到。响应体开始接收但未完成。 4 Loaded HTTP 响应已经完全接收。 onreadystatechange属性存有服务器响应的函数，readyState数字每次改变都会执行该函数； 1xmlHttp.onreadystatechange = function()&#123; &#125;; responseText 用来获取由服务器返回的数据,返回字符串形式 ；(json格式)或者如果还没有接收到数据的话，就是空字符串 。 responseXML 与 responseText 以字符串 返回 HTTP 响应不同，responseXML 以 XML 返回响应。 1responseXML 属性返回 **XML 文档对象** ，可使用节点树的方法和属性来检查和解析该对象;这些从数据库中选取的数据将被转换为 XML 文档，然后我们将使用 DOM 来提取要显示的值。 所谓的服务器返回的数据，其实就是echo 输出的内容(这个内容就是服务器端的响应体)，如果响应体是XML格式的文本，则需要用responseXML，如果响应体是字符串格式的文本，则需要用responseText来获取响应的内容； 3 XMLHttpRequest对象的重要方法:如何将请求发送到服务器 3.1 open( type,url,async) type代表客户端向服务器发送数据的方式，url代表服务器处理客户端发送数据的程序，async代表是异步处理还是同步处理，默认是true，异步处理，false是同步处理; open(HEAD,url,true) , 3.2 setRequestHeader(‘Content-Type’,’application/x-www-form-urlencoded’); getAllResponseHeaders() 12使用open(&quot;post&quot;,url)的时候必须这样设置；表示相应返回的资源格式get请求可以不设置；setRequestHeader() 方法指定了一个 HTTP 请求的头部，它应该包含在通过后续 send() 调用而发布的请求中。这个方法只有当 readyState 为 1 的时候才能调用，在调用了 open() 之后，但在调用 send() 之前。 3.3 send( string ),将请求发往服务器;send() 把 readyState 设置为 2，并触发 onreadystatechange 事件句柄。必须在open()方法之后才能调用 ; 注意:添加一个随机数，以防服务器使用缓存的文件 3.4 栗子解释: get请求 请求发送给服务器的数据直接附在URL地址的后面 12xmlhttp.open("GET","demo_get2.asp?fname=Bill&amp;lname=Gates&amp;r="+Math.random(),true);xmlhttp.send(); post请求 请求发送的数据在send(string) ； 123xmlhttp.open("POST","ajax_test.asp",true);xmlhttp.setRequestHeader("Content-type","application/x-www-form-urlencoded");xmlhttp.send("fname=Bill&amp;lname=Gates&amp;r="+Math.random()); async 异步处理 (true) 同步处理(false) 1234567891011121314//async = true ;需要规定响应处于 onreadystatechange 事件中的就绪状态时执行的函数：xmlhttp.onreadystatechange=function() &#123; if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200) &#123; document.getElementById("myDiv").innerHTML=xmlhttp.responseText; &#125; &#125;xmlhttp.open("GET","test1.txt",true);xmlhttp.send();//async =false ; 规定必须在响应完成之后才能执行javascript,此时不需要编写onreadystatechange,javascript代码紧跟在send()之后便可以;xmlhttp.open("GET","test1.txt",false);xmlhttp.send();document.getElementById("myDiv").innerHTML=xmlhttp.responseText; 4 XMLHttpRequest对象监听服务器变化 onreadystatechanges属性发生变化的时候，可以执行函数体；responseText和responseXML得到响应体。 5 XMLHttpRequest是javascript的一个内置对象，这个对象可以用来给后台服务器发送数据，同时接受后台返回来的数据，通过javascript动态的操作返回的数据，从而实现了交互的友好型，不会再反复的刷新页面。因为之前发送请求的时候，都是通过document对象发送请求，所以会刷新页面，后来直接用XHR发送请求，则不会再刷新页面了； jQuery— Ajax1 ajax方法里面封装了底层的XMLHttpRequest对象，建立了发送请求和响应请求的过程，并且在发送请求和得到响应这个过程中定义了一系列的函数的函数; 2 jQuery Ajax是一个十分强大的封装体，ajax所有的技术基本上都可以设置，一个$.ajax(url,settings)基本上可以处理大部分服务器和客户端的通信； 3 下面一步步来用栗子了解 jQuery-Ajax底层实现原理；(有关XMLHttpRequest对象的兼容上面以及解释过，此处不再做兼容) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546obj = &#123;"type":"GET","data":"data","URL":"url"&#125;var $ = &#123; ajax : function(obj)&#123; var xhr = new XMLHttpRequest(); if(typeof obj.data === "object")&#123; //因为data有可能是一个对象，将data自动转化为字符串; var str = this.params(obj.data);//将data转化为字符串，这个就是 jQuery底层发送到服务器的数据。将自动转换为请求字符串格式的原理； obj.data= str ; &#125; if(obj.type == "GET")&#123; obj.url = obj.url+"?"+obj.data; obj.data = null ; &#125; xhr.open(obj.type,obj.url,true); if(obj.type =="POST")&#123; xhr.setRequestHeader("Content-Type", "application/x-www-form-urlencoded"); &#125; xhr.send(obj.data); xhr.onreadystatechange = function()&#123; //每次readyState值变化的时候，都活触发这个onreadystatechange监听器，所以要设定一些条件，来限制函数体的执行， if(xhr.readyState == 4)&#123; //响应完成 if(xhr.status == 200) &#123; //状态ok var res = xhr.responseText ;//(如果返回是XML类型的数据，则用 xhr.responseXML接受) var resObj = JSON.parse(res);//这个就是jQuery底层实现：当dataType设置为json的时候，返回的数据类型是javascript对象; obj.sucess(resObj); &#125;else&#123; obj.reeor(); &#125;else&#123; obj.complete(); &#125; &#125; &#125;; &#125;, params: function (obj) &#123; var str = ""; for (var key in obj) &#123; //console.log(key); str += key + "=" + obj[key] + "&amp;" &#125; console.log(str); str = str.substr(0, str.length - 1); console.log(str); return str; &#125;&#125; 4 用法 语法: $.ajax({ URL [settings] }) 传入键值对形式的设置和URL 1234$.ajax (&#123; url : "url" , //表示要访问的服务器后台地址 settings : //以下详细说明settings设置&#125;) settings 设置 dataType : 请求服务器返回的数据类型； “text”: 返回纯文本字符串 “xml”: 返回 XML 文档，可用 jQuery 处理。 “html”: 返回纯文本 HTML 信息；包含的script标签会在插入dom时执行。 “script”: 返回纯文本 JavaScript 代码。不会自动缓存结果。除非设置了”cache”参数。’’’注意：’’’在远程请求时(不在同一个域下)，所有POST请求都将转为GET请求。(因为将使用DOM的script标签来加载) “json”: 返回 JSON 数据 ，服务器返回javascript对象;即经过JSON.parse()解析成javascript对象 “jsonp” : 如果跨域的话，这个时候就不是XMLHttpRequest对象发送请求了，而是script标签发送请求，服务器返回的script代码会直接执行 表示可以进行跨域请求；使用这种类型的话，会创建一个查询字符串参数 callback=? ，这个参数会加在请求的URL后面。服务器端应当在JSON数据前加上回调函数名，以便完成一个有效的JSONP请求。如果要指定回调函数的参数名来取代默认的callback 如果指定了text html javascript 则将返回字符串；如果指定了XML 则将返回XML格式的数据，可以用XML DOM 对象操作 我们必须确保网页服务器报告的MIME类型与我们选择的dataType所匹配。比如说，如果我们将dataType设置为xml，则要求服务器返回xml类型的数据，服务器端就必须声明 text/xml 或者 application/xml 来获得一致的结果。 12345&lt;?php $callback=$_GET['back']; $data='&#123;"username":"zhangsanlisiwangwsu"&#125;'; echo $callback."(".$data.")";?&gt; situation: 123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script&gt; function getInfo(obj)&#123; console.log(obj); &#125; &lt;/script&gt; &lt;script src="js/jquery-1.12.4.js"&gt;&lt;/script&gt; &lt;script&gt; $.ajax(&#123; url:"04jsonp.php?callback=getInfo", type:"GET", dataType:"jsonp",//如果没有这行代码，就是返回纯文本的javascript代码 //既支持跨域资源，也支持本地资源，服务器返回的以javascript代码直接执行 //&#123; username: "zhangsanlisiwangwsu" &#125; success:function(res)&#123; console.log(res); &#125; &#125;) &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; jsonp : 在一个jsonp请求中重写回调函数的名字。这个值用来替代在”callback=?”中的 callback jsonpCallback : 为jsonp请求指定一个回调函数名。这个值将用来取代jQuery自动生成的随机函数名。 1234567891011 $.ajax(&#123; url:'http://study.com/data.php', dataType : 'jsonp', jsonpCallback:"myCall", jsonp:"funcName", success:function(data)&#123; &#125; &#125;)// ?funcName=myCall&amp;_=1488624180015 //如果不设置 jsonp和 jsonpCallback // ?callback=jQuery111103367937101396201_1488624279118&amp;_=1488624279119 type : jQuery默认 GET 其他值 POST ,规定请求的方式； async Boolean (默认: true) 默认设置下，所有请求均为异步请求。如果需要发送同步请求，请将此选项设置为 false。注意，同步请求将锁住浏览器，用户其它操作必须等待请求完成才可以执行。 cache : 默认为true ，缓存 ，dataType : jsonp script 的时候默认为false data : 传递给服务器的数据 ，如果是对象，则自动转化为字符串；必须为key/value 格式，如果value值是数组，则将为相应 的key对应每个数组的值；如果是GET请求，需要将参数附在url之后 12data:&#123; "name":"Jhon", "age":[13,14] &#125;,jQuery将解析成这样的字符串 : ?name=Jhon&amp;age%5B%5D=13&amp;age%5B%5D=14 传递给服务器； 必须 为 data: { “name”:”Jhon”,”age”:14 } 这种格式，其他的都会报错； 即使 是data: ‘ {“name”:”Jhon”,”age”:15} ‘ 这种形式，发送到服务器的数据有误； 当以键值对的对象发送给后台数据的时候，可以被转化为JSON的数据格式，key值方便后台查询 processData : (默认: true) 默认情况下，通过data选项传递进来的数据，如果是一个对象(技术上讲只要不是字符串)，都会处理转化成一个查询字符串，以配合默认内容类型“application/x-www-form-urlencoded”。如果要发送 DOM 树信息或其它不希望转换的信息，请设置为 false。 发送 XML 数据至服务器。设置 processData 选项为 false，防止自动转换数据格式。 jsonp : JSON with padding 底层实现原理其实就是动态的创建标签，然后利用scritp的src属性不受同源策略的约束来跨域获取数据； timeout : 设置请求超时时间，以毫秒计；比如设置了 timeout:3000,如果服务器3 秒内没有响应的阿虎，那么则断开这个请求链接； success : function( data,textStatus,XHR){ } 请求成功才会执行该函数体，从服务器返回的数据直接返回给该函数的参数；参数：由服务器返回，并根据dataType参数进行处理后的数据；描述状态的字符串 注意:此时返回的data的类型由dataType 决定，html text script返回的是 字符串类型的文本； ​ json 会返回javascript对象 ; xml 会返回xml 文档 ； beforeSend : function( XHR ){ } 传入一个xhr对象，包含XMLHttpRequset相关的属性详细的信息； 12345&lt;?php echo "ok"; echo $_GET["name"]; echo $_GET["age"];?&gt; 123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang="en"&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;input type="button" value="触发ajax"/&gt;&lt;script src="jquery-1.12.4.js"&gt;&lt;/script&gt;&lt;script&gt; $.ajax(&#123; url:"05-ajxacallback.php", type:"GET", data:&#123;"name":"Jhon","age":15&#125;,// data:&#123;// "name":"Jhon",// "age":[13,14]// &#125;,//不能这种形式 // ?name=Jhon&amp;age%5B%5D=13&amp;age%5B%5D=14// data :&#123;// "name":[&#123;"name":"Jhon","age":14&#125;]// &#125; ,不能这种形式 dataType:"html", //可以改变属性值， beforeSend:function()&#123; console.log(arguments); &#125;, complete:function()&#123; console.log(arguments); &#125;, success:function(res)&#123; console.log(res); console.log(typeof res); console.log(arguments); &#125; &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 如果请求的数据类型和返回的数据类型不同的话，则不会执行success函数]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[the Methods of String]]></title>
      <url>%2F2016%2F04%2F11%2F106-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93%2F</url>
      <content type="text"><![CDATA[字符串的方法总结(注意字符串的不可变性)1 str.charAt(index) : 返回位于index处的字符 ；如果index不在0和str.length-1之间那么返回一个空字符 ； 2 str.charCodeAt(index): 返回位于index处的字符的Unicode编码，如果index不在0和str.length-1之间，那么返回NaN ； 3 str.indexOf(searchvalue,fromindex) : 返回被检索字符串第一次出现的位置值，如果找不到返回 -1,注意对大小写敏感 stringObject 中的字符位置是从 0 开始的。 1console.log('item?'.indexOf('?'));//4 正则 str.search(refexp) 不执行全局匹配，返回被检索字符第一次出现的位置值 如果找不到，返回-1 ; 4 str.slice(start,end) 不改变原字符串，返回一个新的字符串 ，包括起始位置，不包括end位置，end省略则直到字符串末尾；-1表示最后一个字符；和substr(start,end) substring(start,stop)效果类似 注意索引值从0 开始 包括起始位置字符，不包括结尾的字符 123var str = "abcdef"; console.log(str.substring(1));//bcd console.log(str.slice(1));//bcd 5 str.split(seperate,howmany) : 不改变原字符串，返回一个数组 ，该数组中保存了被分割的字符串，howmany设置数组中的元素的个数； 1234567891011var str = 'www.baidu.com?name=Jhon&amp;age=15'; console.log(str.indexOf('?')); var newArr = str.slice(str.indexOf('?')+1).split('&amp;'); console.log(newArr); console.log(newArr[0].substring(0,4)); console.log(newArr[0].substring(5,9)); for(var i = 0 ; i &lt; newArr.length ; i++)&#123; if(newArr[i].substring(0,5) == 'name=')&#123; document.write('&lt;p&gt;welcome '+newArr[i].substring(5,9)+'&lt;/p&gt;') &#125; &#125; 6 str.concat(str1,str2····) : 不改变原字符串，返回一个新的字符串； 7 正则 str.match(value) str.match(regexp) 不改变原来的字符串，找到匹配则返回匹配的数组 ，找不到匹配则返回null match() 方法将检索字符串 stringObject，以找到一个或多个与 regexp 匹配的文本。这个方法的行为在很大程度上有赖于 regexp 是否具有标志 g。 如果 regexp 没有标志 g，那么 match() 方法就只能在 stringObject 中执行一次匹配。如果没有找到任何匹配的文本， match() 将返回 null。否则，它将返回一个数组，其中存放了与它找到的匹配文本有关的信息。该数组的第 0 个元素存放的是匹配文本，而其余的元素存放的是与正则表达式的子表达式匹配的文本。除了这些常规的数组元素之外，返回的数组还含有两个对象属性。index 属性声明的是匹配文本的起始字符在 stringObject 中的位置，input 属性声明的是对 stringObject 的引用。 如果 regexp 具有标志 g，则 match() 方法将执行全局检索，找到 stringObject 中的所有匹配子字符串。若没有找到任何匹配的子串，则返回 null。如果找到了一个或多个匹配子串，则返回一个数组。不过全局匹配返回的数组的内容与前者大不相同，它的数组元素中存放的是 stringObject 中所有的匹配子串，而且也没有 index 属性或 input 属性。 注意：在全局检索模式下，match() 即不提供与子表达式匹配的文本的信息，也不声明每个匹配子串的位置。 如果需要这些全局检索的信息，可以使用 RegExp.exec()。 12345var str = 'av fgf df'; console.log(str.match('f'));//["f", index: 3, input: "av fgf df"] 返回一个数组，包含匹配字符的详细信息 console.log(str.match('f')[0]);//f console.log(str.match('f').index);//3 console.log(str.match(/f/g));//["f", "f", "f"] 8 正则 str.replace(str/regexp , replacement | function) ; 不改变原字符串，返回一个新的字符串； 8.1 如果 regexp 具有全局标志 g，那么 replace() 方法将替换所有匹配的子串。否则，它只替换第一个匹配子串。 1234var str = "Jhon Jim";var newStr = str.replace(/J/,'G')console.log(str);//"Jhon Jim"console.log(newStr);//"Ghon Jim" 1234var str = "Jhon Jim";var newStr = str.replace(/J/g,'G')console.log(str);//"Jhon Jim"console.log(newStr);//"Ghon Gim" 8.2 $ 1,2,3,4……99 表示与正则表达式第1 到99个子表达式相匹配的文本；子表达式是用( )括起来的那部分 123var name = "Doe, John";var newName = name.replace(/(\w+)\s*, \s*(\w+)/, "$2 $1");console.log(newName);//John Doe 8.4 如果replace第二个参数没有传递，那么默认传入undefined 1console.log('str'.replace('r')); //stundefined 9 str.trim( ) 方法可以用来去掉字符串中的前面和后面的空格，底层实现 1234String.prototype.trim = String.prototype.trim || function()&#123; if(!this) return this; return this.replace(/^\s+|\s+$/g,"");//使用正则表达式将空格替换为空字符串 &#125; 记住，String 对象的所有属性和方法都可应用于 String 原始值上，因为它们是伪对象。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[js乱炖]]></title>
      <url>%2F2016%2F04%2F11%2F109-js%E4%B9%B1%E7%82%96%2F</url>
      <content type="text"><![CDATA[1 逗号操作符：返回最后一个操作数,逗号运算符会先执行左侧表达式，然后执行右侧表达式然后执行右侧表达式并且以右侧表达式的计算结果作为返回值 123456789101112131415161718192021222324252627282930313233 // Note that the following creates globals and is disallowed in strict mode. a = b = 3, c = 4; // Returns 4 in console console.log(a); // 3 (left-most) console.log(a = b = 3, c = 4);//3 4 console.log((a = b = 3, c = 4));//4 x = (y = 5, z = 6); // Returns 6 in console console.log(x); // 6 (right-most) //------------------------------------ x = (y = 5, z = 6,z=5); // Returns 6 in console console.log(x); // 5 (right-most)//-----------------------------------function myFunc() &#123; var x = 0; return (x += 1, x); // the same as return ++x; &#125; console.log(myFunc());//1//-------------------------------------- var x = 20; var temp = &#123; x: 40, foo: function() &#123; var x = 10; return this.x; &#125; &#125;; var res = (temp.foo, temp.foo)(); // 20，而不是40 console.log(res);//20 var res = ( 1,temp.foo)(); // 20，而不是40 console.log(res);//20 2 常用hack技巧 12345678910111213141516171819202122* png24位的图片在iE6浏览器上出现背景，解决方案是做成PNG8.* 浏览器默认的margin和padding不同。解决方案是加一个全局的*&#123;margin:0;padding:0;&#125;来统一。* IE6双边距bug:块属性标签float后，又有横行的margin情况下，在ie6显示margin比设置的大。 浮动ie产生的双倍距离 #box&#123; float:left; width:10px; margin:0 0 0 100px;&#125; 这种情况之下IE会产生20px的距离，解决方案是在float的标签样式控制中加入 ——_display:inline;将其转化为行内属性。(_这个符号只有ie6会识别) 渐进识别的方式，从总体中逐渐排除局部。 首先，巧妙的使用“\9”这一标记，将IE游览器从所有情况中分离出来。 接着，再次使用“+”将IE8和IE7、IE6分离开来，这样IE8已经独立识别。 css .bb&#123; background-color:red;/*所有识别*/ background-color:#00deff\9; /*IE6、7、8识别*/ +background-color:#a200ff;/*IE6、7识别*/ _background-color:#1e0bd1;/*IE6识别*/ &#125; 123456789101112131415* IE下,可以使用获取常规属性的方法来获取自定义属性, 也可以使用getAttribute()获取自定义属性; Firefox下,只能使用getAttribute()获取自定义属性。 解决方法:统一通过getAttribute()获取自定义属性。* IE下,even对象有x,y属性,但是没有pageX,pageY属性; Firefox下,event对象有pageX,pageY属性,但是没有x,y属性。* 解决方法：（条件注释）缺点是在IE浏览器下可能会增加额外的HTTP请求数。* Chrome 中文界面下默认会将小于 12px 的文本强制按照 12px 显示, 可通过加入 CSS 属性 -webkit-text-size-adjust: none; 解决。超链接访问过后hover样式就不出现了 被点击访问过的超链接样式不在具有hover和active了解决方法是改变CSS属性的排列顺序:L-V-H-A : a:link &#123;&#125; a:visited &#123;&#125; a:hover &#123;&#125; a:active &#123;&#125; 3 其他小结 CSS里的visibility属性有个collapse属性值是干嘛用的？在不同浏览器下以后什么区别？ 对于普通元素visibility:collapse;会将元素完全隐藏,不占据页面布局空间,与display:none;表现相同.如果目标元素为table,visibility:collapse;将table隐藏,但是会占据页面布局空间.仅在Firefox下起作用,IE会显示元素,Chrome会将元素隐藏,但是占据空间. position跟display、margin collapse、overflow、float这些特性相互叠加后会怎么样？ 如果元素的display为none,那么元素不被渲染,position,float不起作用,如果元素拥有position:absolute;或者position:fixed;属性那么元素将为绝对定位,float不起作用.如果元素float属性不是none,元素会脱离文档流,根据float属性值来显示.有浮动,绝对定位,inline-block属性的元素,margin不会和垂直方向上的其他元素margin折叠. 对BFC规范(块级格式化上下文：block formatting context)的理解？ （W3C CSS 2.1 规范中的一个概念,它是一个独立容器，决定了元素如何对其内容进行定位,以及与其他元素的关系和相互作用。） 一个页面是由很多个 Box 组成的,元素的类型和 display 属性,决定了这个 Box 的类型。 不同类型的 Box,会参与不同的 Formatting Context（决定如何渲染文档的容器）,因此Box内的元素会以不同的方式渲染,也就是说BFC内部的元素和外部的元素不会互相影响 请解释一下为什么需要清除浮动？清除浮动的方式 清除浮动是为了清除使用浮动元素产生的影响。浮动的元素，高度会塌陷，而高度的塌陷使我们页面后面的布局不能正常显示。 123456789101112131415161718192021222324252627282930311、父级div定义height；2、父级div 也一起浮动；3、常规的使用一个class； .clearfix:before, .clearfix:after &#123; content: &quot; &quot;; display: table; &#125; .clearfix:after &#123; clear: both; &#125; .clearfix &#123; *zoom: 1; &#125;4、SASS编译的时候，浮动元素的父级div定义伪类:after &amp;:after,&amp;:before&#123; content: &quot; &quot;; visibility: hidden; display: block; height: 0; clear: both; &#125;解析原理：1) display:block 使生成的元素以块级元素显示,占满剩余空间;2) height:0 避免生成内容破坏原有布局的高度。3) visibility:hidden 使生成的内容不可见，并允许可能被生成内容盖住的内容可以进行点击和交互;4）通过 content:&quot;.&quot;生成内容作为最后一个元素，至于content里面是点还是其他都是可以的，例如oocss里面就有经典的 content:&quot;.&quot;,有些版本可能content 里面内容为空,一丝冰凉是不推荐这样做的,firefox直到7.0 content:”&quot; 仍然会产生额外的空隙；5）zoom：1 触发IE hasLayout。通过分析发现，除了clear：both用来闭合浮动的，其他代码无非都是为了隐藏掉content生成的内容 CSS优化、提高性能的方法有哪些？ 1234关键选择器（key selector）。选择器的最后面的部分为关键选择器（即用来匹配目标元素的部分）；如果规则拥有 ID 选择器作为其关键选择器，则不要为规则增加标签。过滤掉无关的规则（这样样式系统就不会浪费时间去匹配它们了）；提取项目的通用公有样式，增强可复用性，按模块编写组件；增强项目的协同开发性、可维护性和可扩展性;使用预处理工具或构建工具（gulp对css进行语法检查、自动补前缀、打包压缩、自动优雅降级）； 浏览器是怎样解析CSS选择器的？12样式系统从关键选择器开始匹配，然后左移查找规则选择器的祖先元素。只要选择器的子树一直在工作，样式系统就会持续左移，直到和规则匹配，或者是因为不匹配而放弃该规则。 ::before 和 :after中双冒号和单冒号 有什么区别？解释一下这2个伪元素的作用。 12345678单冒号(:)用于CSS3伪类，双冒号(::)用于CSS3伪元素。（伪元素由双冒号和伪元素名称组成）双冒号是在当前规范中引入的，用于区分伪类和伪元素。不过浏览器需要同时支持旧的已经存在的伪元素写法，比如:first-line、:first-letter、:before、:after等，而新的在CSS3中引入的伪元素则不允许再支持旧的单冒号的写法。想让插入的内容出现在其它内容前，使用::before，否者，使用::after；在代码顺序上，::after生成的内容也比::before生成的内容靠后。如果按堆栈视角，::after生成的内容会在::before生成的内容之上 BFC(Block formatting context)直译为”块级格式化上下文”。它是一个独立的渲染区域，只有Block-level box参与， 它规定了内部的Block-level Box如何布局，并且与这个区域外部毫不相干。 BFC布局规则： 内部的Box会在垂直方向，一个接一个地放置。 Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠 每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。 BFC的区域不会与float box重叠。 BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。 计算BFC的高度时，浮动元素也参与计算 哪些元素会生成BFC: 根元素 float属性不为none position为absolute或fixed display为inline-block, table-cell, table-caption, flex, inline-flex overflow不为visible 如果需要手动写动画，你认为最小时间间隔是多久，为什么？（阿里） 1多数显示器默认频率是60Hz，即1秒刷新60次，所以理论上最小间隔为1/60＊1000ms ＝ 16.7ms 什么是CSS 预处理器 / 后处理器？ 12345- 预处理器例如：LESS、Sass、Stylus，用来预编译Sass或less，增强了css代码的复用性， 还有层级、mixin、变量、循环、函数等，具有很方便的UI组件模块化开发能力，极大的提高工作效率。- 后处理器例如：PostCSS，通常被视为在完成的样式表中根据CSS规范处理CSS，让其更有效；目前最常做的 是给CSS属性添加浏览器私有前缀，实现跨浏览器兼容性的问题。 说几条写JavaScript的基本规范？ 1234567891.不要在同一行声明多个变量。2.请使用 ===/!==来比较true/false或者数值3.使用对象字面量替代new Array这种形式4.不要使用全局函数。5.Switch语句必须带有default分支6.函数不应该有时候有返回值，有时候没有返回值。7.For循环必须使用大括号8.If语句必须使用大括号9.for-in循环中的变量 应该使用var关键字明确限定作用域，从而避免作用域污染。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[scope以及scopechain]]></title>
      <url>%2F2016%2F04%2F11%2F102-%E4%BD%9C%E7%94%A8%E5%9F%9F%20%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%2F</url>
      <content type="text"><![CDATA[###1 作用域以及作用域链 1 .1作用域 在JavaScript中，我们可以将作用域定义为一套规则,这套规则用来管理引擎如何在当前作用域以及嵌套的子作用域中根据标识符名称进行变量查找。 这里的标识符，指的是变量名或者函数名 JavaScript中只有全局作用域与函数作用域 作用域与执行上下文是完全不同的两个概念。 JavaScript代码的整个执行过程，分为两个阶段，代码编译阶段与代码执行阶段。 编译阶段由编译器完成，将代码翻译成可执行代码，这个阶段作用域规则会确定以及语法分析，词法分析，可执行的代码生成； 执行阶段由引擎完成，主要任务是执行可执行代码，执行上下文在这个阶段创建以及垃圾回收； 1.2 作用域链作用域链，是由当前环境与上层环境的一系列变量对象组成，它保证了当前执行环境对符合访问权限的变量和函数的有序访问。 作用域链在函数执行之前就已经创建 123456789101112131415 var cs = "zero"; function foo()&#123; var cs = "one" ; function innerFoo1 ()&#123; console.log(cs); &#125; return innerFoo1; &#125;//作用域链 全局作用域---&gt; foo函数作用域---&gt; innerFoo1函数作用域，当函数innerFoo1执行的时候，会顺着这条作用域链去找变量，一层一层向上找，直到全局变量对象处，如果找不到，则会抛出 未定义异常 var ret = foo(); //这个返回的是innerFoo1函数 innerFoo1函数执行的时候，现在innerFoo1函数作用域里面找cs变量，找不到的时候，向上一层foo函数作用域找cs变量，这个时候找到了 one,然后输出，结束函数执行； ret(); //one//如果作用域链是在函数执行的时候才创建，那么应该是如下作用域链 //全局作用域---&gt;foo()作用域(其实就是innerFoo1作用域，foo函数执行了)---&gt; //ret()执行后应该输出zero,很明显不是的 1234567891011121314151617 var cs = "zero" ; function innerFoo1 ()&#123; console.log(cs); &#125; function innerFoo2 ()&#123; var cs = "one" ; return innerFoo1; &#125;//创建了两条作用域链(作用域链由函数作用域和全局作用域组成，全局作用域是作用域链的最顶端，变量查找的最后区域)//全局作用域---&gt; innerFoo1作用域---&gt;//全局作用域---&gt; innerFoo2作用域---&gt;//作用域链在执行之前就已经创建var ret = innerFoo2(); //返回的是 innerFoo1函数，这个函数执行的时候，其作用域链已经确定，innerFoo1函数作用域里没有cs变量，然后去全局作用域去找，找到了 zeroret(); //zero 1.3 延长作用域链 123try---catchwith 1.4 需要注意在if语句块和for语句块中声明的变量，是其所运行的环境的内的变量，如果在全局作用域运行for或者if，那么if和for中声明的变量就是全局window的属性，如果在函数内部运行if或者for循环，在if和for循环中声明的变量就是该函数作用域的局部变量；以下栗子，for也是一样的道理； 1234567891011121314if(true)&#123; var color= "blue"; &#125; console.log(color); function f1()&#123; if(true)&#123; var color= "red"; &#125; console.log(color); &#125; f1(); console.log(color); 2 变量声明提升2.1”链式作用域” : 子对象会一级一级地向上寻找所有父对象的变量。所以，父对象的所有变量，对子对象都是可见的，反之则不成立。 123456789101112 var tmp = new Date(); function f() &#123; console.log(tmp);//undefined if (false) &#123; //由于是false不会进入，但是变量的声明还是会提升到函数体内，体内，体内的最上面(重三遍)，所以下面在执行的时候会输出 undefined, var tmp = "hello world"; //函数体内的声明会提升到 函数作用域 的最上面 &#125; console.log(tmp);//undefined &#125; f(); console.log(tmp);//Tue Feb 28 2017 21:24:05 GMT+0800 (中国标准时间)console.log(typeof tmp);//object 123456789101112var tmp = new Date();function f1() &#123; console.log(tmp);//undefined if (true) &#123; //true可以进入 var tmp = "hello world";//var 声明的变量会进行变量声明提升，只是提升到函数作用域最上面，并且只在函数作用域内有效 &#125; console.log(tmp);// hello world&#125; f1();//函数执行的时候 ，输出 undefind 和 hello world console.log(tmp);//Tue Feb 28 2017 21:24:05 GMT+0800 (中国标准时间) console.log(typeof tmp);//object 1234567891011var tmp = new Date();function f2() &#123; console.log(tmp);//Tue Feb 28 2017 21:24:05 GMT+0800 (中国标准时间) if (true) &#123; tmp = "hello world";//不是用var声明的变量，可以看做是全局的变量，当执行到这一行代码的时候，会改变全局变量tmp的值 &#125; console.log(tmp);// hello world &#125; f2(); console.log(tmp);//hello world console.log(typeof tmp);//string 2.2 变量名 形参 函数名重名 12345678910111213141516console.log(typeof a);//funtionfunction a()&#123;&#125; ;var a=10; //-----------------------------------------------function foo(a)&#123; console.log(typeof a); var a =100; function a()&#123;&#125;;&#125;foo(10); //输出function 如果变量名 形参 函数重名 ，还是函数优先//-----------------------------------------------function foo(a)&#123; console.log(typeof a); var a = "string";&#125;foo(10); //输出number 3 执行上下文3.1 函数每次的调用，都会形成一个执行上下文，每次调用都会形成一个新的执行上下文； 3.2 执行上下文 –&gt; 变量对象(变量声明，函数声明，所有形参)+作用域链+this指向 3.3 生成执行上下文有三种情况 全局环境：JavaScript代码运行起来会首先进入该环境 函数环境：当函数被调用执行时，会进入当前函数中执行代码 eval 每个函数都有自己的执行环境，当该函数之心完毕之后，该环境就会被销毁，保存在该函数环境中的变量和变量也会被销毁 全局执行环境直到程序结束，例如关闭网页的时候才会被销毁 1234567891011121314var color = 'blue';function changeColor() &#123; var anotherColor = 'red'; function swapColors() &#123; var tempColor = anotherColor; anotherColor = color; color = tempColor; &#125; swapColors();&#125;changeColor(); 3.4 执行上下文有以下特性: 单线程 同步执行，只有栈顶的上下文处于执行中，其他上下文需要等待 全局上下文只有唯一的一个，它在浏览器关闭时出栈 函数的执行上下文的个数没有限制 每次某个函数被调用，就会有个新的执行上下文为其创建，即使是调用的自身函数，也是如此。 3.5 执行上下文的生命周期 创建阶段在这个阶段中，执行上下文会分别创建变量对象，建立作用域链，以及确定this的指向 代码执行阶段创建完成之后，就会开始执行代码，这个时候，会完成变量赋值，函数引用，以及执行其他代码。 3.6 变量对象的创建 变量对象（Variable Object）变量对象的创建，依次经历了以下几个过程。 建立arguments对象。检查当前上下文中的参数，建立该对象下的属性与属性值。 function声明 检查当前上下文的函数声明，也就是使用function关键字声明的函数。在变量对象中以函数名建立一个属性，属性值为指向该函数所在内存地址的引用。如果函数名的属性已经存在，那么该属性将会被新的引用所覆盖。 var声明 检查当前上下文中的变量声明，每找到一个变量声明，就在变量对象中以变量名建立一个属性，属性值为undefined。如果该变量名的属性已经存在，为了防止同名的函数被修改为undefined，则会直接跳过，原属性值不会被修改。 变量对象在代码执行的时候会变成活动对象 4 走个demo 12345678910111213141516function test() &#123; console.log(foo); console.log(bar); var foo = 'Hello'; console.log(foo); var bar = function () &#123; return 'world'; &#125; function foo() &#123; return 'hello'; &#125;&#125;test(); 1234567// 创建阶段 这个变量对象创建的过程，变量声明提升其实就是变量对象创建过程中完成的VO = &#123; arguments: &#123;...&#125;, foo: &lt;foo reference&gt;, bar: undefined&#125;// 这里有一个需要注意的地方，因为var声明的变量当遇到同名的属性时，会跳过而不会覆盖 1234567// 执行阶段 执行阶段，变量对象---&gt;活动对象VO -&gt; AOVO = &#123; arguments: &#123;...&#125;, foo: 'Hello', bar: &lt;bar reference&gt;&#125; ​]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[javascript中的运算符]]></title>
      <url>%2F2016%2F04%2F11%2F98-Javascript%E4%B8%AD%E8%BF%90%E7%AE%97%E7%AC%A6%2F</url>
      <content type="text"><![CDATA[Javascript中运算符1 一元运算符以及访问 . [] () 字段访问、数组下标、函数调用以及表达式分组 ++ — - + ~ ! delete new typeof void 一元运算符、返回数据类型、对象创建、未定义值 delete可以删除对象的属性值以及方法，将其值为undefined，对于局部变量和方法，以及全局用var声明的变量,delete是没有用的；delete obj.prop ; 如果删除成功，delete x 返回true，否则返回false; 1234a = 6 ; console.log(a);//6 console.log(delete a );//true console.log(a);//报错 1234var a = 6 ; console.log(a);//6 console.log(delete a );//fasle console.log(a);//6 123456789101112 (function()&#123;// 'use strict' //如果在严格模式下会报错 var obj = &#123;&#125;; Object.defineProperty(obj,"name",&#123; value:"Jhon", weitable:true, configable:false,//控制属性是否可以被删除 enumerable:false &#125;) console.log(delete obj.name); //false console.log(obj.name);//Jhon &#125;)() 一元加法(+)和一元减法(-),对于数字来说，就是简单的加减，对于字符串来说，会将字符串转化为数字，类似于parseInt； 2 关系运算符 &gt; &gt;= &lt; &lt;= 返回一个布尔类型的值(带有NaN的比较运算，返回的结果都是false) 2.1 基本数据类型的比较(比较的时候会将对象，数组等转化为原始值) ​ 2.1.1 Number类型比较 直接比较值即可 ,就是常规的算术比较，不做深究， 如果只有一个运算数是数字，那么会隐式的将另外一个运算数转化为数字，然后进行比较；字符串转化为数字，布尔类型转化为数字，对象转化为数字； 1234567//如果有一个是数字类型的，会尽量将另外一个运算数也转化为数字类型 console.log(1 &gt; []);//true 空数组转化为数字是0 ,先将空数组转化为空字符串，然后空字符串转化为 0 console.log(1 &lt; []);//false console.log(1 &lt; &#123;&#125;);//false 对象转化为字符串[object object] 然后转为数字是 NaN 带有NaN的关系运算表达式，返回的结果是false console.log(1 &lt; &#123;&#125;);//false console.log(1 &lt; new Date());//true console.log(1 &gt; new Date());//false ​ 2.1.2 字符串类型比较 对于字符串，第一个字符串中每个字符的代码都与会第二个字符串中对应位置的字符的代码进行数值比较。完成这种比较操作后，返回一个 Boolean 值。 大写字母的代码都小于小写字母的代码 ，所以，如果比较的字符有大写和小写，那么需要将字母字符串进行大小写转化 如果两个运算数都是字符串，比较的是字符串中每一个字符的对应的字符代码 123456789101112131415 console.log("Ball"&lt;"alpha");//true console.log("Ball".toLocaleLowerCase()&lt;"alpha".toLocaleLowerCase());//true console.log('alpha' &lt; "5");//false console.log('alpha' &gt; "5");//true console.log("23" &lt; "5");//true 对于字符串比较的是字符的编码//"2" 的字符代码是 50,"3" 的字符代码是 51 console.log("" &gt; "a");//false 字符串的比较是字符的编码 console.log("" &lt; "a");//true console.log("a" &lt; []);//true console.log("a" &gt; []);//fasle console.log("a" &gt; &#123;&#125;);//true 空对象经过ToPrimitive运算出来的是 '[object Object]' 字符串值，以 'a'.charCodeAt(0) 计算出的值是字符编码是97数字，而 '['.charCodeAt(0) 则是91数字，所以 'a' &gt; (&#123;&#125;) 会是得到true。 console.log("a" &lt; &#123;&#125;);//fasle console.log([1,2,3] &lt; [1,2,4]) ;//true 数组的比较按照字典顺序比较//接下来引出 数字和字符串的比较 console.log(23 &lt; "5");//false 2.1.3 字符串和数字类型比较 会将字符串先转化成数字，将字符串转化成数字的时候，解析器会使用parseInt () parseFloat()将字符串转化为可比较的数字； 布尔类型值和数字类型值比较会将布尔类型转化为数字 2.1.4 复杂数据类型的比较 parseInt()parseInt() 方法首先查看位置 0 处的字符，判断它是否是个有效数字；如果不是，该方法将返回 NaN，不再继续执行其他操作。但如果该字符是有效数字，该方法将查看位置 1 处的字符，进行同样的测试。这一过程将持续到发现非有效数字的字符为止，此时 parseInt() 将把该字符之前的字符串转换成数字。 例如，如果要把字符串 “12345red” 转换成整数，那么 parseInt() 将返回 12345，因为当它检查到字符 r 时，就会停止检测过程。 字符串中包含的数字字面量会被正确转换为数字，比如 “0xA” 会被正确转换为数字 10。不过，字符串 “22.5” 将被转换成 22，因为对于整数来说，小数点是无效字符。 parseFloat()parseFloat() 方法与 parseInt() 方法的处理方式相似，从位置 0 开始查看每个字符，直到找到第一个非有效的字符为止，然后把该字符之前的字符串转换成整数。 不过，对于这个方法来说，第一个出现的小数点是有效字符。如果有两个小数点，第二个小数点将被看作无效的。parseFloat() 会把这个小数点之前的字符转换成数字。这意味着字符串 “11.22.33” 将被解析成 11.22。 1234 //'alpha'转化成数字的时候，会直接返回NaN ，带有NaN的关系运算表达式，返回的结果是falseconsole.log('alpha' &gt; 5);//false console.log('alpha' &lt; 5);//falseconsole.log("22.5" &gt; 22); //true 2.2 == === != !== 比较运算 全等比较 === 不仅仅比较两个运算数的值，还比较两个运算数的数据类型，这个一般容易进行判断 对于 == 比较运算，会对运算数进行隐式转化，转化为原始值进行比较 如果我们要判断两个运算数是否相等的话，最好使用全等，因为 == != 会进行隐式类型转化； 12345678910111213141、如果两个值类型相同，进行 === 比较。 2、如果两个值类型不同，他们可能相等。根据下面规则进行类型转换再比较： a、如果一个是null、一个是undefined，那么[相等]。 b、如果一个是字符串，一个是数值，把字符串转换成数值再进行比较。 c、如果任一值是 true，把它转换成 1 再比较；如果任一值是 false，把它转换成 0 再比较。 console.log([] == true);//fasle console.log([] == false);//true d、如果一个是对象，另一个是数值就把对象转化为数字，另一个是字符串就把对象转化为字符串对象转换成基础类型，利用它的toString或者valueOf方法。js核心内置类，会尝试valueOf先于toString；例外的是Date，Date利用的是toString转换。非js核心的对象 e、任何其他组合，都[不相等]。 12console.log([] == ![]);//true 对于对象类型的比较，会发生隐式类型的转化，这里还要注意运算符的优先级 ！比== 的优先级要高，所以 ！[]为false,含有布尔类型的会转化为 false会转化为0 ，[]也会转化为0console.log(![]);//false 3 + - 运算符3.1 + 运算符 以下有两种情况(执行代码之前会将运算数转化为原始值)+ 性运算符是字符串环境，会将数字，布尔类型，undefined NaN null 转化为字符串进行拼接 原始值: number string boolean null undefined 对象值[object,object] 3.1.1 : 如果两个 运算数都是数值类型，直接进行算术运算 3.1.2 : 如果有一个运算是不是数字，或者都不是数字，那么将会进行字符串拼接 如果运算数有一个是字符串，那么这个运算环境就是字符串环境，需要将另外一个运算数转化为字符串，然后进行字符串的连接 另外一个是字符串，直接进行拼接 另外一个运算数是 数字 ， 将数字转化字符串，然后进行字符串拼接 另外一个运算数是 复杂数据类型 数组 或者对象 javascript会调用这两者的toString()方法，将它们转化为字符串，然后进行拼接 如果两个运算数都是 数组 或者对象 ，那么在 + 性环境中，javascript会将两个运算数都转化成字符串，然后进行拼接； 如果一个运算数是数字，为另外一个运算是是布尔类型，会将布尔类型转化为0或者1 ，然后进行数字运算 12345678910111213141516171819202122232425262728293031//以下是第二种情况下，转化为字符串 var arr = [1,2,3]var arr1 = [1,2,3,4]var obj1 = &#123;name:"Jhon"&#125;var obj2 = &#123;name:"JiM"&#125;var num = 9;var num1 = 6;var str = "Jhon";console.log(arr+num);//1,2,39console.log(typeof (arr+num));//stringconsole.log(arr+str);//1,2,3Jhonconsole.log(typeof (arr+str));//stringconsole.log(obj1+num);//[object Object]9console.log(arr1+arr);//1,2,3,41,2,3console.log(obj1+obj2);//[object Object][object Object]console.log("3"+NaN);//NaNconsole.log('str'+undefined);//strundefinedconsole.log('str'+null);//strnull//----------console.log(undefined+NaN);//NaNconsole.log(1+NaN);//NaNconsole.log(null+NaN);//NaN//-----如果有一个运算数是对象，那么javascript会调用toString转化为字符串，在和NaN记性字符串的拼接console.log([]+NaN); //NaN(这个是字符串NaN)console.log(&#123;&#125;+NaN);//[object Object]NaNconsole.log(1 + [] + 1 );//11 string类型的//-------------------console.log(true + 1);//2console.log(true + '3');//true3 3.2 - 运算符 两种情况 -性运算符的环境是数字环境，会将字符串，布尔类型等转化为数字进行运算3.2.1 如果两个运算数都是数字，那么进行基本的算术运算； 3.2.2 如果有一个运算数是数字，另外一个运算数是字符串 ，那么会尝试将字符串转化为数字 ，如果转化失败，则返回NaN 3.2.3 如果一个运算数是布尔类型，一个运算数是数字，会将布尔类型转化为数字 1234567891011console.log(num - num1);//3//只要有一个不是数字，运算结果就返回NaNconsole.log(num - arr);//NaNconsole.log(num - str);//NaNconsole.log(arr1-arr);//NaNconsole.log(obj1-obj2);//NaN//---------------------------------------console.log(true - 3);//-2console.log(true - '3');//-2console.log('2'-'1');//1console.log('str'-'1');//NaN 4 逻辑运算符 ！ &amp;&amp; ｜｜ 根本要明白布尔类型转化的规则，这个逻辑运算也就清楚了 1234567//-------------------! 运算符 以下结果全部返回true console.log(!undefined); console.log(!null); console.log(!NaN); console.log(!0); console.log(!"");// ！ 运算返回的一定是布尔类型的 123456789//----------------|| 或运算符 返回布尔类型或者其他数据类型console.log(''|| null);//null 空字符串 和null都是false 返回第二个运算数console.log(2||1);//2 2转化为布尔类型是true，直接返回，不在及逆行第二个运算数的运算console.log(2||null);//2 //简单来说，或运算就是找true的运算，找到true则马上返回该运算数；//1 对于运算数已经声明的情况// 如果第一个运算数是true,那么就返回第一个运算数，不再进行第二个运算数的判断// 如果第一个运算数是false,那么就直接返回第二个运算数，无论第二个运算数是true还是false;//2 对于运算数没有声明的情况,如果第一个运算数没有声明，则直接报错，如果第二个运算数没有声明，在第一个运算数为true的情况下不会报错，如果第一个运算数为false,会报错 123456789//----------------&amp;&amp; 与运算符console.log('' &amp;&amp; null); //如果第一个运算数为false,则直接返回第一个运算数console.log(2 &amp;&amp; 1 ); //如果第一个运算数为true,则直接返回第二个运算数console.log(2 &amp;&amp; null );//简单来说 ，与运算就是找false的运算，找到false则马上返回该运算数；//1 对于已经声明的变量，// 如果第一个运算数是false,则直接返回第一个运算数，不再进行第二个运算数的判断，//如果第一个运算数是true,则直接返回第二个运算数，无论第二个运算数是true还是false;//2 对于运算数没有声明的情况，如果第一个运算数没有声明，那么直接报错，如果第二个运算数没有声明，在第一个运算数为false的情况下不会报错，当第一个运算数为true的时候，会报错 12console.log(notDefined || true );//对于没有定义的直接报错是这样的情况，不再一一举证console.log("cant be excuted"); 5 类型转换5.1 转化为布尔类型为 false 的值如下；这个是逻辑运算的核心支撑 1234567891011121314// 0 null undefined NaN "" (空字符串) 返回false console.log(Boolean(null)); console.log(Boolean(undefined)); console.log(Boolean(0)); console.log(Boolean("")); console.log(Boolean(NaN)); console.log(Boolean(false));//对于非空字符串 数字 数组 对象 返回true console.log(Boolean("str")); console.log(Boolean(9)); console.log(Boolean(new Object));//if( ) 会进行隐式类型转化 if判断会对flag进行隐式类型转化，转化为布尔类型的值document.getElementById(id)如果能够获取某个元素，那么返回该元素对象，如果获取不到，返回undefined获取到的话，返回一个对象，对象的布尔类型值是 true ### 7 条件运算符 variable = boolean expression ? true value : false value ;在进行条件运算符运算的时候，会对boolean expression进行转化为布尔类型，需要熟悉了解布尔类型转化的规则； 8 赋值运算符，返回 = 右边的运算数，从右向左进行运算； 12345678910 var x = 5 ; console.log(x = 7);//7 var y = "str"; console.log(x = y );//str//"链式"赋值运算符---------------------------------- var arr, num1,num2 ; arr = [num1,num2] = [1,2,3,4]; console.log(arr);// [1,2,3,4] console.log(num1);//1 console.log(num2);//2]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[the Methods of String]]></title>
      <url>%2F2016%2F04%2F11%2F125-%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%91%BD%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[文本编辑命令1 给元素设置contenteditable属性，可以设置该元素中的内容是否可以被编辑 1&lt;div contenteditable="true"&gt;click to rewrite&lt;/div&gt; 2 给文档设置 design]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[hasOwnProperty和in的区别]]></title>
      <url>%2F2016%2F04%2F11%2F91-hasOwnProperty(property)%E5%92%8Cin%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
      <content type="text"><![CDATA[hasOwnProperty(“property”) 和 in 的区别1 先看各自应用 123456789101112&lt;script&gt; function Test()&#123; this.foo= "bar";//将属性直接添加给将要实例化的对象 &#125; Test.prototype.name = "Jhon";//将属性值添加在原型上 var test1 = new Test();// console.log(foo in test1);//语法错误，属性必须加上引号 console.log("foo" in test1);//true console.log(test1.hasOwnProperty("foo"));//true console.log("name" in test1);//true console.log(test1.hasOwnProperty("name"));//false&lt;/script&gt; 2 “property” in obj 返回布尔类型，用于判断某个对象上是否有某个属性，包括其实例化的属性，以及原型链上的属性 obj.hasOwnProperty(“property”) 返回布尔类型，用于判断某个对象上是否有某个属性，但是仅仅指的是实例化的属性，不包括原型上的属性,也不包括属性指向一个对象当中的属性； “property” in obj 可以判断一个对象是否有原生属性或者原型属性; obj.hasOwnProperty(“property”) 只能判断原生属性，不能判断原型属性 注意属性一定要用引号括起来 3 我们可以进行一个封装，用来判断某个属性是否在原型上 123456789101112 function hasProperty (property,obj)&#123; if(property in obj &amp;&amp; !obj.hasOwnProperty(property))&#123; return true ;//该属性在原型上 &#125;else&#123; return false; &#125; &#125;//注意property传入字符串属性 var result1 = hasProperty("foo",test1); console.log(result1);//false var result2 = hasProperty("name",test1); console.log(result2);//true 4 对于下面这种情况也要引起注意 1234567891011121314 var obj = &#123; name:"Jhon", age:13, address:"American", InnerObj:&#123; gender:"man" &#125; &#125; console.dir(obj); console.log( obj.hasOwnProperty("name"));//true console.log("name" in obj); //true console.log("gender" in obj); //fasle //"gender"并不是实例化对象的属性，也不是在原型上的属性 console.log( obj.hasOwnProperty("gender"));//false]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[元素选择器]]></title>
      <url>%2F2016%2F04%2F11%2F123-%E5%85%83%E7%B4%A0%E9%80%89%E6%8B%A9%E5%99%A8%2F</url>
      <content type="text"><![CDATA[元素选择器一 : 即时匹配元素 1 document.querySelector( ) 匹配选中的第一个HTML元素，如果没有匹配到，则返回 null ; 2 document.querySelectorAll( ) 匹配的是对象并不是实时的，后续更新的文档并不会被匹配到，它只包含当前调用时刻选择器所匹配的元素，如果匹配不到则返回一个空的nodelist对象； 二 实时匹配元素 1 getElementById getElementsTagName getElementsByClassName 等获取元素都是实时的； 三 对于有id属性的元素，可以直接通过window.id 获取到该元素 1234&lt;div id="div1"&gt; &lt;/div&gt;&lt;script&gt; console.log(window.div1);&lt;/script&gt; 四 对于form表单元素，如果form表单元素有id和name属性，可以直接通过name属性和id拉访问form属性，也可以直接通过元素document.forms来访问，这个获取的是一个HTMLCollection类数组 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang="en"&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action="#" id="formId" name="subName"&gt; &lt;input type="text"/&gt; &lt;input type="password"/&gt; &lt;input type="button "/&gt;&lt;/form&gt;&lt;form action="##" id="form22" name="address"&gt;&lt;/form&gt;&lt;script&gt; //对于有name和id属性的form可以直接通过window.id window.name 来访问元素 console.log(document.forms);//获取结果是一个HTML Collection集合，可以获取页面中所有的form表单 console.log(document.forms.subName);//获取结果是一个HTML Collection集合，可以获取页面中所有的form表单 console.log(document.forms.address);//获取结果是一个HTML Collection集合，可以获取页面中所有的form表单 //获取form表单里面的元素 console.log(document.forms.subName[0]);//可以通过索引来获取对应的表单元素 //也可以直接通过 id 和 name 直接访问 form表单 console.log(window.formId); console.log(window.subName); console.log(document.subName);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[CMD command]]></title>
      <url>%2F2016%2F04%2F11%2F61-cmd%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E8%A1%8C%2F</url>
      <content type="text"><![CDATA[cmd常用命令行 1 IP地址所谓IP地址就是给每个连接在互联网上的主机分配的一个32位地址。(就像每部手机能正常通话需要一个号码一样) 查看本机IP地址 ping、ipconfig、ifconfig（linux） &gt; ipconfig ... 显示信息 &gt; ipconfig /all ... 显示详细信息 &gt; ipconfig /renew ... 更新所有适配器 &gt; ipconfig /renew EL* ... 更新所有名称以 EL 开头 的连接 &gt; ipconfig /release *Con* ... 释放所有匹配的连接， 例如“有线以太网连接 1”或 “有线以太网连接 2” &gt; ipconfig /allcompartments ... 显示有关所有隔离舱的 信息 &gt; ipconfig /allcompartments /all ... 显示有关所有隔离舱的 详细信息 2、域名由于IP地址基于数字，不方便记忆，于是便用域名来代替IP地址，域名是一个IP地址的“面具” 查看域名对应的IP地址 ping 3、DNS服务DNS（Domain Name System）因特网上作为域名和IP地址相互映射的一个分布式数据库， 能够使用户更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。 简单的说就是记录IP地址和域名之间对应关系的服务。 查找优先级 本机hosts文件、DNS服务器 ipconfig /flushdns 刷新DNS 4、端口端口号是计算机与外界通讯交流的出口，每个端口对应不同的服务。 现实生活中，银行不同的窗口办理不同的业务。 查看端口占用情况 netstat -an 常见端口号 80、8080、3306、21、22]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[form]]></title>
      <url>%2F2016%2F04%2F11%2F88-form%E8%A1%A8%E5%8D%95%20%E5%B1%9E%E6%80%A7%E5%B8%B8%E7%94%A8%E6%80%BB%E7%BB%93%2F</url>
      <content type="text"><![CDATA[form表单属性常用总结1 enctype 设置或返回表单用来编码内容的 MIME 类型；规定在发送表单数据之前如何对其进行编码。 enctype 属性可设置或返回用于 编码表单内容 的 MIME 类型。如果表单没有 enctype 属性，那么当提交文本时的默认值是 “application/x-www-form-urlencoded”。 当 input type 是 “file” 时，必须设置是 “multipart/form-data”。 注意enctype属性是 用来设置如何对提交的内容进行编码的 属性 值 描述 application/x-www-form-urlencoded (默认) 在发送到服务器之前，所有字符都会进行编码（空格转换为 “+” 加号，特殊符号转换为 ASCII HEX 值）。 multipart/form-data 不对字符编码。在使用包含文件上传控件的表单时，必须使用该值。 text/plain 空格转换为 “+” 加号，但不对特殊字符编码。如果设置该属性,这不会对上传数据进行编码 2 method 属性,规定表单以何种方式向服务器发送数据 ​ 2.1 get方式发送数据 这时浏览器会与表单处理服务器建立连接，然后直接在一个传输步骤中发送所有的表单数据：浏览器会将数据直接附在表单的 action URL 之后。这两者之间用问号进行分隔。 如果不指定method属性值，默认以get方式发送数据 123456&lt;form action="35-form.php" method="get"&gt; &lt;input type="text" name="username" value="txt"/&gt; &lt;input type="password" name="psw" value="password"/&gt; &lt;input type="submit" value="提交"/&gt;&lt;/form&gt;地址栏显示:http://127.0.0.1/03-ajxa/mycode/35-form.php?username=txt&amp;psw=password ​ 2.2 post 方式发送数据 浏览器将会按照下面两步来发送数据。首先，浏览器将与 action 属性中指定的表单处理服务器建立联系，一旦建立连接之后，浏览器就会按分段传输的方法将数据发送给服务器。在服务器端，一旦 POST 样式的应用程序开始执行时，就应该从一个标志位置读取参数，而一旦读到参数，在应用程序能够使用这些表单值以前，必须对这些参数进行解码。用户特定的服务器会明确指定应用程序应该如何接受这些参数123456&lt;form action="35-form.php" method="post"&gt; &lt;input type="text" name="username" value="txt"/&gt; &lt;input type="password" name="psw" value="password"/&gt; &lt;input type="submit" value="提交"/&gt;&lt;/form&gt;地址栏显示:http://127.0.0.1/03-ajxa/mycode/35-form.php]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[javascript中的类型比较中的隐式转化是如何进行的？]]></title>
      <url>%2F2016%2F04%2F11%2F118-javascript%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%9E%8B%E6%AF%94%E8%BE%83%E4%B8%AD%E7%9A%84%E9%9A%90%E5%BC%8F%E8%BD%AC%E5%8C%96%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E7%9A%84%EF%BC%9F%2F</url>
      <content type="text"><![CDATA[javascript中的类型比较中的隐式转化是如何进行的？我们知道，在进行&lt; &gt; == 等比较运算的时候，总会遇到隐式转化，然后进行比较，有点混乱，这里简单总结下，方便参考: 在JavaScript中 对象到字符串 的转换经过如下步骤:1) 如果对象具有toString()方法,则调用这个方法。如果返回一个原始值,JavaScript将这个值转换字符串,并返回这个字符串的结果。2)如果对象没有toString()方法或者这个方法并不是返回一个原始值,那么JavaScript会调用valueOf()方法。如果存在这个方法,JavaScript调用它。如果返回值是原始值,将这个值转换为字符串,然后返回。3)如果无法从toString()和valueOf()获得一个原始值,此时就会抛出一个类型错误。 在 对象到数字 的转换过程中,JavaScript做了同样的事情,只是它首先尝试调用valueOf()方法。1)如果对象具有valueOf()方法,并返回一个原始值,则JavaScript将这个原始值转换为数字,并返回这个数字。2) 否则,对象尝试去调用toString()方法,返回一个原始值,则JavaScript返回这个值。3)如果无法从valueOf()和toString()获得一个原始值,此时就会抛出一个类型错误。 对象转换数字的细节解释了为什么空数组会被转换为数字0以及为什么具有单个元素的数组会被转换为一个数字。数组继承了默认的valueOf()方法，这个方法返回一个对象而不是一个原始值,因此数组到数组的转换调用toString()方法。空数组转换成空字符串,空字符串转换为数字0。含有一个元素的数组转换为字符串的结果和这个元素转换字符串的结果一样。如果数组只包含一个数字元素,这个数字转换为字符串,再转换为数字。 JavaScript中的”+”运算符可以进行数学加法和字符串连接操作。如果它的其中一个操作是对象,则JavaScript将使用特殊的方法将对象转换为原始值,而不是使用其它算术运算符的方法执行对象到数字的转换。”==”相等运算符与此类似。如果将对象和一个原始值比较,则转换将会遵照对象到原始值得转换方式进行。“+”和”==”应用的对象到原始值得转换包含日期对象的一种特殊情形。日期类是JavaScript语言核心中唯一的预先定义类型,它定义了有意义的向字符串和数字类型的转换。对于所有非日期的对象来说,对象到原始值的转换基本上是对象到数字的转换(首先调用valueOf),日期对象则使用对象到字符串的转换模。然而这里的转换(+ ==)和上文讲述的并不完全一致:通过valueOf和toString 返回的原始值将被直接使用,而不会被强制转换为数字或者字符串。和”==”一样,”&lt;”运算符以及其它关系算术运算符也会做到对象到原始值得转换,但要除去日期对象的特殊情形:任何对象都会先尝试调用valueOf,然后调用toString。不管得到的原始值是否直接使用,它都不会进一步被转换为数字或字符串。 值 转换为字符串 数字 布尔值 对象 undefined “undefined” NaN false throws TypeError null “null” 0 false throws TypeError true “true” 1 true new Boolean(true) false “false” 0 false new Boolean(false) “” “” 0 false new String(“”) “1.2” “1.2” 1.2 true new String(“1.2”) “zero” “zero” NaN true new String(“zero”) 0 “0” 0 false new Number(0) -0 “0” -0 false new Number(-0) NaN “NaN” false new Number(NaN) Infinity “Infinity” true new Number(Infinity) -Infinity “-Infinity” true new Number(-Infinity) 1(无穷大,非零) “1” true new Number(1) {}(任意对象) 对象本身 对象本身 true new Object({}) [](数组) “” 0 true new Array() [0](数组) “0” 0 true new Array() [0,1,2](数组) “0,1,2” NaN true new Array() function(){} 函数本身 NaN true]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[javascript GC 垃圾回收机制]]></title>
      <url>%2F2016%2F04%2F11%2F92-Javasript%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%2F</url>
      <content type="text"><![CDATA[Javascript 垃圾回收机制1 当内存中的对象不再有引用的时候，那么过一段时间该对象开辟的内存空间则会回收 123var obj = &#123;"name":"Jhon"&#125;;var obj = null ;//当将obj设置为null 的时候，将会回收掉&#123;"name":"Jhon"&#125; 123var obj = &#123;"name":"JiM"&#125;;var obj = &#123;"age":18&#125;;//当将obj的指向改变之后，原来的&#123;"name":"JiM"&#125;，这块内存就会被回收 2 JavaScript垃圾回收的机制很简单：找出不再使用的变量，然后释放掉其占用的内存，但是这个过程不是时时的，因为其开销比较大，所以垃圾回收器会按照固定的时间间隔周期性的执行。 变量生命周期什么叫不再使用的变量？不再使用的变量也就是生命周期结束的变量，当然只可能是局部变量 (函数体内用var声明的变量)，全局变量的生命周期直至浏览器卸载页面才会结束。局部变量只在函数的执行过程中存在，而在这个过程中会为局部变量在栈或堆上分配相应的空间，以存储它们的值，然后再函数中使用这些变量，直至函数结束（闭包中由于内部函数的原因，外部函数并不能算是结束、 在局部作用域中，当函数执行完毕，垃圾回收机制很容易判断出，并且做出回收，但是全局变量声明时候需要释放内存空间则很难判断，因此我们在日常开发过程中，要尽量的避免使用全局变量，以确保性能。 在Javascript中，如果一个对象不再被引用，那么这个对象就会被GC回收。如果两个对象互相引用，而不再被第3者所引用，那么这两个互相引用的对象也会被回收。因为函数a被b引用，b又被a外的c引用，这就是为什么函数a执行后不会被回收的原因。 全局变量什么时候需要自动释放内存空间则很难判断，因此在我们的开发中，需要尽量避免使用全局变量，以确保性能问题。 3 垃圾清除的方式 标记清除(mark and sweep) 这是JavaScript最常见的垃圾回收方式，当变量进入执行环境的时候，比如函数中声明一个变量，垃圾回收器将其标记为“进入环境”，当变量离开环境的时候（函数执行结束）将其标记为“离开环境”。至于怎么标记有很多种方式，比如特殊位的反转、维护一个列表等，这些并不重要，重要的是使用什么策略，原则上讲不能够释放进入环境的变量所占的内存，它们随时可能会被调用的到。 垃圾回收器会在运行的时候给存储在内存中的所有变量加上标记，然后去掉环境中的变量以及被环境中变量所引用的变量（闭包），在这些完成之后仍存在标记的就是要删除的变量了，因为环境中的变量已经无法访问到这些变量了，然后垃圾回收器相会这些带有标记的变量机器所占空间。 引用计数(reference counting) 在低版本IE中经常会出现内存泄露，很多时候就是因为其采用引用计数方式进行垃圾回收。引用计数的策略是跟踪记录每个值被使用的次数，当声明了一个变量并将一个引用类型赋值给该变量的时候这个值的引用次数就加1，如果该变量的值变成了另外一个，则这个值得引用次数减1，当这个值的引用次数变为0的时候，说明没有变量在使用，这个值没法被访问了，因此可以将其占用的空间回收，这样垃圾回收器会在运行的时候清理掉引用次数为0的值占用的空间。 看起来也不错的方式，为什么很少有浏览器采用，还会带来内存泄露问题呢？主要是因为这种方式没办法解决循环引用问题。比如对象A有一个属性指向对象B，而对象B也有有一个属性指向对象A，这样相互引用 123456function test()&#123; var a=&#123;&#125;; var b=&#123;&#125;; a.prop=b; b.prop=a; &#125; 这样a和b的引用次数都是2，即使在test()执行完成后，两个对象都已经离开环境，在标记清除的策略下是没有问题的，离开环境的就被清除，但是在引用计数策略下不行，因为这两个对象的引用次数仍然是2，不会变成0，所以其占用空间不会被清理，如果这个函数被多次调用，这样就会不断地有空间不会被回收，造成内存泄露。 在IE中虽然JavaScript对象通过标记清除的方式进行垃圾回收，但BOM与DOM对象却是通过引用计数回收垃圾的，也就是说只要涉及BOM及DOM就会出现循环引用问题。看上面的例子，有同学回觉得太弱了，谁会做这样无聊的事情，其实我们是不是就在做 1234window.onload=function outerFunction()&#123; var obj = document.getElementById(&quot;element&quot;); obj.onclick=function innerFunction()&#123;&#125;; &#125;; 这段代码看起来没什么问题，但是obj引用了document.getElementById(“element”)，而document.getElementById(“element”)的onclick方法会引用外部环境中德变量，自然也包括obj，是不是很隐蔽啊。 解决办法 最简单的方式就是自己手工解除循环引用，比如刚才的函数可以这样 12345window.onload=function outerFunction()&#123; var obj = document.getElementById(&quot;element&quot;); obj.onclick=function innerFunction()&#123;&#125;; obj=null; &#125;;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[the property of object]]></title>
      <url>%2F2016%2F04%2F11%2F89-%E5%AF%B9%E8%B1%A1-%E4%BC%AA%E5%AF%B9%E8%B1%A1%2F</url>
      <content type="text"><![CDATA[对象一 对象的类型1 对象的定义:在 ECMAScript 中，所有对象并非同等创建的。一般来说，可以创建并使用的对象有三种：本地对象、内置对象和宿主对象 1.1 本地对象: Object Function Array String Boolean Number Date 这些是基本的类(引用类型)；使用这些引用类型的时候需要进行实例化； 1.2 内置对象 : Math 对象 Global 对象，这些对象在ECMAscript程序开始执行的时候出现，也就是说，我们不必实例化该对象，便可以直接引用它们内置的方法和属性； 1.3 宿主对象，所有非本地对象都是宿主对象，比如BOM和DOM 1.4 其中内置对象Math 对象和Global对象，这些对象的方法可以直接调用，比如Math.abs()， Math.random() ; 全局的eval() Number() parseInt() parseFloat() escape() ,但是Array String Date等本地对象的一些方法只能在实例化之后，应用在实例化的对象上； 二 对象的创建1.对象创建包括三种方式: new 一个对象；字面量创建 ； ES5新增的Object.create(); 1.1 var = { } ; var obj = { “name”:”Jhon”,”age”:18 } 1.2 通过构造函数new一个对象 12function CreateObj ()&#123; &#125;var obj = new CreateObj () ; 1.3 通过ES5的新方法 var obj = Object.create( obj1) 需要传入一个参数，该参数是一个对象 等价于 obj.prototype = obj1 ; Object.create( ) 方法会直接给原型添加属性 1234567var obj = &#123; name : 'tom', color : 'blue' &#125; console.log(o); var obj1 = Object.create(obj);//注意obj1的属性在其原型上 console.log(o1); 三 Javascript中对象内部 key : value 形式的构成:1 构造函数实例化的属性包括两部分，一部分是”原生属性”，一部分是”原型属性”； 一部分是通过构造函数内部直接创建或者obj.property = “value”直接创建，我么可以称作”原生属性”； 一部分是通过原型创建，obj.prototype = value ; obj.prototype.property = value ;我们可以称作”原型属性”； “原生属性”可以被操作，可以重新赋值，不同实例对象之间不会影响 ; “原型属性”由构造函数创建的所有实例对象 共享 ，”牵一发而动全身”; 1234567891011121314&lt;script&gt; function CreateObj()&#123; this.name = "Jhon"; this.height = "180cm" &#125; CreateObj.prototype = &#123;"age":12,"address":"China"&#125;; CreateObj.prototype.gender = "male"; CreateObj.prototype.fn = function()&#123; console.log("this is innerFunc"); &#125;;//通过原型创建属性 var obj1 = new CreateObj(); obj1.favour = "singing";//构造函数的"原生属性"; console.log(obj1);&lt;/script&gt; 2 对于实例对象的属性的操作由两种方式，通过操作符 和 直接操作原型属性 通过点操作符设置属性的时候，只能操作原生属性 值，如果实例对象有该原生属性，那么则改变值，没有的话则创建原生属性，同时添加一个值； 由于点操作符不能修改原型属性 的值，所以要通过实例化对象的proto属性值，通过proto属性修改的值，会应用到所有的由该构造函数创建的实例对象上，这就是”牵一发而动全身”； 1234567891011121314151617181920212223242526272829&lt;script&gt; function CreateObj()&#123; this.name = "Jhon"; this.height = "180cm" &#125; CreateObj.prototype = &#123;"age":12,"address":"China"&#125;;//对象是复杂类型数据，传给prototype的是地址 //如果将原型形属性指向一个函数，那么后面创造的属性都是类似函数类型 //如果将原形属性指向一个基础数据类型，那么，后面则无法贼通过原型添加属性 CreateObj.prototype.gender = "male";//基础数据类型传值传的是值 //注意 obj.prorotype = value CreateObj.prototype.fn = function()&#123; console.log("this is innerFunc"); &#125;;//通过原型创建属性 //实例化两个对象 var obj1 = new CreateObj(); var obj2 = new CreateObj(); console.log("通过原生属性修改后——————————"); obj1.age = "22"; //构造函数的"原生属性",可以直接通过点操作符直接设置和修改，点操作符只能访问原生属性，不能访问原型属性。 console.log(obj1,obj2); console.log("通过原型属性修改后——————————"); obj1.__proto__.address = "American";//等价于下面这行代码 隐藏属性__proto__ 在实际生产中尽量不要用 // CreateObj.prototype.address ="American"; // 通过__proto__属性可以访问原型属性，进行设置和更改，注意如果通过原型属性修改属性的话，所有通过该构造函数创建的对象的原型属性值都会改变 console.log(obj1,obj2); console.log(obj1.name);//Jhon console.log(obj1.address);//American&lt;/script&gt; 看下图便于大家理解 四 “一切皆对象”: 1 数组、函数、String包装对象都是对象，对象的操作同样适用于这些 五 : 对象中原型的继承 DOM 元素的继承如下 对象是由 new 运算符加上要实例化的对象的名字创建的]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[prototype 浅析]]></title>
      <url>%2F2016%2F04%2F11%2F90-js%E4%B8%AD%E5%8E%9F%E5%9E%8Bprototype%E5%B1%9E%E6%80%A7%20%20%20_%20_%20proto_%20_%20%E5%B1%9E%E6%80%A7%20%E4%BB%A5%E5%8F%8A%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%9A%84%E6%80%BB%E7%BB%93%2F</url>
      <content type="text"><![CDATA[js中 构造函数prototype属性 实例化对象 proto 属性 以及原型链的总结1 注意区分 prototype是构造函数的属性，可以直接操作，所有的实例化对象可以共享由其创建的属性或者方法，也就数说，当函数被new调用的时候，实例化的对象上才有原型上的属性，但是不用new，而直接调用的时候，却没有； proto 是实例化对象的属性，该属性是JS对象上的隐藏属性，这个属性指向的是该对象 对应构造函数的prototype属性；该属性不可实际操作； 实例化的对象里面包括 实例化的属性 + proto 属性 ， proto 属性里面又包含constructor 属性和 proto (原型链终点) 1.1 test.prototype.property = “value”; test.prototype.property =function(){ };直接向原型中添加属性， 12345function test()&#123; this.age = 13 ; &#125; var obj = new test; console.log(obj); 123456789101112 function test()&#123; this.age = 13 ; &#125; var obj1 = new test; obj1.name = "JiM";//点操作符，直接给当前实例化的对象添加属性或者方法,只能给obj1 添加 test.prototype.name = "Jhon";//构造函数的prototype属性可以直接将属性和方法添加到__proto__:属性里面，所有的由该构造函数实例化的对象都会拥有由prototype声明的属性和方法， var obj2 = new test ;//注意 prototype属于构造函数的属性，而不是实例化对象的属性 console.log(obj1); console.log(obj2); 123console.log(obj1.name);//JiMconsole.log(obj2.name);//Jhon//原型链的对象会遵循就近原则进行取值 构造函数首字母一般要大写，这里由于开始的疏忽，暂时用小写 1.2 test.prototype = new test2 ( ) ;改变实例对象的proto原型指向; 12345678910function test()&#123; this.age = 13 ; &#125; function test2()&#123; this.email = "gmail"; &#125; //注意 prototype属于构造函数的属性，而不是实例化对象的属性 test.prototype = new test2();//var obj2 = new test ; console.log(obj2); 1.3 所有的函数的 proto 指向 构造函数 Function.prototype ; ​ 所有实例对象的 proto 指向 对应构造函数的 prototype属性: arr. proto === Array.prototype ​ 所有构造函数的prototype属性中有一个constructor属性，指向其构造函数 ​ 在Javascript中每个函数都有一个prototype属性和 proto 属性， 其中所有函数 的 proto 属性指向Function的 prototype属性， 所有实例化对象 的 proto 属性指向其对应 的构造函数的 prototype 属性； 123456789101112131415161718&lt;script&gt; function MyFunc()&#123;&#125; console.dir(Function); console.dir(Object); console.dir(Array); console.dir(MyFunc); console.dir(Function.__proto__ === Function.prototype);//true console.dir(MyFunc.__proto__ === Function.prototype);//true console.dir(Array.__proto__ === Function.prototype);//true //所有函数,包括(Object，Array，Date ，MyFunc 这些构造函数)，它们的__proto__属性指向Function构造函数的prototype属性，即 Function.prototype var myFunc = new MyFunc ; var arr = new Array(); console.dir(myFunc); console.dir(arr); console.log(myFunc.__proto__ === MyFunc.prototype);//true console.log(arr.__proto__ === Array.prototype);//true //所有实例化的对象，对象，对象的__proto__属性指向其对应的构造函数的prototype属性&lt;/script&gt; 1.4 注意区分函数也是对象，但是对象不一定是函数；Function是所有函数的构造函数，包括内置构造函数(内置对象，如果给Function的prototype添加了属性，那么所有通过构造函数new出来的对象都会在 proto 属性中有该属性) 12345678910111213141516171819202122232425&lt;script&gt; function fn()&#123; //声明一个函数 &#125; fn.address = "China"; //如果将函数看成一个对象的话，点操作符可以给函数添加属性 //当把函数当成构造函数使用的 时候，生成的实例化的对象里面的属性，只有通过构造函数原型添加的属性和方法，以及在构造函数内部声明的属性和方法 fn.prototype.na = "Jhon"; fn.prototype.age = 15 ; Function.prototype.foo = "bar";//通过函数的构造函数Function的prototype添加属性 console.dir(fn);//查看fn的属性组成//如果将fn看成对象的话，fn里面有如下属性 address prototype __proto__ 属性等 console.log(fn.foo);//bar console.log(Array.foo);//bar console.log(fn.na);//undefined //. 操作符只会顺着原型属性__proto__往上去找某个属性 console.log(fn.__proto__.na);//undefined console.log(fn.prototype.na);//Jhon console.log(fn.age);//undefined console.log(fn.__proto__.age);//undefined console.log(fn.prototype.age);//15 //要区分函数的prototype属性和__proto__属性 //函数的__proto__属性指向Function构造函数的prototype属性，即 Function.prototype console.log(fn.address);//China&lt;/script&gt; 1.5 有点绕 所有的函数都有prototype属性，同时也都有 proto 属性，该属性指向Function构造函数的prototype属性；Function的 proto 属性指向Object构造函数，函数也是对象； 所有的对象都有 proto 属性，指向该对象的构造函数的prototype属性 2 原型继承，所谓的继承，其实就是一个构造函数原型指向另外一个构造函数的实例化对象2.1 原型继承的所有的属性由 所有 的实例化的对象共享，一个改变，其余的都会改变，这是原形继承的一个缺点； 2.2 原型的继承方式：借助构造函数继承、组合继承 2.3 原型继承要注意理解复杂类型传递的是数据在堆内存中的地址； 2.4.1 不使用prototype属性定义的对象方法，是静态方法，只能直接用类名进行调用！另外，此静态方法中无法使用this变量来调用对象其他的属性！ 2.4.2 使用prototype属性定义的对象方法，是非静态方法，只有在实例化后才能使用！其方法内部可以this来引用对象自身中的其他属性！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[eventDelegate]]></title>
      <url>%2F2016%2F04%2F11%2F76-%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%B4%BE%2F</url>
      <content type="text"><![CDATA[事件委派1 jQuery事件委派:可以理解为，本来应该下属做的事情，却由领导做了 1234567891011121314151617&lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt;&lt;/ul&gt;&lt;script&gt; $(function()&#123; $("ul li").click(function()&#123; console.log("click绑定程序"); &#125;); &#125;); $(function()&#123; $("ul").delegate("li","click",function()&#123; console.log("delegate直接绑定执行程序"); &#125;); &#125;);&lt;/script&gt; 以上两种绑定事件的方式所实现的效果是一样的，但是需要注意 第一种绑定方式 click 1 很耗费资源，因为这种方式是给每个li都加上了事件，li的个数少的话还没事，如果li多的话会很耗费资源。 2 如果后期动态添加li，不会拥有这个弹出事件。 第二种绑定方式 delegate 1 可以解决耗费资源的问题，只绑定给ul元素一个事件处理程序 2 后期动态添加的子元素，也会拥有该事件处理程序]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[封装函数 innerText textContent innerHTML]]></title>
      <url>%2F2016%2F03%2F22%2F20-%E5%B0%81%E8%A3%85%E5%87%BD%E6%95%B0%20%20%20innerText%20%20%20textContent%20%20innerHTML%20%2F</url>
      <content type="text"><![CDATA[封装函数 innerText textContent innerHTML 1 如何改变元素文本内容？innerText 和 textContent 的区别 obj.innerHTML 可以获取元素内所有的内容，obj.innerHTML=” “可以修改元素内容，里面也可以添加其他元素标签；谷歌，火狐，IE都支持； obj.innerText 只能获取内容，不能获取标签；obj.innerText=” “也只能设置文本内容；谷歌火狐支持，IE不支持，所以需要兼容性封装； obj.textContent 只能获取内容，不能获取标签；obj.textContent=” “也只能设置文本内容；谷歌火狐支持，IE也支持； obj.textContent 和 obj.innerText 可以修改对象内部整体的内容，包括元素、属性、文本. 栗子： 12345678910111213141516&lt;div id="dv"&gt; &lt;p&gt;通过innerText和innerHTMl获取内容的不同&lt;/p&gt;&lt;/div&gt;document.getElementById("dv").innerText = "&lt;p&gt;innerText 不能显示标签&lt;/p&gt;";document.getElementById("dv").inerHTML = "&lt;p&gt;innerHTML可以显示文本和标签&lt;/p&gt;"两种不同的执行结果：innerText:注意此时的 &lt;p&gt;是以文本的形式在页面中存在的；&lt;div id="dv"&gt; &lt;p&gt;innerText 不能显示标签&lt;/p&gt;&lt;/div&gt;innerHTML:此时的&lt;p&gt;标签是以元素的形式在页面中存在的；&lt;div id="dv"&gt; &lt;p&gt;innerHTML可以显示文本和标签&lt;/p&gt;&lt;/div&gt; 2 如何获取元素内容？innerText 和 innerHTML 的区别 obj.innerHTML 不仅可以获取对象的文本节点，只要是元素内的节点，包括元素节点，文本节点，都会被获取到。 obj.innerText 只能获取对象的文本节点，不能获取元素的子元素节点 栗子： 1234567891011&lt;div id="dv"&gt; &lt;p&gt;通过innerText和innerHTMl获取内容的不同&lt;/p&gt;&lt;/div&gt;var result1 = document.getElementById("dv").innerText;var result2 = document.getElementById("dv").innerHTML;console.log(result1);console.log(result2);输出结果：result1:通过innerText和innerHTMl获取内容的不同result2:&lt;p&gt;通过innerText和innerHTMl获取内容的不同&lt;/p&gt; 3 封装函数原因：因为谷歌和火狐 都支持innerText 和 textContent 但是，IE只支持textContent，所以需要封装函数，无论哪个浏览器都可以设置文本内容或者获取文本内容。 12345678910111213141516function setInnerText (element,content)&#123; if (element.innerText == undefined)&#123; element.textContent = content &#125;else &#123; element.innerText = content &#125;&#125;function getInnerText (element,content)&#123; if (element.innerText == undefined)&#123; return element.textContent &#125;else &#123; return element.innerText &#125;&#125; 这些API联系document.write( ) 4 在jquery中对应的是html() 和 text (),jqueryObj.html() jqueryObj.text()，如果没有参数可以获取jquery对象的内容，如果设置了内容则可以为其设置文本内容。 和DOM中一样 ，html()不仅可以获取文本节点，还可以获取元素节点，而text()只能获取文本节点的内容；同样。html(“innerHTML可以显示文本和标签“),可以设置元素节点以及文本节点，但是text(“innerHTML可以显示文本和标签“),只能设置文本节点，及时添加了标签，标签也会以文本的形式显示，不会形成元素节点。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[boostrap基础]]></title>
      <url>%2F2016%2F03%2F22%2F41-Bootstrap%E6%A1%86%E6%9E%B6%E6%80%BB%E7%BB%93%E6%80%BB%E7%BB%93%2F</url>
      <content type="text"><![CDATA[1 理解其核心思想:通过组合样式对标签进行样式操作，从而到达控制页面的样式以及网页结构 2 bootstrap环境搭建:引入相应的css javascript 3 如何理解Bootstrap移动端优先，通过其媒体查询设置宽度可窥一二,Bootstrap框架代码的百分比设置优先基于 12345678910111213141516171819202122232425.container &#123; padding-right: 15px; padding-left: 15px; margin-right: auto; margin-left: auto;&#125;/*默认移动端设备优先 width &lt; 768px*/@media (min-width: 768px) &#123; .container &#123; width: 750px; &#125;&#125;/*sm 屏幕设备 768px &lt; width &lt; 992px*/@media (min-width: 992px) &#123; .container &#123; width: 970px; &#125;&#125;/*md屏幕设备 992px &lt; width &lt; 1200px */@media (min-width: 1200px) &#123; .container &#123; width: 1170px; &#125;&#125;/*lg 屏幕设备 width &gt; 1200px*/ 4 Bootstrap 实现移动端自适应布局的基础是根据宽度 100% 设置自适应布局，宽度基准是以父元素的宽度为基准的。 5 栅格系统:如何理解 col-xs-(超小屏&lt;768px) col-sm-(小屏768px 992px) col-md-(1200px&gt;中等屏 &gt;992px) col-lg- (大屏 &gt;1200px) 12345678/* 超小屏幕（手机，小于 768px） *//* 没有任何媒体查询相关的代码，因为这在 Bootstrap 中是默认的（Bootstrap 是移动设备优先的） *//* 小屏幕（平板，大于等于 768px） */@media (min-width: @screen-sm-min) &#123; ... &#125;/* 中等屏幕（桌面显示器，大于等于 992px） */@media (min-width: @screen-md-min) &#123; ... &#125;/* 大屏幕（大桌面显示器，大于等于 1200px） */@media (min-width: @screen-lg-min) &#123; ... &#125; 1234567891011121314151617181920212223242526&lt;div&gt; &lt;div class="col-xs-6 col-sm-4 col-md-3"&gt; col-xs-6会优先作用，查看bootstrap源码可以得知，col-sm-4需要在@media(min-width : 768px)&#123;&#125;成立的时 候，该类才会起作用，col-md-3需要在@media(min-width : 992px)&#123;&#125;成立的时候才会起作用。 &lt;/div&gt; &lt;div class="col-xs-6 col-sm-4 col-md-3"&gt; 源码中的书写顺序如下: .col-xs-6 &#123; width:100%; &#125; col-xs-* 是可以全局使用的 &lt;/div&gt; &lt;div class="col-xs-6 col-sm-4 col-md-3"&gt; @media(min-width : 768px)&#123; .col-sm-4 &#123; width: 33.33333333%; &#125; &#125; &lt;/div&gt; &lt;div class="col-xs-6 col-sm-4 col-md-3"&gt; @media(min-width : 992px)&#123; .col-md-3&#123; width: 25%; &#125; &#125; &lt;/div&gt;&lt;/div&gt; 由此可见col- 类主要是改变元素的样式属性，width 的值，所以无论什么情况下， 1col-xs-6 &#123; width:100%&#125; 都是可以起作用的，但是当屏幕的大小变化的时候，比如由超小屏幕变化到—&gt;小屏幕 ,此时 12345@media(min-width : 768px)&#123; .col-sm-4 &#123; width: 33.33333333%; &#125; &#125; 将会起作用，覆盖 掉原来的width：100%设置，变为width:33.3333333%;同理变为中等屏幕的时候，此时 12345@media(min-width : 992px)&#123; .col-md-3&#123; width: 25%; &#125; &#125; 将会起作用，覆盖掉原来的width:33.3333333%，变为width:25%. 此时在回过头来理解Bootstrap是移动设备优先的这句话，可以看出，移动设备(width&lt;768px)的时候，类样式默认没有使用条件，不需要媒介查询判断，任何时候都可以使用，但是其他屏幕设备上就需要通过媒介查询来判断该类样式是否可以执行 6 Bootstrap源码在全局定义了box-sizing:border-box ，所有的HTML元素都是以边框为准进行的宽度计算，内容会被压缩 1234567891011* &#123; -webkit-box-sizing: border-box; -moz-box-sizing: border-box; box-sizing: border-box;&#125;*:before,*:after &#123; -webkit-box-sizing: border-box; -moz-box-sizing: border-box; box-sizing: border-box;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[select 值提交选择哪一个？]]></title>
      <url>%2F2016%2F03%2F11%2F93-select%20%E7%9A%84%E5%80%BC%E9%80%89%E6%8B%A9%E7%9A%84%E5%93%AA%E4%B8%80%E4%B8%AA%EF%BC%9F%2F</url>
      <content type="text"><![CDATA[select 的值选择的哪一个？12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang="en"&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; div&#123; height: 20px; overflow: hidden; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;select name="car" id="carId"&gt;汽车 &lt;option value=""&gt;福特&lt;/option&gt; &lt;option value="fort1"&gt;福特1&lt;/option&gt; &lt;option value="fort2"&gt;福特2&lt;/option&gt; &lt;option &gt;福特3&lt;/option&gt; &lt;option value=""&gt;福特4&lt;/option&gt; &lt;option value="fort5"&gt;福特5&lt;/option&gt; &lt;option value="fort6"&gt;福特6&lt;/option&gt; &lt;option value="fort7"&gt;福特7&lt;/option&gt; &lt;option value="fort8"&gt;福特8&lt;/option&gt; &lt;option value="fort9"&gt;福特9&lt;/option&gt; &lt;option value="fort10"&gt;福特10&lt;/option&gt;&lt;/select&gt;&lt;script&gt; var selectObj = document.querySelector("select"); selectObj.onchange = function()&#123; console.log(this.value);//选择中哪个，则输出哪个option对应的value值 &#125;;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 每次改变选择的值的时候，都会输出 select 的value值，那么这个value的值到底指的是哪一个？ 这里总结如下： 如果option标签有value属性，那么当选中该option选项的时候，select的value值就是option标签的value属性的值；如果value属性值为为空字符串，那么就是空字符串 如果option标签没有value属性，那么当选中该option选项的时候，select的value值就是option标签的文本节点的值； 对于select的value取值 : option标签的value属性值优先于option标签的文本节点的值]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[vertivalAlign]]></title>
      <url>%2F2016%2F02%2F27%2F35varticalAlign%2F</url>
      <content type="text"><![CDATA[vertical-align 1 在一行中，行内元素默认是以baseline为基准进行垂直对齐的，行内元素包括 img a span 等 2 baseline 基线:可以简单的理解为是在四线格中字母x的底部的那根线 3 img标签默认对齐行内的文本的基线 4 那么由于图片默认对齐基线，会在下面出现几像素的间隙，如何去除该间隙？ 5 先来看看间隙的产生：(注意浏览器默认字体大小，所以对于所有的DOM元素都有) 123456.div1&#123; font-size:50px;&#125;&lt;div class="div1"&gt; &lt;span&gt;该行的基线以文本的baseline为基准&lt;/span&gt; &lt;img src="img/01.jpg" alt="" width="20px"/&gt;&lt;/div&gt; 一 : 既然产生间隙的根源是行内元素 默认以文本的基线为基准的对齐方式导致的，那么只需要将改行的文本字体大小设置为font-size 为0 即可这行代码将图片所在行的文本大小设置为0 ，由于文本相关属性的继承性，该元素内所有元素的文本大小均为0px，所以此时可以消除间隙 123.div1 &#123; font-size:0px ;&#125; 二:既然间隙是有行内元素默认以改行的文本的baseline为基准进行垂直方向的对齐，那么将图片设置为块级元素，也可以消除间隙： 123.div1&gt;img&#123; display: block; &#125; 三 利用vertical-align属性：设置元素的对齐方式 可能值 baseline top bottom middle text-top text-bottom 123.div1&gt;img&#123; vertical-align:bottom;&#125; 四 如果想要更好地理解vertical-align属性的作用，可以将图片width=”20px”，改成可以和字体比较的大小，然后文本设置font-size设置大一些，然后看效果，有助于理解vertical-align的属性。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[onload trigger]]></title>
      <url>%2F2016%2F02%2F19%2F53-js%20%20%E5%92%8C%20jquery%20%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%8C%BA%E5%88%AB%2F</url>
      <content type="text"><![CDATA[1 onload 支持该事件的标签和JavaScript对象: HTML标签\,\, \,\, \, \, \，javascript window image layer 12345678js: window.onload = function()&#123; &#125;; //onload 事件会在页面或图像加载完成后立即发生jquery:$(function()&#123; &#125;); //当DOM载入就绪可以查询及操纵时绑定一个要执行的函数。这是事件模块中最重要的一个函数，因为它可以极大地提高web应用程序的响应速度。简单地说，这个方法纯粹是对向window.load事件注册事件的替代方法。通过使用这个方法，可以在DOM载入就绪能够读取并操纵时立即调用你所绑定的函数，而99.99%的JavaScript函数都需要在那一刻执行。有一个参数－－对jQuery函数的引用－－会传递到这个ready事件处理函数中。可以给这个参数任意起一个名字，并因此可以不再担心命名冲突而放心地使用$别名。1 js中只能写一个，如果一个页面写了多个，后面的会将前面的覆盖 jquery中可以写多个，后面的不会覆盖2 执行时间不同，js中是在页面元素加载完成之后执行 1js : script.onload = function()&#123; &#125; ;表示页面中script标签加载完毕 当向jQuery中传入参数的时候，该参数可以作为全局的对 –jQuery– 的引用 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang="en"&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; div&#123; width: 100px; height: 100px; background-color: #003C78; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;&lt;/div&gt;&lt;script src="jquery-1.12.2.js"&gt;&lt;/script&gt;&lt;script&gt; $(function(ev)&#123; console.log(arguments); console.log(ev);// $("div").click(function()&#123;// $(this).css("background-color","red") //等价于下面 ev("div").click(function()&#123; ev(this).css("background-color","red") &#125;) &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 2 trigger(type,[data]) 在每一个匹配的元素上触发某个事件(该事件必须已经绑定在了所匹配的元素上)，以下代码是等价的 12345678910111213functin render()&#123; console.log("我被执行了");&#125;$(window).on('resize',function()&#123; render(); &#125;).trigger('resize'); /* 等价于*/$(window).resize(function()&#123; render();&#125;);window.onresize = function()&#123; render();&#125;;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[box-sizing]]></title>
      <url>%2F2016%2F01%2F18%2F59-%E6%80%AA%E5%BC%82%E7%9B%92%E6%A8%A1%E5%9E%8Bbox-sizing%2F</url>
      <content type="text"><![CDATA[怪异盒模型:box-sizing box-sizing:content-box || border-box ; content-box： padding和border不被包含在定义的width和height之内。对象的实际宽度等于设置的width值和border、padding之和，即 ( Element width = width + border + padding ) 此属性表现为标准模式下的盒模型。 border-box： padding和border被包含在定义的width和height之内。对象的实际宽度就等于设置的width值，即使定义有border和padding也不会改变对象的实际宽度，即 ( Element width = width ) 浏览器对盒模型的解释是IE6之前的版本下相同，此时内容的宽高可以由定义的 width height 减去相应方向上的padding和border;此属性表现为怪异模式下的盒模型。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[hexo 命令]]></title>
      <url>%2F2016%2F01%2F17%2F11hexo%20%E5%91%BD%E4%BB%A4%2F</url>
      <content type="text"><![CDATA[hexo 命令 初始化博客 $ mkdir blog 创建一个名为blog 的文件夹 $ hexo init 将会在目标文件夹下建立博客需要的所有文件 $ npm install 进行依赖包安装 配置博客 创建博文 $ hexo new myhello 创建一个makedown文件在drafts目录里面 $ hexo n myhello 等价 $ hexo publish myhello 将文件从drafts移到post目录 $ hexo server 启动服务器 $ hexo s 也可以启动服务器 如何将博客发布到GitHub上？ $ npm install hexo-deployer-git –save 安装hexo git插件 部署 $ hexo clean 清除一些莫名其妙的问题 $ hexo generate 生成静态页面 此时会将/source的.md文件生成到/public中，形成网站的静态文件。 等价于 $ hexo g $ hexo deploy 将生成的博客静态页面上传GitHub上 ；该操作会将hexo生成的静态内容部署到配置的仓库中，请看下面介绍。 部署网站之前需要生成静态文件，即可以用 $ hexo generate -d 直接生成并部署。等价于 $ hexo d $ hexo clean # 删除 已经生成的静态页面 $ cd your-hexo-site $ git clone + http 地址可以创建主题 然后修改root/config.yml theme]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[DOM元素和jquery对象的互相转化]]></title>
      <url>%2F2015%2F12%2F22%2F08DOM%E5%85%83%E7%B4%A0%E5%92%8Cjquery%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BA%92%E7%9B%B8%E8%BD%AC%E5%8C%96%2F</url>
      <content type="text"><![CDATA[DOM元素和jquery对象的互相转化 1 DOM对象转化为jquery对象,语法：$(DOM对象)：用js一些固有的操作获取页面元素。比如 document.getElementById(),getElementsByTagName()，等js方法获取页面元素的所得为DOM对象,将DOM对象放在中括号里面所得便是jquery对象； 2 jquery对象转化为DOM对象，语法：jquery对象[ index]或者 jquery对象.get(index); 用jquery方法获取页面元素，通过jquery选择器，筛选器进行选择，所得结果为jquery对象，jquery对象有两种方法可以转化为DOM对象：jqueryObj[index] 和 jqueryObj . get(index);(如果不写参数的话，那么则将匹配到的所有的jquery对象转化为DOM对象) 3 DOM中this代表DOM对象 jquery中$(this)代表jquery对象。 4 栗子说明下： 12345678910111213&lt;div class="bd"&gt; &lt;ul&gt; &lt;li class="current"&gt;我是体育模块&lt;/li&gt; &lt;li&gt;我是娱乐模块&lt;/li&gt; &lt;li&gt;我是新闻模块&lt;/li&gt; &lt;li&gt;我是综合模块&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;console.log($(".hd&gt;span"));//jquery对象console.log($(".hd&gt;span:first-child"));//jquery对象console.log($(".hd&gt;span").get(1));//DOM对象console.log($(".hd&gt;span").get());//DOM对象console.log($(".hd&gt;span")[1]);//DOM对象 5 注意jQuery对象和DOM对象的方法不能通用， DOM对象只能用 innerHTML，innerText ，属性操作 setAttribute() 、getAttribute() 、ele.style.property ； jQuery对象只能用html() text(), 属性操作，attr() 、prop( )、 css( );]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[jquery中position 方法]]></title>
      <url>%2F2015%2F12%2F15%2F04jquery%E4%B8%ADposition%20%E6%96%B9%E6%B3%95%2F</url>
      <content type="text"><![CDATA[position() jquery DOM一 相关position定位基准建议回顾： 1 DOM 中获取元素定位相关属性的方法： obj.style.property obj.currentStyle(attr) window.getComputedStyle(element,null)[attr] 将attr设置为 定位的 left top 等 即可。 2 jquery中获取定位元素的偏移，官方文档定义：获取匹配元素相对父元素的偏移。 返回的对象包含两个整型属性：top 和 left。 嗯，就是这么简洁。初学者需要注意,官方文档说的很模糊，我在这里详细说明一下： 二 代码： 12345678910111213141516171819202122232425262728 &lt;style&gt; *&#123; margin: 0; padding: 0; &#125; div&#123; border: 5px solid #000; width: 300px; height: 200px; margin: 100px; &#125; p&#123; border: 1px solid green; width: 200px; position: absolute; padding: 10px; margin: 25px; &#125; &lt;/style&gt;&lt;div&gt;&lt;p id="p2"&gt;这是一个段落&lt;/p&gt;&lt;/div&gt;&lt;script src="jquery-1.12.2.js"&gt;&lt;/script&gt;&lt;script&gt; var pos = $("#p2").position(); console.log(pos);//object console.log(pos.top);//105 console.log(pos.left);//105&lt;/script&gt; 定位还是按原来的走： 如果父元素有除了static定位以外的定位，那么就相对于父元素进行定位； 如果父元素没有定位，那么就相对于body定位 定位的基准是 ：子元素整体(margin +border+padding+content)的最外边界，相对于有定位的父元素或者body的内边界。 如果给div加一个定位 1position: absolute; 此时： console.log(pos);//object console.log(pos.top);//0 console.log(pos.left);//0 三：总结，jquery中position( )方法不能对定位进行设置，只能获取定位的top left 值，如果要设置定位的坐标，还是的用 css( ) 方法。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[eventBubble]]></title>
      <url>%2F2015%2F12%2F01%2F56-%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1%2F</url>
      <content type="text"><![CDATA[事件冒泡一、什么是事件冒泡在一个对象上触发某类事件（比如单击onclick事件，那么会一直冒泡直到document元素找click事件，然后执行处理程序，如果都没有绑定，那就算咯；比如onmouseover事件，也是会执行这样的过程），如果此对象定义了此事件的处理程序，那么此事件就会调用这个处理程序，如果没有定义此事件处理程序或者事件返回true，那么这个事件会向这个对象的父级对象传播，从里到外，直至它被处理（父级对象所有同类事件都将被激活），或者它到达了对象层次的最顶层，即document对象（有些浏览器是window）。 二、事件冒泡有什么作用（1）事件冒泡允许多个操作被集中处理（把事件处理器添加到一个父级元素上，避免把事件处理器添加到多个子级元素上），它还可以让你在对象层的不同级别捕获事件。 【集中处理例子】 12345678910111213&lt;div onclick="eventHandle(event)" id="outSide" style="width:100px; height:100px; background:#000; padding:50px"&gt; &lt;div id="inSide" style="width:100px; height:100px; background:#CCC"&gt;&lt;/div&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt;//本例子只在外面盒子定义了处理方法，而这个方法一样可以捕获到子元素点击行为并处理它。假设有成千上万子元素要处理，难道我们要为每个元素加“onclick="eventHandle(event)"”？显然没有这种集中处理的方法来的简单，同时它的性能也是更高的。function eventHandle(e)&#123; var e=e||window.event; var obj=e.target||e.srcElement; alert(obj.id+' was click')&#125;&lt;/script&gt;复制代码 （2）让不同的对象同时捕获同一事件，并调用自己的专属处理程序做自己的事情，就像老板一下命令，各自员工做自己岗位上的工作去了。 【同时捕获同一事件例子】 123456789101112131415161718192021222324&lt;div onclick="outSideWork()" id="outSide" style="width:100px; height:100px; background:#000; padding:50px"&gt; &lt;div onclick="inSideWork()" id="inSide" style="width:100px; height:100px; background:#CCC"&gt; &lt;/div&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt;function outSideWork()&#123; alert('My name is outSide,I was working...');&#125;function inSideWork()&#123; alert('My name is inSide,I was working...');&#125;//因为下面程序自动激活单击事件，有些浏览器不允许，所以请单击灰色盒子，从这里开始下命令，这样因为冒泡的原因，黑色大盒子也会收到单击事件，并调用了自己的处理程序。如果还有更多盒子嵌套，一样道理。/*function bossOrder()&#123; document.getElmentById('inSide').click();&#125;bossOrder();*/&lt;/script&gt; 三、需要注意什么●事件捕获其实有三种方式，事件冒泡只是其中的一种：（1）IE从里到外（inside→outside）的冒泡型事件。（2）Netscape4.0从外到里（outside→inside）的捕获型事件。（3）DOM事件流，先从外到里，再从里到外回到原点（outside→inside→outside）的事件捕获方法（似乎对象将触发两次事件处理，这有什么作用？鄙人不懂！）。 ●不是所有的事件都能冒泡。以下事件不冒泡：blur、focus、load、unload。 ●事件捕获方式在不同浏览器，甚至同种浏览器的不同版本中是有所区别的。如Netscape4.0采用捕获型事件解决方案，其它多数浏览器则支持冒泡型事件解决方案，另外DOM事件流还支持文本节点事件冒泡。 ●事件捕获到达顶层的目标在不同浏览器或不同浏览器版本也是有区别的。在IE6中HTML是接收事件冒泡的，另外大部分浏览器将冒泡延续到window对象，即……body→documen→window。 ●阻止冒泡并不能阻止对象默认行为。比如submit按钮被点击后会提交表单数据，这种行为无须我们写程序定制。 四、阻止事件冒泡通常情况下我们都是一步到位，明确自己的事件触发源，并不希望浏览器自作聪明、漫无目的地去帮我们找合适的事件处理程序，即我们明确最精准目标，这种情况下我们不需要事件冒泡。另外通过对事件冒泡的理解，我们知道程序将做多较多额外的事情，这必然增大程序开销。还有一个重要的问题是：事件冒泡处理可能会激活我们本来不想激活的事件，导致程序错乱，甚至无从下手调试，这常成为对事件冒泡不熟悉程序员的棘手问题。所以必要时，我们要阻止事件冒泡。 【不想激活的事件被激活例子】 1234567891011&lt;div onclick="openWin('http://www.baidu.com')" id="outSide" style="width:100px; height:100px; background:#000; padding:50px"&gt;&lt;div onclick="openWin('http://www.google.com')" id="inSide" style="width:100px; height:100px; background:#CCC"&gt;&lt;/div&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt;//本例你实际希望点击灰色盒子打开google首页，而点击黑色盒子打开baidu首页，但结果你点击灰色盒子的时候，却是同时打开了两个网页。其实在实际设计中较少遇到此问题，你可能会想如果我在页面不同DOM深处安置了不同的按钮或链接，深层处的事件触发会不会波及顶层的按钮呢？不会，因为按钮不能形成嵌套关系。function openWin(url)&#123; window.open(url);&#125;&lt;/script&gt; 本例你实际希望点击灰色盒子打开google首页，而点击黑色盒子打开baidu首页，但结果你点击灰色盒子的时候，却是同时打开了两个网页。其实在实际设计中较少遇到此问题，你可能会想如果我在页面不同DOM深处安置了不同的按钮或链接，深层处的事件触发会不会波及顶层的按钮呢？不会，因为按钮不能形成嵌套关系。 【阻止事件冒泡例子】 1234567891011121314151617181920212223&lt;div onclick="showMsg(this,event)" id="outSide" style="width:100px; height:100px; background:#000; padding:50px"&gt;&lt;div onclick="showMsg(this,event)" id="inSide" style="width:100px; height:100px; background:#CCC"&gt;&lt;/div&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt;//阻止事件冒泡后，你点击灰色盒子，整个过程只弹一次对话框了（注意与默认情况对比）function showMsg(obj,e)&#123; alert(obj.id); stopBubble(e)&#125;//阻止事件冒泡函数function stopBubble(e)&#123; if (e &amp;&amp; e.stopPropagation) e.stopPropagation() else window.event.cancelBubble=true; //或者如下 e&amp;&amp;e.stopPropagation ? e.stopPropagation : window.event.cancelBubble = true ;&#125; //或者在事件处理函数 return false也可以阻止事件冒泡，同时会取消对应的默认行为&lt;/script&gt; 【阻止事件默认行为】 12345e = e ? e : window.event ;e.preventDefault()//或者return false;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[HTTP(HyperText Transfer Protocol)]]></title>
      <url>%2F2015%2F11%2F14%2F62-HTTP%E5%8D%8F%E8%AE%AE%2F</url>
      <content type="text"><![CDATA[HTTP(HyperText Transfer Protocol)MIME (Multipurpose Internet Mail Extensions) 是描述消息内容类型的因特网标准。一 HTTP理解1 HTTP 服务器:即网站服务器，主要提供文档(文本、图片、视频、音频)浏览服务，一般安装Apache、Nginx服务器软件。HTTP服务器可以结合某一编程语言处理业务逻辑，由此进行的开发，通常称之为服务端开发。常见的运行在服务端的编程语言包 括 php、java、.net、Python、Ruby、Perl等。 如何搭建自己的HTTP服务器？ 安装wampsever:(Windows+Apache+Mysql+PHP) 配置安装根目录 配置虚拟主机 2 HTTP 协议:超文本传输协议（HTTP，HyperText Transfer Protocol) 网站是基于HTTP协议的， 例如网站的图片、CSS、JS等都是基于HTTP协议进行传输的。HTTP协议是由从客户机到服务器的请求(Request)和从服务器到客户机的响应(Response)进行了约束和规范。即HTTP协议主要由请求和响应构成。 3 请求和响应 3.1、请求行 由请求方式、请求URL和协议版本构成 12GET /day01/code/login.php?username=123&amp;password=123 HTTP/1.1POST /day01/code/login.php HTTP/1.1 3.2、请求头 Host：localhost请求的主机 Cache-Control：max-age=0控制缓存 Accept：/ 接受的文档MIME类型 121 如果是XHR对象和javascript标签发送请求，那么accept ：*/ * 代表接受所有的MIME类型的返回值;2 jQuery ajax发送请求的时候，如果设置了dataType 属性 User-Agent：很重要 Referer：从哪个URL跳转过来的 Accept-Encoding：可接受的压缩格式 If-None-Match：记录服务器响应的ETag值，用于控制缓存 此值是由服务器自动生成的 If-Modified-Since：记录服务器响应的Last-Modified值 此值是由服务器自动生成的 3.3、请求主体 即传递给服务端的数据 注：当以post形式提交表单的时候，请求头里会设置 Content-Type: application/x-www-form-urlencoded，以get形式当不需要 4 响应 响应由服务器发出，其规范格式为：状态行、响应头、响应主体。 4.1、状态行 由协议版本号、状态码和状态信息构成 HTTP/1.1 200 OK 4.2、响应头 Date：响应时间 Server：服务器信息 Last-Modified：资源最后修改时间 由服务器自动生成 ETag：资源修改后生成的唯一标识 由服务器自动生成 Content-Length：响应主体长度 Content-Type：响应资源的类型(header()函数可以定义返回的资源类型text/html 、text/javascript 、 ) 4.3、响应主体 即服务端返回给客户端的内容； 二 请求的”进化”；“标签”请求 form可以设置get和post a标签href发送请求get请求 iframe src属性 img src属性 script src属性 1 form表单method:get post方法请求 a 标签 都是以get发送请求 控制台 type document对象 ; 代表有document对象直接发送请求(这就是为什么页面会刷新的原因) 2 XMLHttpResponse 对象请求 ，该请求只允许请求当前源(域名，端口，协议)的资源，所以AJAX是不能跨域的 控制台 type 是 XMLHttpRequest 对象 ； 代表请求是由这个javascript内置对象发送的；所谓的ajax其实就是请求的发送以及响应体的接受都是由一个javascript对象XMLHttpRequest完成。页面不会刷新，可以通过js动态的加载元素。 3 跨域请求(同源策略:域名 协议 端口相同，当前域不能访问其他域的资源) script标签请求 script标签不受同源策略的限制 script 的src获取javascript;link的src获取 css； img的src获取图片资源； iframe 的src获取页面标 是允许跨域的，这些标签不受跨域的限制； 控制台 type script ，(如果我们用script标签请求其他网站的jQuery库，可以减少本网站的请求) Cross-Origin Resource Sharing（CORS）跨域资源共享是一份浏览器技术的规范，提供了 Web 服务从不同域传来沙盒脚本的方法，以避开浏览器的同源策略，是 JSONP 模式的现代版。 3.1 如何解决同源策略带来的问题，进行跨域？ 3.1.1 jsonp 单向跨域(get请求方式) 为什么script标签引入的文件不受同源策略的限制？因为script标签引入的文件内容是不能够被客户端的js获取到的，不会影响到被引用文件的安全，所以没必要使script标签引入的文件遵循浏览器的同源策略。而通过ajax加载的文件内容是能够被客户端js获取到的，所以ajax必须遵循同源策略，否则被引入文件的内容会泄漏或者存在其他风险。JSONP的缺点则是：它只支持GET请求而不支持POST等其它类型的HTTP请求 1234567//本域代码&lt;script&gt; function getUsers (obj)&#123; console.log(obj) &#125;&lt;/script&gt;&lt;script src="http://www.google.com/getUsers.php"&gt;&lt;/script&gt; 1234//需要谷歌支持，服务器代码如下，返回的是一个js代码的字符串，&lt;?php echo 'getUsers(["Jhon","JiM","kobe"])'; ?&gt; 3.1.2 Assess-Control 比如百度向谷歌发送一个请求，那么谷歌的服务器上的响应的文件上需要设置如下 1header("Access-Control-Allow-Origin: http://www.baidu.com");//表示允许baidu.com跨域请求本文件 4 HTML5新增API postMessage方法，HTML5系列博文有篇文章专门分析总结]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[jQuery js offset系列的不同]]></title>
      <url>%2F2015%2F11%2F10%2F17-jQuery%20js%20offset%E7%B3%BB%E5%88%97%E7%9A%84%E4%B8%8D%E5%90%8C%2F</url>
      <content type="text"><![CDATA[jQuery中和DOM中 offset系列的不同；一 offset jQuery中offset( ) 方法获取元素距离边界的值，该方法返回两个整形数值，一个代表left,一个代表top，其始终是获取的当前jquery对象相对于文档的边界的距离； 不写参数：jqueryObj.offset().left jqueryObj.offset().top 可以获取相应值 传入键值对参数：jQueryObj.offset({left:30,left:50});可以将匹配的元素设置距离边界的距离。 DOM中的offsetLeft offsetTop 获取元素距离边界值， 1)如果父元素有定位，那么DOM子元素是相对于父元素的border内边界的距离； 2)如果父元素没有定位，那么子元素是相对于文档边界的距离； 3)offsetLeft offsetTop 只能获取值，不能设置值，是一个只读属性； 4)offsetLeft 经常结合定位进行轮播图的封装，因为offsetLeft指的是子元素border外边界相对于父元素border内边界的距离，而定位的left值代表的也是这一段距离。 二，事件对象参数的offsetX offsetY clientX clientY的区别 先总结下区别： event.clientX、event.clientY 鼠标相对于浏览器窗口可视区域的X，Y坐标（窗口坐标），可视区域不包括工具栏和滚动条。IE事件和标准事件都定义了这2个属性 event.pageX、event.pageY 类似于event.clientX、event.clientY，但它们使用的是文档坐标而非窗口坐标。这2个属性不是标准属性，但得到了广泛支持。IE事件中没有这2个属性。 event.offsetX、event.offsetY 鼠标相对于事件源元素（srcElement）的X,Y坐标，只有IE事件有这2个属性，标准事件没有对应的属性。 event.screenX、event.screenY 鼠标相对于用户显示器屏幕左上角的X,Y坐标。标准事件和IE事件都定义了这2个属性]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[XML base]]></title>
      <url>%2F2015%2F11%2F09%2F66XML%2F</url>
      <content type="text"><![CDATA[XML 1 XML声明以及基础语法 1234567891011121314&lt;?xml version="1.0" encoding="ISO-8859-1"?&gt; &lt;!--第一行是 XML 声明。它定义 XML 的版本 (1.0) 和所使用的编码 (ISO-8859-1 = Latin-1/西欧字符集)。下一行描述文档的根元素--&gt;&lt;note&gt; &lt;to&gt;George&lt;/to&gt;&lt;from&gt;John&lt;/from&gt;&lt;heading&gt;Reminder&lt;/heading&gt;&lt;body&gt;Don't forget the meeting!&lt;/body&gt;&lt;/note&gt;&lt;root&gt; &lt;child id="brother"&gt; &lt;subchild&gt;.....&lt;/subchild&gt; &lt;/child&gt;&lt;/root&gt; 注意:xml如何形成良好的语法习惯 1)XML 文档必须有根元素 2) XML 文档必须有关闭标签 3)XML 标签对大小写敏感 4)XML 元素必须被正确的嵌套 5)XML 属性必须加引号 &lt; &lt; 小于 &gt; &gt; 大于 &amp; &amp; 和号 &apos; ‘ 单引号 &quot; “ 引号 2 xml命名规则:可使用任何名称，没有保留的字词。 1)名称可以含字母、数字以及其他的字符 2)名称不能以数字或者标点符号开始 3)名称不能以字符 “xml”（或者 XML、Xml）开始 4)名称不能包含空格 3 xml元素和属性:元数据（有关数据的数据）应当存储为属性，比如id 用来查找元素的，可以存储为属性；而数据本身应当存储为元素。 因使用属性而引起的一些问题,请尽量使用元素来描述数据。而仅仅使用属性来提供与数据无关的信息 1)属性无法包含多重的值（元素可以） 2)属性无法描述树结构（元素可以） 3)属性不易扩展（为未来的变化） 4)属性难以阅读和维护 4 xmlDOM XMLHttpRequest对象:XMLHttpRequest 对象提供了对 HTTP 协议的完全的访问，包括做出 POST 和 HEAD 请求以及普通的 GET 请求的能力。XMLHttpRequest 可以同步或异步地返回 Web 服务器的响应，并且能够以文本或者一个 DOM 文档的形式返回内容。尽管名为 XMLHttpRequest，它并不限于和 XML 文档一起使用：它可以接收任何形式的文本文档。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[toString()和valueof()的区别]]></title>
      <url>%2F2015%2F10%2F28%2F112-toString%E5%92%8CtoValue%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
      <content type="text"><![CDATA[toString()和valueof()的区别1.存在环境1所有的对象都继承了这两个方法，甚至于包装对象Number、String和Boolean。 2.具体细节12345678910对于不同类型的对象，js定义了多个版本的 toString 和 valueOf 方法toString:（1）普通对象，返回 &quot;[object Object]&quot;;（2）数组，返回数组元素之间添加逗号合并成的字符串;（3）函数，返回函数的定义式的字符串;（4）日期对象，返回一个可读的日期和时间字符串;（5）正则，返回其字面量表达式构成的字符串;valueOf:（1）日期对象，返回自1970年1月1日到现在的毫秒数;（2）其它均返回对象本身;比如数组，函数，对象等以及number 布尔类型 字符串的valueof()都将返回本身 123Object.prototype.valueOf()用 MDN 的话来说，valueOf() 方法返回指定对象的原始值。JavaScript 调用 valueOf() 方法用来把对象转换成原始类型的值（数值、字符串和布尔值）。但是我们很少需要自己调用此函数，valueOf 方法一般都会被 JavaScript 自动调用。 12toString() 方法返回一个表示该对象的字符串。每个对象都有一个 toString() 方法，当对象被表示为文本值时或者当以期望字符串的方式引用对象时，该方法被自动调用。 原始类型 12Number String Boolean Undefined Null在 JavaScript 进行对比或者各种运算的时候会把对象转换成这些类型，从而进行后续的操作 3.应用场景——类型转换1234567891011121314151617String类型转化 对象到字符串 （1）执行toString，如果返回了一个原始值，则将其转化为字符串（2）否则执行valueOf方法，如果返回了一个原始值，则将其转化为字符串（3）否则抛出类型错误 如果 toString 方法存在并且返回原始类型，返回 toString 的结果。 如果 toString 方法不存在或者返回的不是原始类型，调用 valueOf 方法，如果 valueOf 方法存在，并且返回原 始类型数据，返回 valueOf 的结果。 其他情况，抛出错误。Number类型转化 对象到数字（1）执行valueOf，如果返回了一个原始值，如果需要，则将其转化为数字（2）否则执行toString，如果返回了一个原始值，则将其转化为数字并返回（3）否则抛出类型错误 如果 valueOf 存在，且返回原始类型数据，返回 valueOf 的结果。 如果 toString 存在，且返回原始类型数据，返回 toString 的结果。 其他情况，抛出错误。 以上两种方式转换的情况，我们可以通过重写对象的valueOf()方法和toString()方法来看下javascript是如何选择执行的以及执行的顺序 4.类型转换与关系操作符(&gt;、&lt;等，不包括===和!==)12345- 两个都是数值，则比较数值- 两个都是字符串，则比较字符编码值- 其中一个是数值，则要把另个转化成数值进行比较- 如果其中一个是对象，则调用valueOf，若没有返回原始值则调用toString，再进行前面的比较- 如果有一个是布尔值，则将其转化成数值 注：日期对象只调用toString，不会调用valueOf方法]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[opacity和rgba 改变透明度的区别]]></title>
      <url>%2F2015%2F10%2F17%2F03opacity%E5%92%8Crgba%20%E6%94%B9%E5%8F%98%E9%80%8F%E6%98%8E%E5%BA%A6%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
      <content type="text"><![CDATA[一 opacity和rgba 改变透明度的区别 需要注意，rgba() 仅仅改变的是背景的透明度， 不会对文本造成影响，不具有继承性 然而，opacity 不仅会改变背景的透明度， 还会改变文本的透明度，并且具有继承性 二 代码演示： 123456789101112&lt;style&gt; div&#123; width: 500px; height: 100px; background-color: rgba(344,24,67,.3); &#125; &lt;/style&gt;&lt;div&gt;这一段话是div里面的文字,opacity 透明度会改变字体的透明度 ，rgba 则不会 &lt;p&gt;这一段话是p里面的文字，如果对div设置透明度的时候，用opacity那么将会被继承，如果用rgba设置 透明度的时候，则不会被继承 &lt;/p&gt;&lt;/div&gt; 12345678&lt;style&gt; div&#123; width: 500px; height: 100px; background-color: rgb(344,24,67); opacity: 0.3; &#125; &lt;/style&gt; 三 总结：在做项目的时候，尽量用rgba 来改变透明度，因为opacity透明度具有继承性，并且还会改变文本的透明度，会造成一些影响]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[文档坐标和视口坐标]]></title>
      <url>%2F2015%2F09%2F28%2F124-%E6%96%87%E6%A1%A3%E5%9D%90%E6%A0%87%E5%92%8C%E8%A7%86%E5%8F%A3%E5%9D%90%E6%A0%87%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
      <content type="text"><![CDATA[文档坐标和视口坐标1 二者区别 1.1 文档坐标是整个HTML 形成的坐标体系，视口是显示文档内容的 浏览器的一部分,它不包括浏览器的”外壳”，如菜单和工具栏和标签页 1.2 如果文档比视口要小，或者说文档还没有出现滚动，那么这个时候文档左上角就是视口左上角，文档坐标和视口坐标是同一个系统； 1.3 文档坐标是视口坐标更加基础，因为文档坐标系统是固定不变的，元素相对于文档坐标的位置是不变的；但是视口坐标系统就不一样了，元素相对于视口坐标的位置，在发生滚动的时候，是实时变化的； 2 获取窗口滚动条的位置 1234567891011function getSCroll()&#123; return &#123; left : window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft, top : window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop &#125; &#125; window.onscroll = function()&#123; var scroll = getSCroll(); console.log(scroll.left); console.log(scroll.top); &#125;; 3 获取窗口的可视区域的宽高 123456789101112function getClient()&#123; return &#123; width : window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth, height : window.innerHeight||document.documentElement.clientHeight||document.body.clientHeight &#125; &#125;//在文档根元素查询这些属性的时候，返回的值和窗口的innerHeight innerWidth属性值一样 window.onresize = function()&#123; var client = getClient(); console.log(client.width); console.log(client.height); &#125;; 4 获取文档内容的宽高 12var documentHeight = document.documentElement.offsetHeight;var documentWidth = document.documentElement.offsetWidth; 5 获取元素相对于视口坐标系统原点的距离 ele.getBoundingClientRect(); 返回一个数组,包括元素左上角和右下角距离视口坐标系统原点的距离，以及元素自身的宽高 12345678910111213141516 &lt;style&gt; div&#123; position: absolute; left: 100px; top: 150px; background-color: pink; height: 100px; width: 100px; &#125; &lt;/style&gt;&lt;div id = "div1"&gt;&lt;/div&gt; &lt;script&gt; var div1 = document.getElementById("div1"); var box = div1.getBoundingClientRect(); console.log(box);&lt;/script&gt; 6 获取元素相对于 文档坐标系统 原点 的 距离 ； offsetLeft offsetTop 用来获取元素(border边界)左上角相对于文档坐标原点的距离 或者 相对于 定位了的父元素 的border边界左上角的距离； 1234567891011function getElePos(ele)&#123; var x = 0,y = 0 ; while(ele != null )&#123; x += ele.offsetLeft; y += ele.offsetTop; ele = ele.offsetParent; console.log(ele); &#125; return &#123;x : x ,y: y &#125; &#125;//这个封装的方法可以获取任何元素相对于文档坐标系统原点的 x y 坐标值 对于不支持ele.getBoundingClientRect();获取元素相对于 视口坐标系统的浏览器来说 进行以下封装,用来获取元素相对于视口坐标系统的 x y的值 123456789101112131415function getElePos(ele)&#123; var x = 0,y = 0 ; for(var e = ele ; e != null ; e = e.offsetParent)&#123; x += e.offsetLeft; y += e.offsetTop; //获取元素相对于文档的坐标 &#125; for(var e = ele.parentNode ; e != null &amp;&amp; e.nodeType == 1 ;e = e.parentNode)&#123; console.log(e); x -= e.scrollLeft; y -= e.scrollTop ; //减去元素卷曲出去距离 &#125; return &#123;x : x ,y: y &#125; &#125; 5 滚动文档内容 window.scrollTo(x,y) window.scrollBy(x,y) 将文档内容滚动到距离 视口坐标左上角 x,y 处的位置；]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[forin 遍历数组和对象细节]]></title>
      <url>%2F2015%2F09%2F19%2F63-for-in%20%20%20foreach%20%20%20%2F</url>
      <content type="text"><![CDATA[for in1234567891011//for in 遍历的是数组的索引 ，而不是数组的值 var arr= ["name","age","address"] for (let key in arr )&#123; console.log(key); &#125;//---------------------------------------//遍历对象的时候，遍历的是对象的属性，而不是属性值 var obj = &#123;name:"Jhon",age:14&#125;; for(let key in obj)&#123; console.log(key); &#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[webStorm 运用快捷键]]></title>
      <url>%2F2015%2F09%2F12%2F29-webstorm%E7%BC%96%E8%BE%91%E5%99%A8%E8%BF%90%E7%94%A8%E5%B0%8F%E6%8A%80%E5%B7%A7%2F</url>
      <content type="text"><![CDATA[webstorm编辑器运用小技巧 1 如何比较两份文件的区别：先复制，然后与剪贴板进行比较: 视图–&gt;与剪贴板比较 2 webstorm默认是没有换行的: 单个文件设置：视图–活跃编辑器–启用自动换行 系统设置，每个文件都要自动换行：文件–设置–编辑器–softwraps–启用软换行 3 鼠标点击某个方法或者某个类，按住ctrl+鼠标左键，可以直接进入该方法或者类所在文件 4 快捷键设置 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849快捷键配置点击“File”-&gt; “settings”Webstorm预置了其他编辑器的快捷键配置，可以点击默认配置-Eclipse的常用快捷键对照表查找/代替Webstorm快捷键 Eclipse快捷键 说明ctrl+shift+N ctrl+shift+R 通过文件名快速查找工程内的文件（必记）ctrl+shift+alt+N ctrl+shift+alt+N 通过一个字符快速查找位置（必记）ctrl+F ctrl+F 在文件内快速查找代码F3 ctrl+K 查找下一个shift+F3 ctrl+shift+K 查找上一个ctrl+R ctrl+F 文件内代码替换ctrl+shift+R 指定目录内代码批量替换ctrl+shift+F ctrl+H 指定目录内代码批量查找界面操作Webstorm快捷键 Eclipse快捷键 说明ctrl+shift+A ctrl+shift+A 快速查找并使用编辑器所有功能（必记）alt+[0-9] alt+[0-9] 快速拆合功能界面模块ctrl+shift+F12 ctrl+shift+F12 最大区域显示代码（会隐藏其他的功能界面模块）alt+shift+F alt+shift+F 将当前文件加入收藏夹ctrl+alt+s ctrl+alt+s 打开配置窗口ctrl+tab ctrl+tab 切换代码选项卡（还要进行此选择，效率差些）alt+←/→ alt+←/→ 切换代码选项卡ctrl+F4 ctrl+F4 关闭当前代码选项卡代码编辑Webstorm快捷键 Eclipse快捷键 说明ctrl+D ctrl+shift+↑ 复制当前行ctrl+W alt+shift+↑ 选中单词ctrl+←/→ctrl+←/→以单词作为边界跳光标位置alt+insert alt+insert 新建一个文件或其他ctrl+alt+L ctrl+alt+L 格式化代码shift+tab/tab shift+tab/tab 减少/扩大缩进（可以在代码中减少行缩进）ctrl+Y ctrl+D 删除一行shift+enter shift+enter 重新开始一行（无论光标在哪个位置）导航Webstorm快捷键 Eclipse快捷键 说明esc esc 进入代码编辑区域alt+F1 alt+F1 查找代码在其他界面模块的位置，颇为有用ctrl+G ctrl+L 到指定行的代码ctrl+]/[ ctrl+]/[ 光标到代码块的前面或后面alt+up/down ctrl+shift+up/down 上一个/下一个方法]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[how to change the theme of hexo]]></title>
      <url>%2F2015%2F08%2F09%2F78-%E5%A6%82%E4%BD%95%E6%9B%B4%E6%94%B9github-hexo%E5%8D%9A%E5%AE%A2%E7%9A%84%E4%B8%BB%E9%A2%98%EF%BC%9F%2F</url>
      <content type="text"><![CDATA[如何更改github-hexo博客的主题？目前使用的主题是：yilia 在博客的根目录下（即上一篇文章使用Hexo框架自由搭建博客中提到的 Blog 文件夹下） 克隆主题1$ git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia 执行：1$ vim _config.yml 将 theme 对应的值进行修改1theme: yilia 接着就自动部署一下：1$ npm install hexo-deployer-git --save 最后发布：1$ hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 稍等片刻看一下自己的博客主页，你想要的效果就出现了。也可以点击 更多，挑选自己喜欢的主题进行修改，只要你快乐就好。 二、主题配置现在主题是更改过来了，但还有许多细节需要处理，比如说你需要修改头像等等。 首先进入到根目录下的 themes\yilia 文件夹，执行1$ vim _config.yml 就能看到这样信息，我是这样配置的：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758# Headermenu: 主页: / 所有文章: /archives # 随笔: /tags/随笔 # SubNavsubnav: github: &quot;https://github.com/Sjunxiao&quot; //github地址 #weibo: &quot;#&quot; //微博地址 rss: &quot;http://www.jianshu.com/users/fb696dcbd06b/latest_articles&quot; //订阅地址,我填的是自己的简书主页地址。 #zhihu: &quot;#&quot; // 下面这些前面带#的,就不显示在主页上,如果有账号,就可以打开 #douban: &quot;#&quot; #mail: &quot;#&quot; #facebook: &quot;#&quot; #google: &quot;#&quot; #twitter: &quot;#&quot; #linkedin: &quot;#&quot;rss: /atom.xml # Contentexcerpt_link: morefancybox: truemathjax: true# 是否开启动画效果animate: true# 是否在新窗口打开链接open_in_new: false# Miscellaneousgoogle_analytics: &apos;&apos;favicon: /favicon.png#你的头像urlavatar: &quot;https://avatars2.githubusercontent.com/u/19587420?v=3&amp;s=460&quot; //设置头像图片，可以直接拷贝Github头像链接#是否开启分享share_jia: trueshare_addthis: false#是否开启多说评论，填写你在多说申请的项目名称 duoshuo: duoshuo-key#若使用disqus，请在博客config文件中填写disqus_shortname，并关闭多说评论duoshuo: true //使用&apos;多说&apos;评论#是否开启云标签tagcloud: false#是否开启友情链接#不开启——#friends: ture#开启——friends: //下面可以设置自定义友情链接#是否开启“关于我”。#不开启——#aboutme: false#开启——aboutme: 像少年啦飞驰 //介绍 配置完成以后，回到 根目录（即上一篇文章使用Hexo框架自由搭建博客中提到的 Blog 文件夹），按顺序执行命令就OK啦。12$ npm install hexo-deployer-git --save $ hexo clean &amp;&amp; hexo g &amp;&amp; hexo d &lt;转载&gt; 那么如何使用 Hexo 建立一个属于自己的网站呢？ 一、 注册GitHub首先我们需要做的是去 GitHub 注册一个帐号，并创建一个Repository仓库。这里需要注意的是仓库的名称必须是 用户名.github.io ，才能使用 Github Pages . 二、配置SSH下载并安装 Git 。 1. 设置user name和email：12$ git config --global user.name &quot;你的GitHub用户名&quot;$ git config --global user.email &quot;你的GitHub注册邮箱&quot; 2. 生成ssh密钥:输入下面命令 1$ ssh-keygen -t rsa -C &quot;你的GitHub注册邮箱&quot; 一般情况下是不需要密码的，所以，接下来直接回车就好。 此时，在用户文件夹下就会有一个新的文件夹 .ssh ，里面有刚刚创建的ssh密钥文件 id_rsa和 id_rsa.pub 。 注：id_rsa文件是私钥，要妥善保管，id_rsa.pub是公钥文件。 3. 添加公钥到github：点击用户头像，进入Settings(设置)选项。在用户设置栏，点击SSH and GPG keys选项，然后点击New SSH key(新建SSH)按钮； 将id_rsa.pub中的内容复制到 Key 文本框中，然后点击Add SSH key(添加SSH)按钮。 4. 测试SSH：1$ ssh -T git@github.com 接下来会出来下面的确认信息： 123The authenticity of host &apos;github.com (207.97.227.239)&apos; can&apos;t be established. RSA key fingerprint is 17:24:ac:a5:76:28:24:36:62:1b:36:4d:eb:df:a6:45.Are you sure you want to continue connecting (yes/no)? 输入 yes 后回车。 然后显示如下信息则OK(其中的SeayXu是用户名)。 12Hi longluo! You&apos;ve successfully authenticated, but GitHub does not provide shell access. 以上是准备工作。 三、创建本地仓库1. 新建仓库文件夹这里就取名为blog。 1$ mkdir blog 在打开bash的地方新建一个文件夹 2. 初始化仓库安装hexo12$ npm install -g hexo-cli$ npm install -g hexo-server 进入到blog文件夹，执行初始化命令。 12$ cd blog # 切换到blog目录 可以从父目录到子目录$ git init # 初始化git仓库 在这个目录下初始化仓库 注：初始化要在Hexo安装之后执行，因为在hexo初始化的时候会从github上克隆代码，会创建.git文件夹。 如果在此之前初始化仓库会将原有的仓库信息覆盖掉，最后也会删除。 四、Hexo初始化之前必须先安装hexo客户端1. 安装HexoHexo是基于 NodeJS ，所以需要先安装NodeJS。 1$ npm install -g hexo-cli 2. 初始化框架12$ hexo init &lt;yourFolder&gt; 这个代表初始化哪个文件夹，如果直接在该文件夹下hexoinit则不需要folder$ cd &lt;yourFolder&gt; 3. 安装依赖1$ npm install 4. 初始化完成大概的目录：1234567891011.├── _config.yml //网站的`配置`信息，您可以在此配置大部分的参数。├── package.json├── db.json // json格式的静态常量数据库 ├── node_modules // Hexo的功能JavaScript文件├── public // 生成静态网页文件├── scaffolds //模版文件夹。当您新建文章时，Hexo会根据scaffold来建立文件。├── source //资源文件夹是存放用户资源的地方。| ├── _drafts // 草稿文件夹| └── _posts // 文章文件夹└── themes //主题文件夹。Hexo会根据主题来生成静态页面。 5. 新建文章（创建一个Hello World）1$ hexo new &lt;title&gt; for example: &quot;Hello World&quot; 在/source/_post里添加hello-world.md文件，之后新建的文章都将存放在此目录下。 如果要删除，直接在此文件夹下删除对应的文件即可。 6. 生成网站1$ hexo generate 此时会将/source的.md文件生成到/public中，形成网站的静态文件。 7. 服务器1$ hexo server -p 3000 输入 http://localhost:3000即可查看网站。 8. 部署网站1$ hexo deploy 该操作会将hexo生成的静态内容部署到配置的仓库中，请看下面介绍。 部署网站之前需要生成静态文件，即可以用 $ hexo generate -d 直接生成并部署。 此时需要在 _config.yml 中配置你所要部署的站点： 12345## Docs: http://hexo.io/docs/deployment.htmldeploy: type: git repo: git@github.com:YourRepository.git branch: master 如果没有意外，部署就成功了，可以打开 http://&lt;用户名&gt;.github.io 查看。 常用Hexo命令清除生成内容 1$ hexo c == hexo clean 执行此操作会删除 public 文件夹中的内容。 12$ hexo g == hexo generate$ hexo s == hexo server 五、使用Next主题让站点更酷炫1. 使用NexT Theme12$ cd your-hexo-site$ git clone https://github.com/iissnan/hexo-theme-next themes/next 从Next的Gihub仓库中获取最新版本。 2. Hexo NexT主题的文档结构1234567891011/languages #用来配置国际化语言版本，里边包含各种个配置像的文本翻译。/layout #以swig文件来定义各种含有配置信息调用的布局/scripts #一些JS脚本/source /css #用来修改自定义样式，需要掌握一定的css语法。 /fonts #定义字体文件，可以修改博客字体 /images #一些svg图片 /js #一些js脚本 /vendors /404.html #自定义的公益404页面/test #用于测试 3. 启用NexT主题需要修改/root/_config.yml配置项theme： 1234# Extensions## Plugins: http://hexo.io/plugins/## Themes: http://hexo.io/themes/theme: next 4. 验证是否启用1$ hexo s --debug 访问 http://localhost:4000，确保站点正确运行。（此命令可以做平时预览用） 六、总结通过以上步骤，我们就成功的实现了在Github上建立了一个高逼格的Hexo个人博客站点。 下面的事情就是不断的去写，去思考，去实践！ Complete By Long Luo @2016-3-08 23:12:01 at Shenzhen, China.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2015%2F07%2F29%2Fhello-world%2F</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
    </entry>

    
  
  
</search>
